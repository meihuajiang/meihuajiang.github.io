<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础 | ゼロツー</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="zerotwo">
    <link rel="preload" href="/assets/css/0.styles.f0b7ee7d.css" as="style"><link rel="preload" href="/assets/js/app.484f4375.js" as="script"><link rel="preload" href="/assets/js/2.ebbe98b4.js" as="script"><link rel="preload" href="/assets/js/115.adf2d1b9.js" as="script"><link rel="prefetch" href="/assets/js/10.91de1805.js"><link rel="prefetch" href="/assets/js/100.1772503e.js"><link rel="prefetch" href="/assets/js/101.b569a1af.js"><link rel="prefetch" href="/assets/js/102.65dffa11.js"><link rel="prefetch" href="/assets/js/103.d7a8cd9e.js"><link rel="prefetch" href="/assets/js/104.0a0e3708.js"><link rel="prefetch" href="/assets/js/105.15bc167a.js"><link rel="prefetch" href="/assets/js/106.8487cf9a.js"><link rel="prefetch" href="/assets/js/107.2310b94b.js"><link rel="prefetch" href="/assets/js/108.781b7ebe.js"><link rel="prefetch" href="/assets/js/109.6225704a.js"><link rel="prefetch" href="/assets/js/11.9c44c6b2.js"><link rel="prefetch" href="/assets/js/110.3c39cb3c.js"><link rel="prefetch" href="/assets/js/111.22bede53.js"><link rel="prefetch" href="/assets/js/112.acb6b722.js"><link rel="prefetch" href="/assets/js/113.c2b6115e.js"><link rel="prefetch" href="/assets/js/114.cbeddf77.js"><link rel="prefetch" href="/assets/js/116.3f23eb5b.js"><link rel="prefetch" href="/assets/js/117.00cb8ac3.js"><link rel="prefetch" href="/assets/js/118.e88e1cfb.js"><link rel="prefetch" href="/assets/js/119.213aaa9b.js"><link rel="prefetch" href="/assets/js/12.878aa51b.js"><link rel="prefetch" href="/assets/js/120.fc12eb0e.js"><link rel="prefetch" href="/assets/js/121.67bafb52.js"><link rel="prefetch" href="/assets/js/122.cca49856.js"><link rel="prefetch" href="/assets/js/123.0e27eb9e.js"><link rel="prefetch" href="/assets/js/124.53383547.js"><link rel="prefetch" href="/assets/js/125.e103d7f1.js"><link rel="prefetch" href="/assets/js/126.adb34a41.js"><link rel="prefetch" href="/assets/js/127.f352dcec.js"><link rel="prefetch" href="/assets/js/128.9aa22460.js"><link rel="prefetch" href="/assets/js/129.02dabe8a.js"><link rel="prefetch" href="/assets/js/13.b4c5b1dd.js"><link rel="prefetch" href="/assets/js/130.7d88cb43.js"><link rel="prefetch" href="/assets/js/14.dce5d003.js"><link rel="prefetch" href="/assets/js/15.ec0f3b1f.js"><link rel="prefetch" href="/assets/js/16.a9597b38.js"><link rel="prefetch" href="/assets/js/17.c8f44f51.js"><link rel="prefetch" href="/assets/js/18.67e67934.js"><link rel="prefetch" href="/assets/js/19.2b8ea36f.js"><link rel="prefetch" href="/assets/js/20.ee5ab76e.js"><link rel="prefetch" href="/assets/js/21.1582f8ed.js"><link rel="prefetch" href="/assets/js/22.130fb5fa.js"><link rel="prefetch" href="/assets/js/23.ecbb4b5d.js"><link rel="prefetch" href="/assets/js/24.0c8b3ecd.js"><link rel="prefetch" href="/assets/js/25.4aae22ea.js"><link rel="prefetch" href="/assets/js/26.4816aa3d.js"><link rel="prefetch" href="/assets/js/27.2e6f0659.js"><link rel="prefetch" href="/assets/js/28.7e0fef24.js"><link rel="prefetch" href="/assets/js/29.dad88d85.js"><link rel="prefetch" href="/assets/js/3.5e8d6a69.js"><link rel="prefetch" href="/assets/js/30.1ecf79ca.js"><link rel="prefetch" href="/assets/js/31.0a97fafc.js"><link rel="prefetch" href="/assets/js/32.8e6151d1.js"><link rel="prefetch" href="/assets/js/33.b5ff95d1.js"><link rel="prefetch" href="/assets/js/34.0d03faf5.js"><link rel="prefetch" href="/assets/js/35.6d4b4665.js"><link rel="prefetch" href="/assets/js/36.b42cbedf.js"><link rel="prefetch" href="/assets/js/37.4de10dce.js"><link rel="prefetch" href="/assets/js/38.9031eb30.js"><link rel="prefetch" href="/assets/js/39.daee868f.js"><link rel="prefetch" href="/assets/js/4.ceb8a314.js"><link rel="prefetch" href="/assets/js/40.df374a26.js"><link rel="prefetch" href="/assets/js/41.563436c6.js"><link rel="prefetch" href="/assets/js/42.b9200ca4.js"><link rel="prefetch" href="/assets/js/43.40ae12a3.js"><link rel="prefetch" href="/assets/js/44.4a0dd48e.js"><link rel="prefetch" href="/assets/js/45.20d657cc.js"><link rel="prefetch" href="/assets/js/46.2d34fe10.js"><link rel="prefetch" href="/assets/js/47.3dcb2d38.js"><link rel="prefetch" href="/assets/js/48.1b0959df.js"><link rel="prefetch" href="/assets/js/49.6652f2b2.js"><link rel="prefetch" href="/assets/js/5.b28c76e0.js"><link rel="prefetch" href="/assets/js/50.30bdc802.js"><link rel="prefetch" href="/assets/js/51.ebe5930a.js"><link rel="prefetch" href="/assets/js/52.02f2caf4.js"><link rel="prefetch" href="/assets/js/53.55df3fc5.js"><link rel="prefetch" href="/assets/js/54.e2bff3b5.js"><link rel="prefetch" href="/assets/js/55.c859c458.js"><link rel="prefetch" href="/assets/js/56.d493a61b.js"><link rel="prefetch" href="/assets/js/57.9af46dbf.js"><link rel="prefetch" href="/assets/js/58.46d4e8aa.js"><link rel="prefetch" href="/assets/js/59.82e453fe.js"><link rel="prefetch" href="/assets/js/6.b43fc5c2.js"><link rel="prefetch" href="/assets/js/60.d9652552.js"><link rel="prefetch" href="/assets/js/61.bad1d82a.js"><link rel="prefetch" href="/assets/js/62.8c307334.js"><link rel="prefetch" href="/assets/js/63.7ebafb7e.js"><link rel="prefetch" href="/assets/js/64.bc588101.js"><link rel="prefetch" href="/assets/js/65.6f66d6a2.js"><link rel="prefetch" href="/assets/js/66.ee6f0d41.js"><link rel="prefetch" href="/assets/js/67.0002a9a5.js"><link rel="prefetch" href="/assets/js/68.4a86ea26.js"><link rel="prefetch" href="/assets/js/69.c9e36070.js"><link rel="prefetch" href="/assets/js/7.87b3f924.js"><link rel="prefetch" href="/assets/js/70.40af8c94.js"><link rel="prefetch" href="/assets/js/71.ee207bd6.js"><link rel="prefetch" href="/assets/js/72.c389068e.js"><link rel="prefetch" href="/assets/js/73.c1526d9c.js"><link rel="prefetch" href="/assets/js/74.cd1c9d32.js"><link rel="prefetch" href="/assets/js/75.144c1f5b.js"><link rel="prefetch" href="/assets/js/76.4c36bfbf.js"><link rel="prefetch" href="/assets/js/77.7db5b3f1.js"><link rel="prefetch" href="/assets/js/78.de99e748.js"><link rel="prefetch" href="/assets/js/79.1febcdca.js"><link rel="prefetch" href="/assets/js/8.ab13bda4.js"><link rel="prefetch" href="/assets/js/80.e802c8bb.js"><link rel="prefetch" href="/assets/js/81.960e4a52.js"><link rel="prefetch" href="/assets/js/82.9a35963d.js"><link rel="prefetch" href="/assets/js/83.005e1aad.js"><link rel="prefetch" href="/assets/js/84.d61f7f01.js"><link rel="prefetch" href="/assets/js/85.0906b75c.js"><link rel="prefetch" href="/assets/js/86.dff86ecd.js"><link rel="prefetch" href="/assets/js/87.00755e79.js"><link rel="prefetch" href="/assets/js/88.00604a67.js"><link rel="prefetch" href="/assets/js/89.376832c9.js"><link rel="prefetch" href="/assets/js/9.b83e9e02.js"><link rel="prefetch" href="/assets/js/90.9be39541.js"><link rel="prefetch" href="/assets/js/91.d5eb29c9.js"><link rel="prefetch" href="/assets/js/92.9f5fba68.js"><link rel="prefetch" href="/assets/js/93.670dcf5c.js"><link rel="prefetch" href="/assets/js/94.9d783387.js"><link rel="prefetch" href="/assets/js/95.0fd08cc1.js"><link rel="prefetch" href="/assets/js/96.ae0eb4f1.js"><link rel="prefetch" href="/assets/js/97.1d15ea38.js"><link rel="prefetch" href="/assets/js/98.1bc97ef6.js"><link rel="prefetch" href="/assets/js/99.d91a7a9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f0b7ee7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./favicon.jpg" alt="ゼロツー" class="logo"> <span class="site-name can-hide">ゼロツー</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link router-link-active">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link router-link-active">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/vue/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/frontend/vue/asyncRoutes.html" class="sidebar-link">动态路由</a></li><li><a href="/frontend/vue/code.html" class="sidebar-link">watch 和 computed 源码</a></li><li><a href="/frontend/vue/component.html" class="sidebar-link">组件开发</a></li><li><a href="/frontend/vue/framework.html" class="sidebar-link">框架</a></li><li><a href="/frontend/vue/lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/frontend/vue/options.html" class="sidebar-link">选项</a></li><li><a href="/frontend/vue/reactive.html" class="sidebar-link">响应式原理</a></li><li><a href="/frontend/vue/vdom.html" class="sidebar-link">虚拟 DOM</a></li><li><a href="/frontend/vue/vue.html" aria-current="page" class="active sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#object-defineproporty内部怎么实现数据劫持的" class="sidebar-link">Object.defineproporty内部怎么实现数据劫持的</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#data-数据是怎么挂到-vue-实例上面" class="sidebar-link">data 数据是怎么挂到 Vue 实例上面</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue3改用proxy的好处" class="sidebar-link">Vue3改用proxy的好处</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#computed-和-watch-的区别" class="sidebar-link">computed 和 watch 的区别</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#methods" class="sidebar-link">methods</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#在-vue-中怎么声明数据才能防止被-vue-监听" class="sidebar-link">在 Vue 中怎么声明数据才能防止被 Vue 监听⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-组件的data为什么是函数形式" class="sidebar-link">Vue 组件的data为什么是函数形式</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#v-for-和-v-if-的区别" class="sidebar-link">v-for 和 v-if 的区别</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#v-for使用key和不使用key有什么区别" class="sidebar-link">v-for使用key和不使用key有什么区别⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#v-if-和-v-show的区别，在dom树上表现一样吗" class="sidebar-link">v-if 和 v-show的区别，在DOM树上表现一样吗</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-就地复用原则" class="sidebar-link">Vue 就地复用原则</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#v-model-的实现原理" class="sidebar-link">v-model 的实现原理⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#nexttick" class="sidebar-link">nextTick⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#process-next-tick-和-vue-next-tick" class="sidebar-link">process.next.Tick() 和 Vue next.Tick()</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#diff算法" class="sidebar-link">diff算法⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#实现源码中的patch函数，伪代码" class="sidebar-link">实现源码中的patch函数，伪代码⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#template编译render过程（ast）" class="sidebar-link">template编译render过程（AST）</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#template的渲染过程" class="sidebar-link">template的渲染过程</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#mixin" class="sidebar-link">mixin⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#组件通信的方法" class="sidebar-link">组件通信的方法</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#父组件调用子组件方法的方式有哪些" class="sidebar-link">父组件调用子组件方法的方式有哪些⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#v-slot：" class="sidebar-link">v-slot：</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue常用指令" class="sidebar-link">Vue常用指令</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-自定义指令-directive" class="sidebar-link">Vue 自定义指令 directive⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue的过滤器、指令和组件的使用场景有什么差异？" class="sidebar-link">Vue的过滤器、指令和组件的使用场景有什么差异？</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue跨页面通信" class="sidebar-link">Vue跨页面通信</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#一个页面跳转到另一个页面，数据怎么传递" class="sidebar-link">一个页面跳转到另一个页面，数据怎么传递</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue内置组件" class="sidebar-link">Vue内置组件</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#写一个通用组件需要考虑哪些问题" class="sidebar-link">写一个通用组件需要考虑哪些问题</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#说说vue的scoped" class="sidebar-link">说说Vue的scoped</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#动态组件" class="sidebar-link">动态组件</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue如何解决回流重绘的问题" class="sidebar-link">Vue如何解决回流重绘的问题</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue路由懒加载" class="sidebar-link">Vue路由懒加载</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#父组件变化，怎么避免子组件不必要的更新" class="sidebar-link">父组件变化，怎么避免子组件不必要的更新</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue整体初始化流程" class="sidebar-link">Vue整体初始化流程</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-set-用法" class="sidebar-link">Vue $set 用法</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-插件" class="sidebar-link">Vue 插件</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#缩写" class="sidebar-link">缩写</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#如果页面上有很多个-checkbox-怎么尽可能少的向后台传输数据" class="sidebar-link">如果页面上有很多个 checkbox 怎么尽可能少的向后台传输数据</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue不可以写jsx吗" class="sidebar-link">Vue不可以写jsx吗</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#高阶vue函数用过哪些" class="sidebar-link">高阶Vue函数用过哪些</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue模板解析的过程" class="sidebar-link">Vue模板解析的过程</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-cli做过哪些配置" class="sidebar-link">Vue-cli做过哪些配置</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#反向代理" class="sidebar-link">反向代理</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue数组用下标更改元素会更新视图吗？那用什么方法可以更新？" class="sidebar-link">Vue数组用下标更改元素会更新视图吗？那用什么方法可以更新？</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#权限控制的路由是怎么配置的？" class="sidebar-link">权限控制的路由是怎么配置的？⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#vue-loader的工作原理" class="sidebar-link">Vue loader的工作原理</a></li><li class="sidebar-sub-header"><a href="/frontend/vue/vue.html#如何手动搭建一个vue项目（不使用脚手架）" class="sidebar-link">如何手动搭建一个Vue项目（不使用脚手架）</a></li></ul></li><li><a href="/frontend/vue/vue-cli.html" class="sidebar-link">Vue-cli</a></li><li><a href="/frontend/vue/vue-router.html" class="sidebar-link">Vue-router</a></li><li><a href="/frontend/vue/vue3.html" class="sidebar-link">Vue3</a></li><li><a href="/frontend/vue/vuex.html" class="sidebar-link">Vuex</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="待填坑"><a href="#待填坑" class="header-anchor">#</a> 待填坑</h1> <h2 id="object-defineproporty内部怎么实现数据劫持的"><a href="#object-defineproporty内部怎么实现数据劫持的" class="header-anchor">#</a> Object.defineproporty内部怎么实现数据劫持的</h2> <p>简单实现示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
					<span class="token comment">//依赖收集</span>
                    dep<span class="token punctuation">.</span><span class="token function">addSubs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> value<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token comment">// 防止 newVal为对象的情况，需要重新将对象中的属性变为响应式</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                value <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
				<span class="token comment">//派发更新</span>
                dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际上是对 watcher 的管理</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">addSubs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">watcher</span> <span class="token operator">=&gt;</span> watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Watcher</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> expr<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>expr <span class="token operator">=</span> expr<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> newVal<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>expr <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            newVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            newVal <span class="token operator">=</span> compileUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>expr<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// let newVal = compileUtil.getValue(this.expr, this.$vm);</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>expr <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> compileUtil<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>expr<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        window<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/img/data.png" alt="响应式原理"></p> <h3 id="vue检测对象的变化"><a href="#vue检测对象的变化" class="header-anchor">#</a> Vue检测对象的变化</h3> <p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token operator">:</span><span class="token punctuation">{</span>
    a<span class="token operator">:</span><span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// `vm.a` 是响应式的</span>
vm<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token comment">// `vm.b` 是非响应式的</span>
</code></pre></div><p>Vue 为了解决这个问题，定义了一个全局 API Vue.set 方法</p> <h3 id="vue检测数组的变化"><a href="#vue检测数组的变化" class="header-anchor">#</a> Vue检测数组的变化</h3> <p>Vue 不能检测以下数组的变动：</p> <ul><li><p>当利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></p> <p>解决方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方式一、Vue.set</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
<span class="token comment">// 方式二、Array.prototype.splice</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>当修改数组的长度时，例如：<code>vm.items.length = newLength</code></p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>newLength<span class="token punctuation">)</span>
</code></pre></div></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../util/index'</span>

<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>

<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache original method</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看到，arrayMethods 首先继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 <code>push</code>、<code>unshift</code>、<code>splice</code> 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知，这就很好地解释了之前的示例中调用 vm.items.splice(newLength) 方法可以检测到变化。</p> <h2 id="data-数据是怎么挂到-vue-实例上面"><a href="#data-数据是怎么挂到-vue-实例上面" class="header-anchor">#</a> data 数据是怎么挂到 Vue 实例上面</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">initData</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data
  data <span class="token operator">=</span> vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'data functions should return an object:\n'</span> <span class="token operator">+</span>
      <span class="token string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// proxy data on instance</span>
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props
  <span class="token keyword">const</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>methods
  <span class="token keyword">let</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span>length
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Method &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; has already been defined as a data property.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
          vm
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The data property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is already declared as a prop. </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Use prop default value instead.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// observe data</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/img/new-vue.png" alt="Vue 渲染过程"></p> <h3 id="vue中data里申明一个空对象，然后再template中对对象进行属性绑定，请问能显示嘛？如果不能应该使用什么方法？"><a href="#vue中data里申明一个空对象，然后再template中对对象进行属性绑定，请问能显示嘛？如果不能应该使用什么方法？" class="header-anchor">#</a> Vue中data里申明一个空对象，然后再template中对对象进行属性绑定，请问能显示嘛？如果不能应该使用什么方法？</h3> <h3 id="vue2重写了哪些数组方法"><a href="#vue2重写了哪些数组方法" class="header-anchor">#</a> Vue2重写了哪些数组方法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../util/index'</span>

<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>

<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache original method</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="如何解决vue2-0不能通过索引改变数组的问题"><a href="#如何解决vue2-0不能通过索引改变数组的问题" class="header-anchor">#</a> 如何解决Vue2.0不能通过索引改变数组的问题⭐️</h3> <ul><li><p>当利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></p> <p>解决方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方式一、Vue.set</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
<span class="token comment">// 方式二、Array.prototype.splice</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>当修改数组的长度时，例如：<code>vm.items.length = newLength</code></p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>newLength<span class="token punctuation">)</span>
</code></pre></div></li></ul> <h3 id="为什么defineproperty不能获取数组的变更"><a href="#为什么defineproperty不能获取数组的变更" class="header-anchor">#</a> 为什么defineProperty不能获取数组的变更</h3> <h2 id="vue3改用proxy的好处"><a href="#vue3改用proxy的好处" class="header-anchor">#</a> Vue3改用proxy的好处</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre></div><ul><li><p>target</p> <p>被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</p></li></ul> <p>Object.defineProperty无法监控到数组长度的变化，以及通过数组下标修改元素，通过其他变通方法实现；Object.defineProperty本身是可以监控到数组下标的变化的，但是在 Vue 中，从性能/体验的性价比考虑，就弃用了这个特性。</p> <blockquote><p>数组的 length 属性的configurable是false，然后各大浏览器厂商包括JS本身，也不允许将length的configurable修改为true</p></blockquote> <p>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</p> <blockquote><p>和 Object.defineProperty() 一样。Proxy 也是不支持嵌套的,因此也需要通过逐层遍历来解决。</p></blockquote> <p>Proxy不仅可以代理对象，还可以代理数组。还可以<strong>代理动态增加的属性。</strong></p> <h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="header-anchor">#</a> computed 和 watch 的区别</h2> <p>计算属性本质上是 <code>computed watcher</code>，而侦听属性本质上是 <code>user watcher</code>。</p> <p>就应用场景而言，计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。(例如数据变化时执行异步操作)</p> <p>computed内部实现了一个惰性的watcher，在实例化的时候不会去求值，其内部通过dirty属性标记计算属性是否需要重新求值。当computed依赖的任一状态（不一定是return中的）发生变化，都会通知这个惰性watcher，让它把dirty属性设置为true。所以，当再次读取这个计算属性的时候，就会重新去求值。</p> <h3 id="watch中deep和immediate的作用"><a href="#watch中deep和immediate的作用" class="header-anchor">#</a> watch中deep和immediate的作用</h3> <p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code></p> <p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  immediate<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 立即以 `a` 的当前值触发回调</span>
</code></pre></div><p>注意在带有 immediate 选项时，不能在第一次回调时取消侦听给定的 property。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这会导致报错</span>
<span class="token keyword">var</span> unwatch <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span>
  <span class="token string">'value'</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">unwatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> immediate<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><h3 id="watch的newval和oldval"><a href="#watch的newval和oldval" class="header-anchor">#</a> watch的newVal和oldVal</h3> <p>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值</p> <p>在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。</p> <p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调</p> <h3 id="vue中computed的内部实现"><a href="#vue中computed的内部实现" class="header-anchor">#</a> Vue中computed的内部实现</h3> <p>computed内部实现了一个惰性的watcher，在实例化的时候不会去求值，其内部通过dirty属性标记计算属性是否需要重新求值。当computed依赖的任一状态（不一定是return中的）发生变化，都会通知这个惰性watcher，让它把dirty属性设置为true。所以，当再次读取这个计算属性的时候，就会重新去求值。</p> <h3 id="vue的计算属性可以通过this改变吗"><a href="#vue的计算属性可以通过this改变吗" class="header-anchor">#</a> Vue的计算属性可以通过this改变吗</h3> <p>计算属性默认只有 getter，不过在需要时也可以提供一个 setter</p> <h3 id="vue能不能监听新属性，如何实现"><a href="#vue能不能监听新属性，如何实现" class="header-anchor">#</a> Vue能不能监听新属性，如何实现</h3> <p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的</p> <p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property</p> <h2 id="methods"><a href="#methods" class="header-anchor">#</a> methods</h2> <h3 id="vue中的methods中如何解决this指向的问题"><a href="#vue中的methods中如何解决this指向的问题" class="header-anchor">#</a> Vue中的methods中如何解决this指向的问题</h3> <p>为了避免this指向出现歧义，有两种方法绑定this。</p> <p>使用bind</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">showMessage1</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;id1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//对setTimeout()里的匿名函数使用bind()绑定到vue实例的this。这样在匿名函数内的this也为vue实例</span>
</code></pre></div><p>把vue实例的this赋值给另一个变量再使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">showMessage1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>也可以改为
<span class="token function-variable function">showMessage1</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;id1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> self<span class="token punctuation">.</span>message<span class="token punctuation">;</span>  <span class="token comment">//改为self</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="在-vue-中怎么声明数据才能防止被-vue-监听"><a href="#在-vue-中怎么声明数据才能防止被-vue-监听" class="header-anchor">#</a> 在 Vue 中怎么声明数据才能防止被 Vue 监听⭐️</h2> <ul><li>Object.freeze()</li> <li>v-once,只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li></ul> <h2 id="vue-组件的data为什么是函数形式"><a href="#vue-组件的data为什么是函数形式" class="header-anchor">#</a> Vue 组件的data为什么是函数形式</h2> <p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：</p> <p>如果是对象形式，这就表示所有的组件实例共用了一份data数据，因此，无论在哪个组件实例中修改了data,都会影响到所有的组件实例。</p> <h3 id="data能不能写成-return-形式"><a href="#data能不能写成-return-形式" class="header-anchor">#</a> data能不能写成 return 形式</h3> <p>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="data在哪个阶段不能访问"><a href="#data在哪个阶段不能访问" class="header-anchor">#</a> data在哪个阶段不能访问</h3> <p>beforeCreate阶段</p> <h2 id="v-for-和-v-if-的区别"><a href="#v-for-和-v-if-的区别" class="header-anchor">#</a> v-for 和 v-if 的区别</h2> <p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p> <p>用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p> <h3 id="vue-能不能在v-for中嵌套v-if"><a href="#vue-能不能在v-for中嵌套v-if" class="header-anchor">#</a> Vue 能不能在v-for中嵌套v-if</h3> <p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级</p> <blockquote><p>vue3 中优先级发生了改变，待验证</p></blockquote> <h2 id="v-for使用key和不使用key有什么区别"><a href="#v-for使用key和不使用key有什么区别" class="header-anchor">#</a> v-for使用key和不使用key有什么区别⭐️</h2> <p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p> <p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</p> <p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 <code>key</code></p> <p>key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> <p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p> <p>简单示例：</p> <p><img src="/img/v2-6e88cc53a7e427f0ae8340cf930ac30d_720w.png" alt="添加节点"></p> <p>在B和C之间加一个F，Diff算法默认执行起来是这样的：</p> <p><img src="/img/v2-bf76311258f100b789226ccbb2600071_720w.png" alt="没有使用key"></p> <p>所以需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p> <h3 id="列表组件的-key-可以使用-index-吗"><a href="#列表组件的-key-可以使用-index-吗" class="header-anchor">#</a> 列表组件的 key 可以使用 index 吗⭐️</h3> <p>必须要保证key和之后要展示的元素是一一对应的。</p> <p>如果我们的key的值使用index：</p> <p><img src="/img/856460148-5ead9fd177d3b_article732.png" alt="没有对应上"></p> <p>同一个元素C，数据修改前C的index是2，修改后变成了3，使index和item不是一一对应的了</p> <p>index作为key，其实就等于不加key</p> <p>示例，将k1删除，可以看到k1，k2复用（然后更新数据），k3被删除
<img src="/img/006tNc79gy1g5tfjbc658j30hg0e6wff.jpg" alt="index作为key"></p> <ol><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</li> <li>如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。</li> <li>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</li></ol> <h2 id="v-if-和-v-show的区别，在dom树上表现一样吗"><a href="#v-if-和-v-show的区别，在dom树上表现一样吗" class="header-anchor">#</a> v-if 和 v-show的区别，在DOM树上表现一样吗</h2> <p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p> <p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p> <p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p> <p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p> <div class="custom-block tip"><p class="custom-block-title">说明</p> <p>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</p> <p>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的<code>display:none</code>；</p> <p>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值</p></div> <h2 id="vue-就地复用原则"><a href="#vue-就地复用原则" class="header-anchor">#</a> Vue 就地复用原则</h2> <p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p> <p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</p> <p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 <code>key</code></p> <p>key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> <p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p> <h3 id="v-for就地复用原理"><a href="#v-for就地复用原理" class="header-anchor">#</a> v-for就地复用原理</h3> <h2 id="v-model-的实现原理"><a href="#v-model-的实现原理" class="header-anchor">#</a> v-model 的实现原理⭐️</h2> <p><code>v-model</code>是<code>v-bind</code>和<code>v-on</code>的语法糖，是vue双向绑定的真正实现</p> <p>自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>等价于：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText = $event.target.value<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">addProp</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token function">addHandler</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> event<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre></div><p>这实际上就是 input 实现 v-model 的精髓，通过修改 AST 元素，给 el 添加一个 prop，相当于我们在 input 上动态绑定了 value，又给 el 添加了事件处理，相当于在 input 上绑定了 input 事件，</p> <p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p> <ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li> <li>checkbox 和 radio 使用 checked property 和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <p>v-model的限制：<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>、<code>components</code></p> <h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> nextTick⭐️</h2> <p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p> <p>然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p> <p>例如，当设置 <code>vm.someData = 'new value'</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。例如：</p> <h2 id="process-next-tick-和-vue-next-tick"><a href="#process-next-tick-和-vue-next-tick" class="header-anchor">#</a> process.next.Tick() 和 Vue next.Tick()</h2> <h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法⭐️</h2> <p>React 和 Vue 做的假设是：</p> <ul><li>检测VDOM的变化只发生在同一层</li> <li>检测VDOM的变化依赖于用户指定的key</li></ul> <ol><li>如果父节点不同，放弃对子节点的比较，直接删除旧节点然后添加新的节点重新渲染；</li> <li>如果子节点有变化，Virtual DOM不会计算变化的是什么，而是重新渲染，</li> <li>通过唯一的key策略</li></ol> <p>如果变化发生在不同层或者同样的元素用户指定了不同的key或者不同元素用户指定同样的key，React 和 Vue都不会检测到，就会发生莫名其妙的问题。</p> <p>但是React 认为，前端碰到上面的第一种情况概率很小，第二种情况又可以通过提示用户，让用户去解决，因此这个取舍是值得的。 没有牺牲空间复杂度，却换来了在大多数情况下时间上的巨大提升。</p> <h3 id="时间复杂度"><a href="#时间复杂度" class="header-anchor">#</a> 时间复杂度</h3> <p>O(n*3)-&gt;O(n)</p> <p>传统diff算法
<a href="/img/8901652-829ed2769504d3b5.webp.jpg">传统diff</a></p> <h3 id="怎么遍历"><a href="#怎么遍历" class="header-anchor">#</a> 怎么遍历</h3> <p>同层之间进行比较</p> <h2 id="实现源码中的patch函数，伪代码"><a href="#实现源码中的patch函数，伪代码" class="header-anchor">#</a> 实现源码中的patch函数，伪代码⭐️</h2> <ol><li><p>组件更新的过程，会执行 <code>vm.$el = vm.__patch__(prevVnode, vnode)</code>，它会调用 patch 函数，执行<code>sameNode</code>函数</p></li> <li><p>新旧节点不同</p> <ol><li>创建新节点</li> <li>更新父占位节点</li> <li>删除旧节点</li></ol></li> <li><p>新旧节点相同</p> <ol><li>找到对应的真实dom，称为el</li> <li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li> <li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li> <li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li> <li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li> <li>如果两者都有子节点，则执行updateChildren函数比较子节点</li></ol></li></ol> <p><code>updateChildren</code>执行过程</p> <ol><li>将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</li> <li>oldCh和vCh各有两个头尾的变量<code>StartIdx</code>和<code>EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx</code>&gt;<code>EndIdx</code>表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ol> <p>比较过程：</p> <ol><li>如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后</li> <li>如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</li> <li>如果四种匹配没有一对是成功的，那么遍历oldChild，S挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将S对应的节点插入到dom中对应的oldS位置，oldS和S指针向中间移动。</li></ol> <p>结束条件：</p> <ol><li>oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据index添加到dom中去</li> <li>S &gt; E表示vCh先遍历完，那么就在真实dom中将区间为[oldS, oldE]的多余节点删掉</li></ol> <h2 id="template编译render过程（ast）"><a href="#template编译render过程（ast）" class="header-anchor">#</a> template编译render过程（AST）</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
  <span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><p>相当于我们编写如下 render 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
     attrs<span class="token operator">:</span> <span class="token punctuation">{</span>
        id<span class="token operator">:</span> <span class="token string">'app'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="template的渲染过程"><a href="#template的渲染过程" class="header-anchor">#</a> template的渲染过程</h2> <h2 id="mixin"><a href="#mixin" class="header-anchor">#</a> mixin⭐️</h2> <h2 id="组件通信的方法"><a href="#组件通信的方法" class="header-anchor">#</a> 组件通信的方法</h2> <h3 id="单向数据流"><a href="#单向数据流" class="header-anchor">#</a> 单向数据流</h3> <p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致应用的数据流向难以理解。</p> <p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop</p> <p>单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。</p> <h3 id="props-emit"><a href="#props-emit" class="header-anchor">#</a> props/$emit</h3> <p>父子组件通信</p> <p>父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 <code>$emit</code>, A 组件中 <code>v-on</code> 的方式实现</p> <h3 id="如果在子组件中调用了父组件的props会怎么样？"><a href="#如果在子组件中调用了父组件的props会怎么样？" class="header-anchor">#</a> 如果在子组件中调用了父组件的props会怎么样？</h3> <h3 id="emit-on（eventbus）"><a href="#emit-on（eventbus）" class="header-anchor">#</a> $emit/$on（eventbus）</h3> <p>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Event<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Event<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span>事件名<span class="token punctuation">,</span>数据<span class="token punctuation">)</span><span class="token punctuation">;</span>
Event<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>事件名<span class="token punctuation">,</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>$on</code>，<code>$off</code> 和 <code>$once</code> 实例方法在 vue3 被移除</p> <p>官方推荐使用实现了事件触发接口的外部库来替换现有的 event hub，例如 <code>mitt</code> 或 <code>tiny-emitter</code></p> <h3 id="attrs-listeners"><a href="#attrs-listeners" class="header-anchor">#</a> $attrs/$listeners</h3> <p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法，<code>$attrs/$listeners</code></p> <ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 interitAttrs 选项一起使用。</li> <li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li></ul> <p>简单来说：<code>$attrs</code>与<code>$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</p> <h3 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> provide/inject</h3> <p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provide来提供变量，然后在子孙组件中通过inject来注入变量。</p> <p>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p> <p>provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。</p> <p>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父级组件提供 'foo'</span>
<span class="token keyword">var</span> Provider <span class="token operator">=</span> <span class="token punctuation">{</span>
  provide<span class="token operator">:</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token string">'bar'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 子组件注入 'foo'</span>
<span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>
  inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// =&gt; &quot;bar&quot;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p></div> <h3 id="parent-children-与-ref-refs"><a href="#parent-children-与-ref-refs" class="header-anchor">#</a> $parent / $children 与 ref / $refs</h3> <ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li> <li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// component-a 子组件</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      title<span class="token operator">:</span> <span class="token string">'Vue.js'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">sayHello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 父组件</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>component<span class="token operator">-</span>a ref<span class="token operator">=</span><span class="token string">&quot;comA&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">-</span>a<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">mounted</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> comA <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>comA<span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comA<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Vue.js</span>
      comA<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 弹窗</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>这两种方法的弊端是，无法在跨级或兄弟间通信。</p> <h3 id="父子组件通信"><a href="#父子组件通信" class="header-anchor">#</a> 父子组件通信</h3> <ul><li>父向子传递数据是通过 props，子向父是通过 events（$emit）；</li> <li>通过父链 / 子链也可以通信（$parent / $children）；</li> <li>ref 也可以访问组件实例；</li> <li>provide / inject API；</li> <li>$attrs/$listeners</li></ul> <h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="header-anchor">#</a> 兄弟组件通信</h3> <ul><li>EventBus；</li> <li>Vuex</li></ul> <h3 id="跨级组件通信"><a href="#跨级组件通信" class="header-anchor">#</a> 跨级组件通信</h3> <ul><li>EventBus；</li> <li>Vuex；</li> <li>provide / inject API、</li> <li>$attrs/$listeners</li></ul> <h3 id="vue组件通信不用父子间传值，不用vuex怎么实现"><a href="#vue组件通信不用父子间传值，不用vuex怎么实现" class="header-anchor">#</a> Vue组件通信不用父子间传值，不用Vuex怎么实现</h3> <h3 id="原生实现组件之间相互通信"><a href="#原生实现组件之间相互通信" class="header-anchor">#</a> 原生实现组件之间相互通信</h3> <h2 id="父组件调用子组件方法的方式有哪些"><a href="#父组件调用子组件方法的方式有哪些" class="header-anchor">#</a> 父组件调用子组件方法的方式有哪些⭐️</h2> <ul><li>在子组件上定义<code>ref=&quot;refName&quot;</code>，在父组件方法中使用<code>this.$refs.refName.method</code>去调用</li> <li><code>this.$children.event</code></li> <li><code>$emit/on</code>（逻辑在子组件）</li></ul> <h3 id="子组件调用父组件的方法的方式有哪些"><a href="#子组件调用父组件的方法的方式有哪些" class="header-anchor">#</a> 子组件调用父组件的方法的方式有哪些</h3> <ul><li>在子组件中通过<code>this.$parent.event</code>来调用父组件的方法</li> <li>在子组件里用<code>$emit</code>向父组件触发一个事件，父组件监听这个事件就行(逻辑在父组件)</li> <li>父组件把方法传入子组件中，在子组件里直接调用这个方法（直接v-bind，然后子组件记得在props声明父组件的函数）</li></ul> <h2 id="v-slot："><a href="#v-slot：" class="header-anchor">#</a> v-slot：</h2> <p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p> <p>注意 v-slot 只能添加在 <code>&lt;template&gt;</code> 上 (只有一种例外情况,自定义组件)</p> <h3 id="命名插槽"><a href="#命名插槽" class="header-anchor">#</a> 命名插槽</h3> <p><code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base-layout</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>header</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Here might be a page title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>A paragraph for the main content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>And another one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>footer</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Here's some contact info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>base-layout</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>没有名字的 <code>&lt;slot&gt;</code> 隐含有一个 &quot;default&quot; 名称</p> <h3 id="作用域插槽"><a href="#作用域插槽" class="header-anchor">#</a> 作用域插槽</h3> <p>所谓作用域插槽，就是让插槽的内容能够访问子组件中才有的数据。</p> <p>为了让 user 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>user<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ user.lastName }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">slotProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 插槽内容</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue常用指令"><a href="#vue常用指令" class="header-anchor">#</a> Vue常用指令</h2> <ul><li>v-model</li> <li>v-show</li> <li>v-html，解决双大括号语法无法渲染HTML标签</li> <li>v-for，列表渲染</li> <li>v-if，条件渲染</li> <li>v-bind，绑定属性</li> <li>v-on，绑定事件</li></ul> <h2 id="vue-自定义指令-directive"><a href="#vue-自定义指令-directive" class="header-anchor">#</a> Vue 自定义指令 directive⭐️</h2> <p>Vue 允许注册自定义指令，在某些情况下仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令</p> <p>简单示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 注册一个全局自定义指令 `v-focus`</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当被绑定的元素插入到 DOM 中时……</span>
  <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 聚焦元素</span>
    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p> <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li> <li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li> <li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。</li> <li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用。</li></ul> <h3 id="重点说一说-inserted-和-componentupdated-两个钩子函数的源码"><a href="#重点说一说-inserted-和-componentupdated-两个钩子函数的源码" class="header-anchor">#</a> 重点说一说 inserted 和 componentUpdated 两个钩子函数的源码</h3> <p><code>parseHTML(template, {})</code> -&gt; <code>addDirective()</code> -&gt; <code>genDirectives()</code> -&gt; <code>updateDirectives()</code> -&gt; <code>_update()</code></p> <p>在 <code>_update()</code> 中调用各种钩子函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_update</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 第一次实例化组件时，oldVnode是emptyNode</span>
  <span class="token keyword">const</span> isCreate <span class="token operator">=</span> oldVnode <span class="token operator">===</span> emptyNode
  <span class="token comment">// 销毁组件时，vnode是emptyNode</span>
  <span class="token keyword">const</span> isDestroy <span class="token operator">=</span> vnode <span class="token operator">===</span> emptyNode
  <span class="token comment">//normalizeDirectives函数是从组件的vm.$options.directives中获取指令的定义</span>
  <span class="token comment">// 获取旧节点上的所有自定义指令</span>
  <span class="token keyword">const</span> oldDirs <span class="token operator">=</span> <span class="token function">normalizeDirectives</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>directives<span class="token punctuation">,</span> oldVnode<span class="token punctuation">.</span>context<span class="token punctuation">)</span>
  <span class="token keyword">const</span> newDirs <span class="token operator">=</span> <span class="token function">normalizeDirectives</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>directives<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>context<span class="token punctuation">)</span>

  <span class="token keyword">const</span> dirsWithInsert <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> dirsWithPostpatch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token keyword">let</span> key<span class="token punctuation">,</span> oldDir<span class="token punctuation">,</span> dir
  <span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> newDirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//循环新vnode上绑定的指令</span>
    oldDir <span class="token operator">=</span> oldDirs<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    dir <span class="token operator">=</span> newDirs<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token comment">// 第一个参数是指令对象，第二个参数是钩子函数名称，第三个参数新节点，</span>
      <span class="token comment">// 第四个参数是旧节点，第五个参数是是否为注销组件，默认为undefined，只在组件注销时使用</span>
      <span class="token comment">// 在这个函数里，会根据我们传递的钩子函数名称，运行我们自定义组件时，所声明的钩子函数，</span>
      <span class="token comment">// new directive, bind   =&gt; 如果第一次绑定，则直接调用bind钩子函数</span>
      <span class="token function">callHook</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token string">'bind'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">.</span>def <span class="token operator">&amp;&amp;</span> dir<span class="token punctuation">.</span>def<span class="token punctuation">.</span>inserted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//若同时还添加了inserted钩子，则会先把它添加到dirsWithInsert数组中。</span>
        dirsWithInsert<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// existing directive, update   =&gt;  如果不是第一次绑定，则调用update钩子函数</span>
	  <span class="token comment">// 将旧值保存下来，供其他地方使用（仅在 update 和 componentUpdated 钩子中可用）</span>
      dir<span class="token punctuation">.</span>oldValue <span class="token operator">=</span> oldDir<span class="token punctuation">.</span>value
      dir<span class="token punctuation">.</span>oldArg <span class="token operator">=</span> oldDir<span class="token punctuation">.</span>arg
      <span class="token function">callHook</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> <span class="token string">'update'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">.</span>def <span class="token operator">&amp;&amp;</span> dir<span class="token punctuation">.</span>def<span class="token punctuation">.</span>componentUpdated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//若同时定义了componentUpdated钩子，则会先把它添加到dirsWithPostpatch数组中。</span>
        dirsWithPostpatch<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// mergeVNodeHook有三个参数，第一个参数是vnode节点，第二个参数是key值，第三个参数是回函数</span>
  <span class="token comment">// mergeVNodeHook会先用一个函数wrappedHook重新封装回调，在这个函数里运行回调函数</span>
  <span class="token comment">// 如果该节点没有这个key属性，会新增一个key属性，值为一个数组，数组中包含上面说的函数wrappedHook</span>
  <span class="token comment">// 如果该节点有这个key属性，会把函数wrappedHook追加到数组中</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>dirsWithInsert<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 封装回调函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">callInsert</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	  <span class="token comment">// 遍历所有指令的inserted钩子</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dirsWithInsert<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 对节点执行指令的inserted钩子函数</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>dirsWithInsert<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'inserted'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isCreate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//如果是vnode是第一次创建，</span>
      <span class="token comment">//则会把dirsWithInsert数组中的回调追加到vnode.data.hook.insert中执行</span>
      <span class="token function">mergeVNodeHook</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token string">'insert'</span><span class="token punctuation">,</span> callInsert<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
	  <span class="token comment">// 如果是更新组件，直接调用函数，遍历inserted钩子</span>
      <span class="token function">callInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果dirsWithPostpatch的长度不为0，也就是在组件更新的时候，且至少有一个指令中有componentUpdated钩子函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>dirsWithPostpatch<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 使用mergeVNodeHook绑定postpatch属性，等待后面子组建全部更新完成调用。</span>
    <span class="token function">mergeVNodeHook</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token string">'postpatch'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dirsWithPostpatch<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 对节点执行指令的componentUpdated钩子函数</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>dirsWithPostpatch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'componentUpdated'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果不是新建/初始化组件，也就是说是更新组件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isCreate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 遍历旧节点中的指令</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> oldDirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token comment">// 如果新节点中没有这个指令（旧节点中有，新节点没有）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newDirs<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// no longer present, unbind  </span>
        <span class="token comment">// 如果不是第一次创建，就调用旧vnode中新vnode不存在的指令的unbind钩子函数</span>
		<span class="token comment">// 从旧节点中解绑，isDestroy表示组件是不是注销了</span>
        <span class="token function">callHook</span><span class="token punctuation">(</span>oldDirs<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'unbind'</span><span class="token punctuation">,</span> oldVnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">,</span> isDestroy<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>callhook</code> 函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">callHook</span><span class="token punctuation">(</span><span class="token parameter">dir<span class="token punctuation">,</span> hook<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">,</span> isDestroy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> dir<span class="token punctuation">.</span>def <span class="token operator">&amp;&amp;</span> dir<span class="token punctuation">.</span>def<span class="token punctuation">[</span>hook<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">,</span> isDestroy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>context<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">directive </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dir<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hook<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> hook</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="指令钩子的参数"><a href="#指令钩子的参数" class="header-anchor">#</a> 指令钩子的参数</h3> <p>指令钩子函数会被传入以下参数：</p> <ul><li>el：指令所绑定的元素，可以用来直接操作 DOM。</li> <li>binding：一个对象，包含以下 property：
<ul><li>name：指令名，不包括 v- 前缀。</li> <li>value：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 2。</li> <li>oldValue：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li> <li>expression：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li> <li>arg：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li> <li>modifiers：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li> <li>vnode：Vue 编译生成的虚拟节点。</li> <li>oldVnode：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul> <h2 id="vue的过滤器、指令和组件的使用场景有什么差异？"><a href="#vue的过滤器、指令和组件的使用场景有什么差异？" class="header-anchor">#</a> Vue的过滤器、指令和组件的使用场景有什么差异？</h2> <ul><li><p>filter</p> <p>过滤器来处理通用文本格式。</p> <p>比如单位转换、数字打点、文本格式化、时间格式化之类的等</p></li></ul> <p>filter在Vue3被废弃，官方建议用计算属性或方法代替过滤器</p> <h2 id="vue跨页面通信"><a href="#vue跨页面通信" class="header-anchor">#</a> Vue跨页面通信</h2> <ul><li>localStorage</li> <li>webSocket</li> <li>vue-router，<code>this.$route.params</code></li></ul> <h2 id="一个页面跳转到另一个页面，数据怎么传递"><a href="#一个页面跳转到另一个页面，数据怎么传递" class="header-anchor">#</a> 一个页面跳转到另一个页面，数据怎么传递</h2> <h2 id="vue内置组件"><a href="#vue内置组件" class="header-anchor">#</a> Vue内置组件</h2> <ul><li><p>component</p> <p>渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 动态组件由 vm 实例的 `componentId` property 控制 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>componentId<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>$options.components.child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>transition</p> <p>为组件的载入和切换提供动画效果，具有非常强的可定制性</p> <p><code>&lt;transition&gt;</code> 元素作为单个元素/组件的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</p></li> <li><p>transition-group</p> <p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 tag attribute 配置哪个元素应该被渲染。</p> <p>注意，每个 <code>&lt;transition-group&gt;</code>的子节点必须有独立的 key，动画才能正常工作</p> <p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它会被应用一个移动中的 CSS 类 (通过 <code>name</code> attribute 或配置 <code>move-class</code> attribute 自动生成)。如果 CSS transform property 是“可过渡”property，当应用移动类时，将会使用 FLIP 技术使元素流畅地到达动画终点。</p></li> <li><p>keep-alive</p> <p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p> <p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p> <p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p></li> <li><p>slot</p> <p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。<code>&lt;slot&gt;</code> 元素自身将被替换。</p></li></ul> <h2 id="写一个通用组件需要考虑哪些问题"><a href="#写一个通用组件需要考虑哪些问题" class="header-anchor">#</a> 写一个通用组件需要考虑哪些问题</h2> <p>通用组件必须具备高内聚、低耦合的特性</p> <ul><li><p>和业务有关的数据不要在公共组件中获取和处理，数据尽量从父组件传入</p> <p>为了和业务与其他的组件解耦，子组件本身就不应该生成数据。即使生成了，也只能在组件内部运作，不能传递出去。</p> <p>父对子传参，就需要用到 props，但是通用组件的的应用场景比较复杂，对 props 传递的参数应该添加一些验证规则</p></li> <li><p>在父组件处理事件</p> <p>在通用组件中，通常会需要有各种事件，这些事件的处理方法应当尽量放到父组件中，在子组件中去触发父组件的函数去处理，通用组件一般只是作为一个事件的中转。</p></li> <li><p>公共组件中一般要留一个插槽slot</p> <p>一个公共组件，一般不能够完全适用于所有应用场景</p></li> <li><p>可定制性与可扩展性</p> <p>公共组件应该根据不同的使用场景增加可定制性和可扩展性
样式方面：我们可以做一些默认的样式选择，如果不满足使用场景，最好能够让用户可以选择自定义，比如按钮组件的背景色，字体大小，边框样式。
功能方面：我们可以给使用组件的开发者尽可能多的配置功能的选项，而且应该留一些入口，便于使用者根据场景二次开发</p></li></ul> <p><a href="pablohpsilva/vuejs-component-style-guide">Vue 组件编码规范</a></p> <h3 id="封装组件时如何判断一个组件要不要封装、封装的颗粒度"><a href="#封装组件时如何判断一个组件要不要封装、封装的颗粒度" class="header-anchor">#</a> 封装组件时如何判断一个组件要不要封装、封装的颗粒度</h3> <p>每一个 Vue 组件（等同于模块）首先必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。</p> <p>如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。</p> <h2 id="说说vue的scoped"><a href="#说说vue的scoped" class="header-anchor">#</a> 说说Vue的scoped</h2> <h2 id="动态组件"><a href="#动态组件" class="header-anchor">#</a> 动态组件</h2> <p>通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>currentTabComponent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在上述示例中，currentTabComponent 可以包括</p> <ul><li>已注册组件的名字，或</li> <li>一个组件的选项对象</li></ul> <h2 id="vue如何解决回流重绘的问题"><a href="#vue如何解决回流重绘的问题" class="header-anchor">#</a> Vue如何解决回流重绘的问题</h2> <h3 id="vue-lazyload-的原理，手写伪代码"><a href="#vue-lazyload-的原理，手写伪代码" class="header-anchor">#</a> Vue-lazyload 的原理，手写伪代码</h3> <p>interSectionObserver</p> <p><img src="/img/v2-111075a4bd7461037abd62798c1a9df7_1440w.jpg" alt=""></p> <h2 id="vue路由懒加载"><a href="#vue路由懒加载" class="header-anchor">#</a> Vue路由懒加载</h2> <p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p> <p>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* 组件定义对象 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>第二，在 Webpack 中，我们可以使用动态 import 语法来定义代码分块点 (split point)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./Foo.vue'</span><span class="token punctuation">)</span> <span class="token comment">// 返回 Promise</span>
</code></pre></div><p>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./Foo.vue'</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="父组件变化，怎么避免子组件不必要的更新"><a href="#父组件变化，怎么避免子组件不必要的更新" class="header-anchor">#</a> 父组件变化，怎么避免子组件不必要的更新</h2> <h2 id="vue整体初始化流程"><a href="#vue整体初始化流程" class="header-anchor">#</a> Vue整体初始化流程</h2> <ol><li><code>new Vue()</code></li> <li>init</li> <li>$mount</li> <li>compile</li> <li>render</li> <li>vnode</li> <li>patch</li> <li>DOM</li></ol> <p><img src="/img/new-vue.png" alt="流程"></p> <h2 id="vue-set-用法"><a href="#vue-set-用法" class="header-anchor">#</a> Vue $set 用法</h2> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span> target<span class="token punctuation">,</span> propertyName<span class="token operator">/</span>index<span class="token punctuation">,</span> value <span class="token punctuation">)</span>
</code></pre></div><ul><li><p>参数：</p> <ul><li>{Object | Array} target</li> <li>{string | number} propertyName/index</li> <li>{any} value</li></ul></li> <li><p>返回值：设置的值。</p></li></ul> <p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi')</p> <p>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p> <h2 id="vue-插件"><a href="#vue-插件" class="header-anchor">#</a> Vue 插件</h2> <p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制</p> <ul><li>添加全局方法或者 property。如：<code>vue-custom-element</code></li> <li>添加全局资源：指令/过滤器/过渡等。如 <code>vue-touch</code></li> <li>通过全局混入来添加一些组件选项。如 <code>vue-router</code></li> <li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li> <li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <code>vue-router</code></li></ul> <p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为<code>install</code> 方法。install 方法调用时，会将 Vue 作为参数传入。</p> <p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p> <p>通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue() 启动应用之前完成：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调用 `MyPlugin.install(Vue)`</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...组件选项</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p> <h3 id="vue-的插件怎么注册-插件接口该怎么设计"><a href="#vue-的插件怎么注册-插件接口该怎么设计" class="header-anchor">#</a> Vue 的插件怎么注册 插件接口该怎么设计</h3> <p>Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p> <div class="language-js extra-class"><pre class="language-js"><code>MyPlugin<span class="token punctuation">.</span><span class="token function-variable function">install</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Vue<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 添加全局方法或 property</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">myGlobalMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 逻辑...</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 2. 添加全局资源</span>
  Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">bind</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 逻辑...</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 3. 注入组件选项</span>
  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 逻辑...</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 4. 添加实例方法</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$myMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">methodOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 逻辑...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="缩写"><a href="#缩写" class="header-anchor">#</a> 缩写</h2> <ul><li><p>v-bind 缩写</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 完整语法 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 缩写 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:[key]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>v-on 缩写</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 完整语法 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 缩写 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@[event]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>v-slot缩写</p> <p>即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code></p> <p>和其它指令一样，该缩写只在其有参数的时候才可用</p></li></ul> <h2 id="如果页面上有很多个-checkbox-怎么尽可能少的向后台传输数据"><a href="#如果页面上有很多个-checkbox-怎么尽可能少的向后台传输数据" class="header-anchor">#</a> 如果页面上有很多个 checkbox 怎么尽可能少的向后台传输数据</h2> <h2 id="vue不可以写jsx吗"><a href="#vue不可以写jsx吗" class="header-anchor">#</a> Vue不可以写jsx吗</h2> <p>可以</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> AnchoredHeading <span class="token keyword">from</span> <span class="token string">'./AnchoredHeading.vue'</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'#demo'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>AnchoredHeading level<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Hello<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span> world<span class="token operator">!</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>AnchoredHeading<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>生成对应模板</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>anchored-heading</span> <span class="token attr-name">:level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>Hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> world!
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>anchored-heading</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>而用render函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">createElement</span><span class="token punctuation">(</span>
  <span class="token string">'anchored-heading'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
      level<span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token string">' world!'</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre></div><h3 id="含-jsx-文件如何最终编译成浏览器可以识别的-js-文件，通过什么工具来完成这个工作的？"><a href="#含-jsx-文件如何最终编译成浏览器可以识别的-js-文件，通过什么工具来完成这个工作的？" class="header-anchor">#</a> 含 JSX 文件如何最终编译成浏览器可以识别的 JS 文件，通过什么工具来完成这个工作的？</h3> <p>Babel</p> <h2 id="高阶vue函数用过哪些"><a href="#高阶vue函数用过哪些" class="header-anchor">#</a> 高阶Vue函数用过哪些</h2> <h2 id="vue模板解析的过程"><a href="#vue模板解析的过程" class="header-anchor">#</a> Vue模板解析的过程</h2> <h2 id="vue-cli做过哪些配置"><a href="#vue-cli做过哪些配置" class="header-anchor">#</a> Vue-cli做过哪些配置</h2> <h2 id="反向代理"><a href="#反向代理" class="header-anchor">#</a> 反向代理</h2> <h2 id="vue数组用下标更改元素会更新视图吗？那用什么方法可以更新？"><a href="#vue数组用下标更改元素会更新视图吗？那用什么方法可以更新？" class="header-anchor">#</a> Vue数组用下标更改元素会更新视图吗？那用什么方法可以更新？</h2> <h2 id="权限控制的路由是怎么配置的？"><a href="#权限控制的路由是怎么配置的？" class="header-anchor">#</a> 权限控制的路由是怎么配置的？⭐️</h2> <h3 id="用户权限控制，用到动态路由加载以及如何改进"><a href="#用户权限控制，用到动态路由加载以及如何改进" class="header-anchor">#</a> 用户权限控制，用到动态路由加载以及如何改进</h3> <p>可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到动态路由的效果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token string">'&lt;div&gt;User&lt;/div&gt;'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 动态路径参数 以冒号开头</span>
    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> User <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="vue-loader的工作原理"><a href="#vue-loader的工作原理" class="header-anchor">#</a> Vue loader的工作原理</h2> <h3 id="vue文件如何识别html，js，style的"><a href="#vue文件如何识别html，js，style的" class="header-anchor">#</a> Vue文件如何识别html，js，style的</h3> <ul><li>vue-loader：HTML 模版 template，再分别把它们交给对应的 Loader 去处理。</li> <li>css-loader：加载由 vue-loader 提取出的 CSS 代码。</li> <li>vue-template-compiler：把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JavaScript 代码，这和 React 中的 JSX 语法被编译成 JavaScript 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。</li></ul> <h3 id="vue的style中的scoped"><a href="#vue的style中的scoped" class="header-anchor">#</a> Vue的Style中的Scoped</h3> <h2 id="如何手动搭建一个vue项目（不使用脚手架）"><a href="#如何手动搭建一个vue项目（不使用脚手架）" class="header-anchor">#</a> 如何手动搭建一个Vue项目（不使用脚手架）</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/vue/vdom.html" class="prev">
        虚拟 DOM
      </a></span> <span class="next"><a href="/frontend/vue/vue-cli.html">
        Vue-cli
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.484f4375.js" defer></script><script src="/assets/js/2.ebbe98b4.js" defer></script><script src="/assets/js/115.adf2d1b9.js" defer></script>
  </body>
</html>
