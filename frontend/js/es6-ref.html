<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6 文档 | ゼロツー</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="zerotwo">
    <link rel="preload" href="/assets/css/0.styles.f0b7ee7d.css" as="style"><link rel="preload" href="/assets/js/app.484f4375.js" as="script"><link rel="preload" href="/assets/js/2.ebbe98b4.js" as="script"><link rel="preload" href="/assets/js/61.bad1d82a.js" as="script"><link rel="prefetch" href="/assets/js/10.91de1805.js"><link rel="prefetch" href="/assets/js/100.1772503e.js"><link rel="prefetch" href="/assets/js/101.b569a1af.js"><link rel="prefetch" href="/assets/js/102.65dffa11.js"><link rel="prefetch" href="/assets/js/103.d7a8cd9e.js"><link rel="prefetch" href="/assets/js/104.0a0e3708.js"><link rel="prefetch" href="/assets/js/105.15bc167a.js"><link rel="prefetch" href="/assets/js/106.8487cf9a.js"><link rel="prefetch" href="/assets/js/107.2310b94b.js"><link rel="prefetch" href="/assets/js/108.781b7ebe.js"><link rel="prefetch" href="/assets/js/109.6225704a.js"><link rel="prefetch" href="/assets/js/11.9c44c6b2.js"><link rel="prefetch" href="/assets/js/110.3c39cb3c.js"><link rel="prefetch" href="/assets/js/111.22bede53.js"><link rel="prefetch" href="/assets/js/112.acb6b722.js"><link rel="prefetch" href="/assets/js/113.c2b6115e.js"><link rel="prefetch" href="/assets/js/114.cbeddf77.js"><link rel="prefetch" href="/assets/js/115.adf2d1b9.js"><link rel="prefetch" href="/assets/js/116.3f23eb5b.js"><link rel="prefetch" href="/assets/js/117.00cb8ac3.js"><link rel="prefetch" href="/assets/js/118.e88e1cfb.js"><link rel="prefetch" href="/assets/js/119.213aaa9b.js"><link rel="prefetch" href="/assets/js/12.878aa51b.js"><link rel="prefetch" href="/assets/js/120.fc12eb0e.js"><link rel="prefetch" href="/assets/js/121.67bafb52.js"><link rel="prefetch" href="/assets/js/122.cca49856.js"><link rel="prefetch" href="/assets/js/123.0e27eb9e.js"><link rel="prefetch" href="/assets/js/124.53383547.js"><link rel="prefetch" href="/assets/js/125.e103d7f1.js"><link rel="prefetch" href="/assets/js/126.adb34a41.js"><link rel="prefetch" href="/assets/js/127.f352dcec.js"><link rel="prefetch" href="/assets/js/128.9aa22460.js"><link rel="prefetch" href="/assets/js/129.02dabe8a.js"><link rel="prefetch" href="/assets/js/13.b4c5b1dd.js"><link rel="prefetch" href="/assets/js/130.7d88cb43.js"><link rel="prefetch" href="/assets/js/14.dce5d003.js"><link rel="prefetch" href="/assets/js/15.ec0f3b1f.js"><link rel="prefetch" href="/assets/js/16.a9597b38.js"><link rel="prefetch" href="/assets/js/17.c8f44f51.js"><link rel="prefetch" href="/assets/js/18.67e67934.js"><link rel="prefetch" href="/assets/js/19.2b8ea36f.js"><link rel="prefetch" href="/assets/js/20.ee5ab76e.js"><link rel="prefetch" href="/assets/js/21.1582f8ed.js"><link rel="prefetch" href="/assets/js/22.130fb5fa.js"><link rel="prefetch" href="/assets/js/23.ecbb4b5d.js"><link rel="prefetch" href="/assets/js/24.0c8b3ecd.js"><link rel="prefetch" href="/assets/js/25.4aae22ea.js"><link rel="prefetch" href="/assets/js/26.4816aa3d.js"><link rel="prefetch" href="/assets/js/27.2e6f0659.js"><link rel="prefetch" href="/assets/js/28.7e0fef24.js"><link rel="prefetch" href="/assets/js/29.dad88d85.js"><link rel="prefetch" href="/assets/js/3.5e8d6a69.js"><link rel="prefetch" href="/assets/js/30.1ecf79ca.js"><link rel="prefetch" href="/assets/js/31.0a97fafc.js"><link rel="prefetch" href="/assets/js/32.8e6151d1.js"><link rel="prefetch" href="/assets/js/33.b5ff95d1.js"><link rel="prefetch" href="/assets/js/34.0d03faf5.js"><link rel="prefetch" href="/assets/js/35.6d4b4665.js"><link rel="prefetch" href="/assets/js/36.b42cbedf.js"><link rel="prefetch" href="/assets/js/37.4de10dce.js"><link rel="prefetch" href="/assets/js/38.9031eb30.js"><link rel="prefetch" href="/assets/js/39.daee868f.js"><link rel="prefetch" href="/assets/js/4.ceb8a314.js"><link rel="prefetch" href="/assets/js/40.df374a26.js"><link rel="prefetch" href="/assets/js/41.563436c6.js"><link rel="prefetch" href="/assets/js/42.b9200ca4.js"><link rel="prefetch" href="/assets/js/43.40ae12a3.js"><link rel="prefetch" href="/assets/js/44.4a0dd48e.js"><link rel="prefetch" href="/assets/js/45.20d657cc.js"><link rel="prefetch" href="/assets/js/46.2d34fe10.js"><link rel="prefetch" href="/assets/js/47.3dcb2d38.js"><link rel="prefetch" href="/assets/js/48.1b0959df.js"><link rel="prefetch" href="/assets/js/49.6652f2b2.js"><link rel="prefetch" href="/assets/js/5.b28c76e0.js"><link rel="prefetch" href="/assets/js/50.30bdc802.js"><link rel="prefetch" href="/assets/js/51.ebe5930a.js"><link rel="prefetch" href="/assets/js/52.02f2caf4.js"><link rel="prefetch" href="/assets/js/53.55df3fc5.js"><link rel="prefetch" href="/assets/js/54.e2bff3b5.js"><link rel="prefetch" href="/assets/js/55.c859c458.js"><link rel="prefetch" href="/assets/js/56.d493a61b.js"><link rel="prefetch" href="/assets/js/57.9af46dbf.js"><link rel="prefetch" href="/assets/js/58.46d4e8aa.js"><link rel="prefetch" href="/assets/js/59.82e453fe.js"><link rel="prefetch" href="/assets/js/6.b43fc5c2.js"><link rel="prefetch" href="/assets/js/60.d9652552.js"><link rel="prefetch" href="/assets/js/62.8c307334.js"><link rel="prefetch" href="/assets/js/63.7ebafb7e.js"><link rel="prefetch" href="/assets/js/64.bc588101.js"><link rel="prefetch" href="/assets/js/65.6f66d6a2.js"><link rel="prefetch" href="/assets/js/66.ee6f0d41.js"><link rel="prefetch" href="/assets/js/67.0002a9a5.js"><link rel="prefetch" href="/assets/js/68.4a86ea26.js"><link rel="prefetch" href="/assets/js/69.c9e36070.js"><link rel="prefetch" href="/assets/js/7.87b3f924.js"><link rel="prefetch" href="/assets/js/70.40af8c94.js"><link rel="prefetch" href="/assets/js/71.ee207bd6.js"><link rel="prefetch" href="/assets/js/72.c389068e.js"><link rel="prefetch" href="/assets/js/73.c1526d9c.js"><link rel="prefetch" href="/assets/js/74.cd1c9d32.js"><link rel="prefetch" href="/assets/js/75.144c1f5b.js"><link rel="prefetch" href="/assets/js/76.4c36bfbf.js"><link rel="prefetch" href="/assets/js/77.7db5b3f1.js"><link rel="prefetch" href="/assets/js/78.de99e748.js"><link rel="prefetch" href="/assets/js/79.1febcdca.js"><link rel="prefetch" href="/assets/js/8.ab13bda4.js"><link rel="prefetch" href="/assets/js/80.e802c8bb.js"><link rel="prefetch" href="/assets/js/81.960e4a52.js"><link rel="prefetch" href="/assets/js/82.9a35963d.js"><link rel="prefetch" href="/assets/js/83.005e1aad.js"><link rel="prefetch" href="/assets/js/84.d61f7f01.js"><link rel="prefetch" href="/assets/js/85.0906b75c.js"><link rel="prefetch" href="/assets/js/86.dff86ecd.js"><link rel="prefetch" href="/assets/js/87.00755e79.js"><link rel="prefetch" href="/assets/js/88.00604a67.js"><link rel="prefetch" href="/assets/js/89.376832c9.js"><link rel="prefetch" href="/assets/js/9.b83e9e02.js"><link rel="prefetch" href="/assets/js/90.9be39541.js"><link rel="prefetch" href="/assets/js/91.d5eb29c9.js"><link rel="prefetch" href="/assets/js/92.9f5fba68.js"><link rel="prefetch" href="/assets/js/93.670dcf5c.js"><link rel="prefetch" href="/assets/js/94.9d783387.js"><link rel="prefetch" href="/assets/js/95.0fd08cc1.js"><link rel="prefetch" href="/assets/js/96.ae0eb4f1.js"><link rel="prefetch" href="/assets/js/97.1d15ea38.js"><link rel="prefetch" href="/assets/js/98.1bc97ef6.js"><link rel="prefetch" href="/assets/js/99.d91a7a9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f0b7ee7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./favicon.jpg" alt="ゼロツー" class="logo"> <span class="site-name can-hide">ゼロツー</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link router-link-active">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link router-link-active">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/js/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/frontend/js/array.html" class="sidebar-link">数组</a></li><li><a href="/frontend/js/async.html" class="sidebar-link">异步</a></li><li><a href="/frontend/js/copy.html" class="sidebar-link">拷贝</a></li><li><a href="/frontend/js/crossOrigin.html" class="sidebar-link">跨域</a></li><li><a href="/frontend/js/data.html" class="sidebar-link">数据类型</a></li><li><a href="/frontend/js/documentNodeRef.html" class="sidebar-link">Document 和 Element 文档</a></li><li><a href="/frontend/js/dom.html" class="sidebar-link">DOM</a></li><li><a href="/frontend/js/domRef.html" class="sidebar-link">DOM接口文档</a></li><li><a href="/frontend/js/es6.html" class="sidebar-link">ES6</a></li><li><a href="/frontend/js/es6-data.html" class="sidebar-link">ES6 数据类型扩展</a></li><li><a href="/frontend/js/es6-object.html" class="sidebar-link">ES6对象扩展</a></li><li><a href="/frontend/js/es6-ref.html" aria-current="page" class="active sidebar-link">ES6 文档</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#promise" class="sidebar-link">promise</a></li><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#generator" class="sidebar-link">Generator</a></li><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#async" class="sidebar-link">async</a></li><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#iterator" class="sidebar-link">Iterator</a></li><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#symbol" class="sidebar-link">symbol</a></li><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#proxy" class="sidebar-link">proxy</a></li><li class="sidebar-sub-header"><a href="/frontend/js/es6-ref.html#reflect" class="sidebar-link">Reflect</a></li></ul></li><li><a href="/frontend/js/es6-setAndMapRef.html" class="sidebar-link">ES6 Set and Map</a></li><li><a href="/frontend/js/event.html" class="sidebar-link">DOM事件</a></li><li><a href="/frontend/js/extension.html" class="sidebar-link">继承</a></li><li><a href="/frontend/js/function.html" class="sidebar-link">函数</a></li><li><a href="/frontend/js/js.html" class="sidebar-link">基础</a></li><li><a href="/frontend/js/module.html" class="sidebar-link">模块化</a></li><li><a href="/frontend/js/object.html" class="sidebar-link">对象</a></li><li><a href="/frontend/js/prototype.html" class="sidebar-link">原型</a></li><li><a href="/frontend/js/q.html" class="sidebar-link">一些输出问题</a></li><li><a href="/frontend/js/regexp.html" class="sidebar-link">正则表达式</a></li><li><a href="/frontend/js/thread.html" class="sidebar-link">多线程</a></li><li><a href="/frontend/js/window.html" class="sidebar-link">浏览器对象</a></li><li><a href="/frontend/js/xhr.html" class="sidebar-link">网络请求</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h2> <p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p> <p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p> <p>Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <p>Promise对象有以下两个特点。</p> <ul><li><p>对象的状态不受外界影响。</p> <p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p> <p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p></li> <li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p> <p>Promise对象的状态改变，只有两种可能：从pending变为fulfilled 和从pending变为rejected。</p> <p>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。</p> <p>如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p> <p>这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul> <p>Promise缺点。</p> <ul><li><p>无法取消Promise，<strong>一旦新建它就会立即执行，无法中途取消。</strong></p></li> <li><p>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p></li> <li><p>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li></ul> <h3 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h3> <p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p> <p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p> <p>resolve函数的作用是，将Promise对象的状态从 pending 变为 resolved，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p> <p>reject函数的作用是，将Promise对象的状态从 pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> <p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p> <p>then方法可以接受两个回调函数作为参数。</p> <p>第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。</p> <p>这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数。</p> <p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。</p> <p>reject函数的参数通常是Error对象的实例，表示抛出的错误；</p> <p>resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例</p> <p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p> <p>立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2</span>
<span class="token comment">// 1</span>
</code></pre></div><p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。</p> <p>所以，最好在它们前面加上return语句，这样就不会有意外。</p> <h3 id="promise-prototype-then"><a href="#promise-prototype-then" class="header-anchor">#</a> Promise.prototype.then()</h3> <p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。</p> <p>它的作用是为 Promise 实例添加状态改变时的回调函数。</p> <p>then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。</p> <p>then方法返回的是一个全新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p> <p>采用链式的then，可以指定一组按照次序调用的回调函数。</p> <p>这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p> <h3 id="promise-prototype-catch"><a href="#promise-prototype-catch" class="header-anchor">#</a> Promise.prototype.catch()</h3> <p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <p>then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。</p> <p>reject()方法的作用，等同于抛出错误。</p> <p>如果 Promise 状态已经变成resolved，再抛出错误是无效的</p> <p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p> <p>一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p> <p><strong>如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</strong></p> <p>catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。</p> <p>catch()方法之中，还能再抛出错误。</p> <h3 id="promise-resolve"><a href="#promise-resolve" class="header-anchor">#</a> Promise.resolve()</h3> <p>有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。</p> <p>Promise.resolve()等价于下面的写法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token comment">// 等价于</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h4> <p>Promise.resolve()方法的参数分成四种情况。</p> <ul><li><p>参数是一个 Promise 实例</p> <p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p></li> <li><p>参数是一个thenable对象</p> <p>thenable对象指的是具有then方法的对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。</span>
<span class="token keyword">let</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 42</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。</p></li> <li><p>参数不是具有then()方法的对象，或根本就不是对象</p> <p>如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法）</span>
<span class="token comment">//返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Hello</span>
</code></pre></div></li> <li><p>不带有任何参数</p> <p>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p> <p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p></li></ul> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p><strong>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>即使是一个已经变成 resolve 状态的 Promise，传递给 <span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 的函数也总是会被异步调用：

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2</span>
</code></pre></div></div> <h3 id="promise-reject"><a href="#promise-reject" class="header-anchor">#</a> Promise.reject()</h3> <p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p> <p>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p> <h3 id="promise-try"><a href="#promise-try" class="header-anchor">#</a> Promise.try()</h3> <p>用 Promise 来处理函数。可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
</code></pre></div><p>上面的写法有一个缺点，就是如果f是同步函数，那么它会变成在本轮事件循环的末尾执行。</p> <p>Promise.try()会让同步函数同步执行，异步函数异步执行</p> <p>Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p> <h3 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> Promise.all()⭐️</h3> <p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例.</p> <p>如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p> <p><strong>Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</strong></p> <p>p的状态由p1、p2、p3决定，分成两种情况。</p> <ul><li><p><strong>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</strong></p></li> <li><p><strong>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</strong></p></li></ul> <p><strong>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</strong></p> <p>如果没有自己的catch方法，就会调用Promise.all()的catch方法。</p> <h3 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> Promise.race()⭐️</h3> <p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</strong></p> <p>Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。</p> <h3 id="promise-any"><a href="#promise-any" class="header-anchor">#</a> Promise.any()⭐️</h3> <p>ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p> <p><strong>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；</strong></p> <p><strong>如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</strong></p> <p>Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。</p> <p>Promise.any()抛出的错误，相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。</p> <blockquote><p>抛出的错误是一个 AggregateError 实例</p></blockquote> <h3 id="promise-allsettled"><a href="#promise-allsettled" class="header-anchor">#</a> Promise.allSettled()⭐️</h3> <p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。</p> <p>**只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。**该方法由 ES2020 引入。</p> <p><strong>该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。</strong></p> <p>状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。</p> <blockquote><p>每个对象都有status属性，该属性的值只能是'fulfilled'或'rejected'。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。</p></blockquote> <p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用</p> <p>Promise.all()方法无法确保所有异步操作结束</p> <h3 id="promise-prototype-finally"><a href="#promise-prototype-finally" class="header-anchor">#</a> Promise.prototype.finally()</h3> <p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p> <blockquote><p>在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p></blockquote> <p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p> <p>finally本质上是then方法的特例。</p> <p><strong>finally方法总是会返回原来的值</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// resolve 的值是 undefined</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// resolve 的值是 2</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// reject 的值是 undefined</span>
Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// reject 的值是 3</span>
Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="generator"><a href="#generator" class="header-anchor">#</a> Generator</h2> <p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p> <p>Generator 函数有多种理解角度。</p> <ul><li><p>语法上</p> <p>首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p> <p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。</p> <p>返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p></li> <li><p>形式上</p> <p>Generator 函数是一个普通函数，但是有两个特征。</p> <p>一是，function关键字与函数名之间有一个星号；</p> <blockquote><p>一般将星号写在紧跟function关键字后面</p></blockquote> <p>二是，函数体内部使用yield表达式，定义不同的内部状态</p></li></ul> <p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。</p> <p>不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象</p> <p>每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</p> <blockquote><p>返回一个有着value和done两个属性的对象。value表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是布尔值，表示是否遍历结束。</p></blockquote> <p>换言之，<strong>Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</strong></p> <blockquote><p>遍历结束调用next方法返回的都是value为undefined，done为true的对象</p></blockquote> <h3 id="yield"><a href="#yield" class="header-anchor">#</a> yield⭐️</h3> <p>yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p> <p>yield表达式与return语句既有相似之处，也有区别。</p> <p>相似之处在于，都能返回紧跟在语句后面的那个表达式的值。</p> <p>区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。</p> <p>一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。</p> <p>正常函数只能返回一个值，因为只能执行一次return；</p> <p>Generator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，</p> <p>Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。</p> <p>另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p> <p><strong>yield表达式如果用在另一个表达式之中，必须放在圆括号里面。</strong></p> <h3 id="next"><a href="#next" class="header-anchor">#</a> next⭐️</h3> <p>遍历器对象的next方法的运行逻辑如下。</p> <ol><li><p>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p></li> <li><p>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p></li> <li><p>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p></li> <li><p>如果该函数没有return语句，则返回的对象的value属性值为undefined。</p></li></ol> <p>yield表达式本身没有返回值，或者说总是<strong>返回undefined</strong>。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token punctuation">(</span>y <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Object{value:6, done:false}</span>
<span class="token comment">//第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Object{value:NaN, done:false}</span>
<span class="token comment">//第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Object{value:NaN, done:true}</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// { value:6, done:false }</span>
<span class="token comment">//第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">// { value:8, done:false }</span>
<span class="token comment">//第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span> <span class="token comment">// { value:42, done:true }</span>
</code></pre></div><p>可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p> <p>由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，</p> <blockquote><p>从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</p></blockquote> <p>只有从第二次使用next方法开始，参数才是有效的。</p> <p>如果想要第一次调用next方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p> <blockquote><p>其实也就是在包装函数内先执行依次next方法</p></blockquote> <h3 id="for-of-循环"><a href="#for-of-循环" class="header-anchor">#</a> for...of 循环⭐️</h3> <p>for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p> <p>这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象</p> <p>使用for...of语句时不需要使用next方法</p> <p>通过 Generator 函数为任意对象加上遍历接口，就可以用for of 循环。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> jane <span class="token operator">=</span> <span class="token punctuation">{</span> first<span class="token operator">:</span> <span class="token string">'Jane'</span><span class="token punctuation">,</span> last<span class="token operator">:</span> <span class="token string">'Doe'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span>jane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也可以将 Generator 函数加到对象的Symbol.iterator属性上面。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> jane <span class="token operator">=</span> <span class="token punctuation">{</span> first<span class="token operator">:</span> <span class="token string">'Jane'</span><span class="token punctuation">,</span> last<span class="token operator">:</span> <span class="token string">'Doe'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

jane<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> objectEntries<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> jane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。</p> <p>这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p> <h3 id="generator-prototype-return"><a href="#generator-prototype-return" class="header-anchor">#</a> Generator.prototype.return()</h3> <p>Generator 函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历 Generator 函数。</p> <p>如果return()方法调用时，不提供参数，则返回值的value属性为undefined。</p> <p>如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return()方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束</p> <p>调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。</p> <p>而return方法返回的值是finally代码块里的值</p> <h3 id="generator-prototype-throw"><a href="#generator-prototype-throw" class="header-anchor">#</a> Generator.prototype.throw()</h3> <p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p> <p>如果 Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。</p> <p>如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。</p> <p>throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法</p> <p>throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法</p> <p>只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p> <p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。</p> <p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p> <h3 id="yield-表达式"><a href="#yield-表达式" class="header-anchor">#</a> yield* 表达式</h3> <p>ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p> <p>如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象</p> <blockquote><p>有递归的意味</p></blockquote> <p>yield*后面的 Generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。</p> <p>反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。</p> <p>任何数据结构只要有 Iterator 接口，就可以被yield*遍历。</p> <h3 id="作为对象属性的-generator-函数"><a href="#作为对象属性的-generator-函数" class="header-anchor">#</a> 作为对象属性的 Generator 函数</h3> <p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">*</span> <span class="token function">myGeneratorMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ···
  <span class="token punctuation">}</span>

<span class="token comment">//等同于</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">myGeneratorMethod</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ···</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="generator-函数的this"><a href="#generator-函数的this" class="header-anchor">#</a> Generator 函数的this</h3> <p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。</p> <p>返回的总是遍历器对象，而不是this对象。</p> <p><strong>Generator 函数也不能跟new命令一起用</strong></p> <p>让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？</p> <p>首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

f<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Object {value: 2, done: false}</span>
f<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Object {value: 3, done: false}</span>
f<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Object {value: undefined, done: true}</span>

obj<span class="token punctuation">.</span>a <span class="token comment">// 1</span>
obj<span class="token punctuation">.</span>b <span class="token comment">// 2</span>
obj<span class="token punctuation">.</span>c <span class="token comment">// 3</span>

<span class="token comment">//将遍历器对象f，生成的对象实例obj，这两个对象统一</span>
<span class="token comment">//将obj换成F.prototype。</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//再将F改成构造函数，就可以对它执行new命令了。</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">gen</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

f<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Object {value: 2, done: false}</span>
f<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Object {value: 3, done: false}</span>
f<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Object {value: undefined, done: true}</span>

f<span class="token punctuation">.</span>a <span class="token comment">// 1</span>
f<span class="token punctuation">.</span>b <span class="token comment">// 2</span>
f<span class="token punctuation">.</span>c <span class="token comment">// 3</span>

<span class="token comment">//有点难理解</span>
</code></pre></div><h3 id="generator-与上下文"><a href="#generator-与上下文" class="header-anchor">#</a> Generator 与上下文</h3> <p>Generator 函数执行产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行next命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p> <h3 id="应用"><a href="#应用" class="header-anchor">#</a> 应用</h3> <ul><li><p>部署 Iterator 接口</p></li> <li><p>异步操作的同步化表达</p> <p>也可以使用promise表达</p></li> <li><p>控制流管理</p> <p>使用for of + 数组</p></li></ul> <h3 id="与-iterator-接口的关系"><a href="#与-iterator-接口的关系" class="header-anchor">#</a> 与 Iterator 接口的关系</h3> <p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口</p> <h2 id="async"><a href="#async" class="header-anchor">#</a> async</h2> <p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p> <p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p> <p><strong>async 函数可以保留运行堆栈</strong></p> <h3 id="对-generator-函数的改进"><a href="#对-generator-函数的改进" class="header-anchor">#</a> 对 Generator 函数的改进</h3> <p>async函数对 Generator 函数的改进，体现在以下四点。</p> <ul><li><p>内置执行器。</p> <p>Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p></li> <li><p>更好的语义。</p> <p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p></li> <li><p>更广的适用性。</p> <p>async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></li> <li><p>返回值是 Promise。</p> <p>async函数的返回值是 Promise 对象，可以用then方法指定下一步的操作。</p> <p>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p></li></ul> <h3 id="基本用法-2"><a href="#基本用法-2" class="header-anchor">#</a> 基本用法</h3> <p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。</p> <p>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p> <p>由于async函数返回的是 Promise 对象，可以作为await命令的参数</p> <h3 id="使用形式"><a href="#使用形式" class="header-anchor">#</a> 使用形式</h3> <ul><li>函数声明</li> <li>函数表达式</li> <li>对象的方法</li> <li>Class 的方法</li> <li>箭头函数</li></ul> <h3 id="await-命令"><a href="#await-命令" class="header-anchor">#</a> await 命令</h3> <p>正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 等同于</span>
  <span class="token comment">// return 123;</span>
  <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 123</span>
</code></pre></div><p>另一种情况是，await命令后面是一个thenable对象（即定义了then方法的对象），那么await会将其等同于 Promise 对象。</p> <p>任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。</p> <p><strong>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</strong></p> <p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dbFuc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//这里不需要 async</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// 这时三个db.post()操作将是并发执行，也就是同时执行，而不是继发执行。</span>
  <span class="token comment">//map方法也是同样</span>
  docs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//正确写法一</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFuc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">await</span> docs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">_<span class="token punctuation">,</span> doc</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> _<span class="token punctuation">;</span>
    <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//正确写法二</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFuc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> doc <span class="token keyword">of</span> docs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>有一个语法提案，允许在模块的顶层独立使用await命令，借用await解决模块异步加载的问题。</p></blockquote> <p>如果确实希望多个请求并发执行，可以使用Promise.all方法。当三个请求都会resolved时，下面两种写法效果相同。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFuc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 或者使用下面的写法</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFuc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> promise <span class="token keyword">of</span> promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">await</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="header-anchor">#</a> async 函数的实现原理⭐️</h3> <p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 等同于</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//自动执行器spwan</span>
<span class="token keyword">function</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token parameter">genF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">genF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">nextF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> next<span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        next <span class="token operator">=</span> <span class="token function">nextF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="返回promise对象"><a href="#返回promise对象" class="header-anchor">#</a> 返回promise对象</h3> <p>async函数返回一个 Promise 对象。</p> <p><strong>async函数内部return语句返回的值，会成为then方法回调函数的参数</strong></p> <p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p> <h3 id="错误处理"><a href="#错误处理" class="header-anchor">#</a> 错误处理</h3> <p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p> <p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。</p> <h3 id="promise-对象的状态变化"><a href="#promise-对象的状态变化" class="header-anchor">#</a> Promise 对象的状态变化</h3> <p><strong>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。</strong></p> <p>也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p> <h2 id="iterator"><a href="#iterator" class="header-anchor">#</a> Iterator</h2> <p>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p> <p>Iterator 的作用有三个：</p> <ul><li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li> <li>二是使得数据结构的成员能够按某种次序排列；</li> <li>三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of使用。</li></ul> <p>遍历器对象本质上，是一个指针对象，通过调用next方法，返回数据结构的当前成员的信息。</p> <p>具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p> <p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的</p> <h3 id="iterator-接口"><a href="#iterator-接口" class="header-anchor">#</a> Iterator 接口</h3> <p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性</p> <p>一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”</p> <p>Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p> <blockquote><p>该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。</p></blockquote> <p>至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内</p> <p>一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p> <blockquote><p>也可以使用while循环遍历。</p></blockquote> <p>对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">NodeList</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 或者</span>
<span class="token class-name">NodeList</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>普通对象部署数组的Symbol.iterator方法，并无效果。</p></blockquote> <p>如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p> <h3 id="原生具备-iterator-接口的数据结构"><a href="#原生具备-iterator-接口的数据结构" class="header-anchor">#</a> 原生具备 Iterator 接口的数据结构</h3> <ul><li>Array</li> <li>Map</li> <li>Set</li> <li>String</li> <li>函数的 arguments 对象</li> <li>NodeList 对象</li></ul> <p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定</p> <h3 id="调用-iterator-接口的场合"><a href="#调用-iterator-接口的场合" class="header-anchor">#</a> 调用 Iterator 接口的场合</h3> <ul><li><p>解构赋值</p> <p>对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。</p></li> <li><p>扩展运算符</p> <p>扩展运算符（...）也会调用默认的 Iterator 接口。</p> <p><strong>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</strong>⭐️</p></li> <li><p>yield*</p> <p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p></li> <li><p>其他场合</p> <p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口</p></li></ul> <h3 id="iterator-接口与-generator-函数"><a href="#iterator-接口与-generator-函数" class="header-anchor">#</a> Iterator 接口与 Generator 函数</h3> <p>Symbol.iterator()方法的最简单实现，是使用Generator 函数</p> <h3 id="遍历器对象的-return"><a href="#遍历器对象的-return" class="header-anchor">#</a> 遍历器对象的 return()</h3> <p>遍历器对象除了具有next()方法，还可以具有return()方法和throw()方法。</p> <p>自定义遍历器对象生成函数，next()方法是必须部署的，return()方法和throw()方法是否部署是可选的。</p> <p>return()方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return()方法。</p> <p>如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return()方法。</p> <p>注意，return()方法必须返回一个对象，这是 Generator 语法决定的。</p> <h3 id="for-of"><a href="#for-of" class="header-anchor">#</a> for of⭐️</h3> <p>for...of循环可以使用的范围包括</p> <ul><li>数组</li> <li>Set</li> <li>Map</li> <li>某些类似数组的对象（比如arguments对象、DOM NodeList 对象）</li> <li>Generator 对象</li> <li>字符串。</li></ul> <h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <p><strong>for...in循环读取键名，for...of循环读取键值。</strong></p> <p>for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。</p> <h4 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h4> <p>字符串来说，for...of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p> <h4 id="类似数组对象"><a href="#类似数组对象" class="header-anchor">#</a> 类似数组对象</h4> <p><strong>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</strong></p> <blockquote><p>具有Iterator 接口的话，可以使用扩展运算符将其转为数组</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span> length<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 报错</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token keyword">of</span> arrayLike<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 正确</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token keyword">of</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h4> <p><strong>对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。</strong></p> <blockquote><p>但是，对于普通的对象，for...in循环依然可以用来遍历键名。</p></blockquote> <p>一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>someObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">': '</span> <span class="token operator">+</span> someObject<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另一个方法是使用 Generator 函数将对象重新包装一下。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">entries</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'-&gt;'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// a -&gt; 1</span>
<span class="token comment">// b -&gt; 2</span>
<span class="token comment">// c -&gt; 3</span>
</code></pre></div><h2 id="symbol"><a href="#symbol" class="header-anchor">#</a> symbol</h2> <p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突</p> <p>ES6 引入Symbol，保证每个属性的名字都是独一无二，从根本上防止属性名的冲突</p> <p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Symbol.for()也可以生成</span>

<span class="token keyword">typeof</span> s
<span class="token comment">// &quot;symbol&quot;</span>
</code></pre></div><p><strong>注意，Symbol函数前不能使用new命令，否则会报错</strong></p> <p>这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p> <p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p> <p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p> <p>Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p> <p><strong>Symbol 值不能与其他类型的值进行运算，会报错。</strong></p> <p>Symbol 值可以显式转为字符串。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'My symbol'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">String</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span> <span class="token comment">// 'Symbol(My symbol)'</span>
sym<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'Symbol(My symbol)'</span>
</code></pre></div><p><strong>Symbol 值也可以转为布尔值(转为布尔值为true，因为只有5个值会转为false)，但是不能转为数值。</strong></p> <p><strong>Symbol 变量不能作为webStorage的键使用</strong></p> <h3 id="symbol-prototype-description"><a href="#symbol-prototype-description" class="header-anchor">#</a> Symbol.prototype.description</h3> <p>创建 Symbol 的时候，可以添加一个描述。</p> <p>ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。</p> <h3 id="作为属性名的-symbol"><a href="#作为属性名的-symbol" class="header-anchor">#</a> 作为属性名的 Symbol</h3> <p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。</p> <p>这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p> <p><strong>Symbol 值作为对象属性名时，不能用点运算符。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> mySymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。</span>
a<span class="token punctuation">.</span>mySymbol <span class="token operator">=</span> <span class="token string">'Hello!'</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span> <span class="token comment">// undefined</span>
a<span class="token punctuation">[</span><span class="token string">'mySymbol'</span><span class="token punctuation">]</span> <span class="token comment">// &quot;Hello!&quot;</span>
</code></pre></div><p>同理，<strong>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</strong></p> <p>如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。</p> <p>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。可以在类的外部访问</p> <h3 id="属性名的遍历-star"><a href="#属性名的遍历-star" class="header-anchor">#</a> 属性名的遍历:star-:</h3> <p>Symbol 作为属性名，遍历对象的时候，<strong>该属性不会出现在for...in、for...of循环中</strong></p> <p><strong>也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。</strong></p> <p><strong>Object.getOwnPropertySymbols()方法</strong>，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p> <p><strong>Reflect.ownKeys()方法</strong>可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p> <h3 id="symbol-for-，symbol-keyfor"><a href="#symbol-for-，symbol-keyfor" class="header-anchor">#</a> Symbol.for()，Symbol.keyFor()</h3> <p>Symbol.for()方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。</p> <p>如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p> <p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。</p> <p>它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p> <p>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。</p> <p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key(Symbol的字符串描述)。</p> <p>注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p> <p>Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p> <h3 id="symbol-iterator"><a href="#symbol-iterator" class="header-anchor">#</a> Symbol.iterator</h3> <p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p> <p>对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器</p> <h3 id="symbol-toprimitive"><a href="#symbol-toprimitive" class="header-anchor">#</a> Symbol.toPrimitive</h3> <p>对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p> <p>Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p> <ul><li>Number：该场合需要转成数值</li> <li>String：该场合需要转成字符串</li> <li>Default：该场合可以转成数值，也可以转成字符串</li></ul> <h3 id="symbol-tostringtag"><a href="#symbol-tostringtag" class="header-anchor">#</a> Symbol.toStringTag</h3> <p>对象的Symbol.toStringTag属性，指向一个方法。</p> <p>在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。</p> <p>可以用来定制[object Object]中object后面的那个字符串。</p> <p>ES6 新增内置对象的Symbol.toStringTag属性值如下。</p> <table><thead><tr><th>对象</th> <th>返回值</th></tr></thead> <tbody><tr><td>JSON[Symbol.toStringTag]</td> <td>'JSON'</td></tr> <tr><td>Math[Symbol.toStringTag]</td> <td>'Math'</td></tr> <tr><td>Module 对象M[Symbol.toStringTag]</td> <td>'Module'</td></tr> <tr><td>ArrayBuffer.prototype[Symbol.toStringTag]</td> <td>'ArrayBuffer'</td></tr> <tr><td>DataView.prototype[Symbol.toStringTag]</td> <td>'DataView'</td></tr> <tr><td>Map.prototype[Symbol.toStringTag]</td> <td>'Map'</td></tr> <tr><td>Promise.prototype[Symbol.toStringTag]</td> <td>'Promise'</td></tr> <tr><td>Set.prototype[Symbol.toStringTag]</td> <td>'Set'</td></tr> <tr><td>%TypedArray%.prototype[Symbol.toStringTag]</td> <td>'Uint8Array'等</td></tr> <tr><td>WeakMap.prototype[Symbol.toStringTag]</td> <td>'WeakMap'</td></tr> <tr><td>WeakSet.prototype[Symbol.toStringTag]</td> <td>'WeakSet'</td></tr> <tr><td>%MapIteratorPrototype%[Symbol.toStringTag]</td> <td>'Map Iterator'</td></tr> <tr><td>%SetIteratorPrototype%[Symbol.toStringTag]</td> <td>'Set Iterator'</td></tr> <tr><td>%StringIteratorPrototype%[Symbol.toStringTag]</td> <td>'String Iterator'</td></tr> <tr><td>Symbol.prototype[Symbol.toStringTag]</td> <td>'Symbol'</td></tr> <tr><td>Generator.prototype[Symbol.toStringTag]</td> <td>'Generator'</td></tr> <tr><td>eneratorFunction.prototype[Symbol.toStringTag]</td> <td>'GeneratorFunction'</td></tr></tbody></table> <h3 id="symbol-hasinstance"><a href="#symbol-hasinstance" class="header-anchor">#</a> Symbol.hasInstance⭐️</h3> <p>对象的Symbol.hasInstance属性，指向一个内部方法。</p> <p><strong>当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。</strong></p> <p>比如，foo instanceof Foo在语言内部，实际调用的是Foo<a href="foo">Symbol.hasInstance</a>。</p> <h3 id="symbol-isconcatspreadable"><a href="#symbol-isconcatspreadable" class="header-anchor">#</a> Symbol.isConcatSpreadable</h3> <p>对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。</p> <p>数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。</p> <p>类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。</p> <h3 id="symbol-species"><a href="#symbol-species" class="header-anchor">#</a> Symbol.species</h3> <p>对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p> <p>由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。</p> <p>定义Symbol.species属性要采用get取值器。</p> <p>Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。</p> <p>它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p> <h3 id="字符串方法调用"><a href="#字符串方法调用" class="header-anchor">#</a> 字符串方法调用</h3> <ul><li><p>Symbol.match</p> <p>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span>
<span class="token comment">// 等同于</span>
regexp<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>match<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

</code></pre></div></li> <li><p>Symbol.replace</p> <p>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>searchValue<span class="token punctuation">,</span> replaceValue<span class="token punctuation">)</span>
<span class="token comment">// 等同于</span>
searchValue<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>replace<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> replaceValue<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>Symbol.search</p> <p>对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>regexp<span class="token punctuation">)</span>
<span class="token comment">// 等同于</span>
regexp<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>search<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>Symbol.split</p> <p>对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>separator<span class="token punctuation">,</span> limit<span class="token punctuation">)</span>
<span class="token comment">// 等同于</span>
separator<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>split<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> limit<span class="token punctuation">)</span>
</code></pre></div></li></ul> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> proxy</h2> <p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p> <p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截</p> <p>因此提供了一种机制，可以对外界的访问进行过滤和改写。</p> <p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。</p> <p>其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为</p> <p>使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作。</p> <p>Proxy 实例也可以作为其他对象的原型对象。</p> <p>同一个拦截器函数，可以设置拦截多个操作。</p> <h3 id="this"><a href="#this" class="header-anchor">#</a> this</h3> <p>目标对象内部的this关键字会指向 Proxy 代理。</p> <p>有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p> <p>需要把this绑定目标对象</p> <p>Proxy 拦截函数内部的this，指向的是handler对象。</p> <h3 id="支持拦截的操作"><a href="#支持拦截的操作" class="header-anchor">#</a> 支持拦截的操作</h3> <table><thead><tr><th>操作</th> <th>描述</th></tr></thead> <tbody><tr><td>get(target, propKey, receiver)</td> <td>拦截对象属性的读取</td></tr> <tr><td>set(target, propKey, value, receiver)</td> <td>拦截对象属性的设置，返回一个布尔值。</td></tr> <tr><td>has(target, propKey)</td> <td>拦截propKey in proxy的操作，返回一个布尔值。</td></tr> <tr><td>deleteProperty(target, propKey)</td> <td>拦截delete proxy[propKey]的操作，返回一个布尔值。</td></tr> <tr><td>ownKeys(target)</td> <td>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回数组。</td></tr> <tr><td>getOwnPropertyDescriptor(target, propKey)</td> <td>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</td></tr> <tr><td>defineProperty(target, propKey, propDesc)</td> <td>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</td></tr> <tr><td>preventExtensions(target)</td> <td>拦截Object.preventExtensions(proxy)，返回一个布尔值。</td></tr> <tr><td>getPrototypeOf(target)</td> <td>拦截Object.getPrototypeOf(proxy)，返回一个对象。</td></tr> <tr><td>isExtensible(target)</td> <td>拦截Object.isExtensible(proxy)，返回一个布尔值。</td></tr> <tr><td>setPrototypeOf(target, proto)</td> <td>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</td></tr> <tr><td>apply(target, object, args)</td> <td>拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。</td></tr> <tr><td>construct(target, args)</td> <td>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。</td></tr></tbody></table> <h3 id="get"><a href="#get" class="header-anchor">#</a> get()</h3> <p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象）</p> <p>其中最后一个参数可选。</p> <p>get方法可以继承。</p> <p><strong>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></p> <h3 id="set"><a href="#set" class="header-anchor">#</a> set()</h3> <p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p> <blockquote><p>与get一样，都是最后一个参数为Proxy实例本身</p></blockquote> <p><strong>注意，如果目标对象自身的某个属性不可写，那么set方法将不起作用。</strong></p> <p>注意，严格模式下，set代理只要没有返回true，就会报错。</p> <h3 id="apply"><a href="#apply" class="header-anchor">#</a> apply()</h3> <p>apply方法拦截函数的调用、call和apply操作。</p> <p>apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p> <p>另外，直接调用Reflect.apply方法，也会被拦截。</p> <h3 id="has"><a href="#has" class="header-anchor">#</a> has()</h3> <p>has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。</p> <p>has()方法可以接受两个参数，分别是目标对象、需查询的属性名。</p> <p><strong>如果原对象的属性不可配置或者禁止扩展，这时has()拦截会报错。</strong></p> <p>值得注意的是，has()方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has()方法不判断一个属性是对象自身的属性，还是继承的属性。</p> <p>另外，虽然for...in循环也用到了in运算符，但是has()拦截对for...in循环不生效。</p> <blockquote><p>ownKeys()拦截</p></blockquote> <h3 id="construct"><a href="#construct" class="header-anchor">#</a> construct()</h3> <p>construct()方法用于拦截new命令</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">construct</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> args<span class="token punctuation">,</span> newTarget</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">target</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>construct()方法可以接受三个参数。</p> <ul><li>target：目标对象。</li> <li>args：构造函数的参数数组。</li> <li>newTarget：创造实例对象时，new命令作用的构造函数。</li></ul> <p>construct()方法返回的必须是一个对象，否则会报错。</p> <p>另外，由于construct()拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p> <p>注意，construct()方法中的this指向的是handler，而不是实例对象。</p> <h3 id="deleteproperty"><a href="#deleteproperty" class="header-anchor">#</a> deleteProperty()</h3> <p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p> <p>注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。</p> <h3 id="defineproperty"><a href="#defineproperty" class="header-anchor">#</a> defineProperty()</h3> <p>defineProperty()方法拦截了Object.defineProperty()操作。</p> <p>注意，如果目标对象不可扩展（non-extensible），则defineProperty()不能增加目标对象上不存在的属性，否则会报错。</p> <p>另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty()方法不得改变这两个设置。</p> <h3 id="ownkeys"><a href="#ownkeys" class="header-anchor">#</a> ownKeys()</h3> <p>ownKeys()方法用来拦截对象自身属性的读取操作。</p> <p>具体来说，拦截以下操作。</p> <ul><li>Object.getOwnPropertyNames()</li> <li>Object.getOwnPropertySymbols()</li> <li>Object.keys()</li> <li>for...in循环</li></ul> <p>注意，使用Object.keys()方法时，有三类属性会被ownKeys()方法自动过滤，不会返回。</p> <ul><li>目标对象上不存在的属性</li> <li>属性名为 Symbol 值</li> <li>不可遍历（enumerable）的属性</li></ul> <p>ownKeys(target)方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p> <p>ownKeys()方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p> <p>如果目标对象自身包含不可配置的属性，则该属性必须被ownKeys()方法返回，否则报错。</p> <p>另外，如果目标对象是不可扩展的（non-extensible），这时ownKeys()方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p> <h3 id="getprototypeof"><a href="#getprototypeof" class="header-anchor">#</a> getPrototypeOf()</h3> <p>getPrototypeOf()方法主要用来拦截获取对象原型。</p> <p>具体来说，拦截下面这些操作。</p> <ul><li>Object.prototype.<strong>proto</strong></li> <li>Object.prototype.isPrototypeOf()</li> <li>Object.getPrototypeOf()</li> <li>Reflect.getPrototypeOf()</li> <li>instanceof</li></ul> <p>注意，getPrototypeOf()方法的返回值必须是对象或者null，否则报错。</p> <p>另外，如果目标对象不可扩展（non-extensible）， getPrototypeOf()方法必须返回目标对象的原型对象。</p> <h3 id="setprototypeof"><a href="#setprototypeof" class="header-anchor">#</a> setPrototypeOf()</h3> <p>setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。</p> <p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。</p> <p>另外，如果目标对象不可扩展（non-extensible），setPrototypeOf()方法不得改变目标对象的原型。</p> <h3 id="isextensible"><a href="#isextensible" class="header-anchor">#</a> isExtensible()</h3> <p>isExtensible()方法拦截Object.isExtensible()操作。</p> <p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p> <p>这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。</p> <h3 id="preventextensions"><a href="#preventextensions" class="header-anchor">#</a> preventExtensions()</h3> <p>preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p> <p>这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</p> <h3 id="getownpropertydescriptor"><a href="#getownpropertydescriptor" class="header-anchor">#</a> getOwnPropertyDescriptor()</h3> <p>getOwnPropertyDescriptor()方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p> <h3 id="proxy-revocable"><a href="#proxy-revocable" class="header-anchor">#</a> Proxy.revocable()</h3> <p>Proxy.revocable()方法返回一个可取消的 Proxy 实例。</p> <h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <p>ES6 为了操作对象而提供的新 API。</p> <p>Reflect对象的设计目的有这样几个。</p> <ol><li><p>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p></li> <li><p>修改某些Object方法的返回结果，让其变得更合理。比如，<strong>Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误</strong>，而Reflect.defineProperty(obj, name, desc)则会返回false。</p></li> <li><p>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p></li> <li><p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p></li></ol> <h3 id="reflect-get-target-name-receiver"><a href="#reflect-get-target-name-receiver" class="header-anchor">#</a> Reflect.get(target, name, receiver)</h3> <p>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。</p> <p>receiver不是必选</p> <p>如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。</p> <p>如果第一个参数不是对象，Reflect.get方法会报错。</p> <p>不会进行类型转换</p> <h3 id="reflect-set-target-name-value-receiver"><a href="#reflect-set-target-name-value-receiver" class="header-anchor">#</a> Reflect.set(target, name, value, receiver)</h3> <p>Reflect.set方法设置target对象的name属性等于value。</p> <p>如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</p> <p>如果第一个参数不是对象，Reflect.set会报错。</p> <p>如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。</p> <p>这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例，而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。</p> <p>如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。</p> <h3 id="reflect-has-obj-name"><a href="#reflect-has-obj-name" class="header-anchor">#</a> Reflect.has(obj, name)</h3> <p>Reflect.has方法对应name in obj里面的in运算符。</p> <p>如果Reflect.has()方法的第一个参数不是对象，会报错。</p> <h3 id="reflect-ownkeys-target"><a href="#reflect-ownkeys-target" class="header-anchor">#</a> Reflect.ownKeys (target)</h3> <p>Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。</p> <h3 id="reflect-construct-target-args"><a href="#reflect-construct-target-args" class="header-anchor">#</a> Reflect.construct(target, args)⭐️</h3> <p>Reflect.construct方法等同于new target(...args)，这<strong>提供了一种不使用new，来调用构造函数的方法。</strong></p> <p>如果Reflect.construct()方法的第一个参数不是函数，会报错。</p> <h3 id="reflect-getprototypeof-obj"><a href="#reflect-getprototypeof-obj" class="header-anchor">#</a> Reflect.getPrototypeOf(obj)</h3> <p>Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。</p> <p>Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。</p> <h3 id="reflect-setprototypeof-obj-newproto"><a href="#reflect-setprototypeof-obj-newproto" class="header-anchor">#</a> Reflect.setPrototypeOf(obj, newProto)</h3> <p>Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。</p> <p>它返回一个布尔值，表示是否设置成功。</p> <p><strong>如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。</strong></p> <p><strong>如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。</strong></p> <p><strong>如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。</strong></p> <h3 id="reflect-apply-func-thisarg-args"><a href="#reflect-apply-func-thisarg-args" class="header-anchor">#</a> Reflect.apply(func, thisArg, args)</h3> <p>Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。</p> <p>一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)</p> <p>但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 旧写法</span>
<span class="token keyword">const</span> youngest <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> ages<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> oldest <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> ages<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>youngest<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 新写法</span>
<span class="token keyword">const</span> youngest <span class="token operator">=</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>min<span class="token punctuation">,</span> Math<span class="token punctuation">,</span> ages<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> oldest <span class="token operator">=</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">,</span> Math<span class="token punctuation">,</span> ages<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">,</span> youngest<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="reflect-defineproperty-target-propertykey-attributes"><a href="#reflect-defineproperty-target-propertykey-attributes" class="header-anchor">#</a> Reflect.defineProperty(target, propertyKey, attributes)</h3> <p>Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。</p> <p>未来，Object.defineProperty会被逐渐废除。</p> <p>如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误</p> <p>这个方法可以与Proxy.defineProperty配合使用。</p> <p>Proxy.defineProperty对属性赋值设置了拦截，然后使用Reflect.defineProperty完成了赋值。</p> <h3 id="reflect-getownpropertydescriptor-target-propertykey"><a href="#reflect-getownpropertydescriptor-target-propertykey" class="header-anchor">#</a> Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3> <p>Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象</p> <p>将来Object.getOwnPropertyDescriptor会被废除。</p> <p>Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是</p> <p>如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, 'foo')不报错，返回undefined，</p> <p>而Reflect.getOwnPropertyDescriptor(1, 'foo')会抛出错误，表示参数非法。</p> <h3 id="reflect-isextensible-target"><a href="#reflect-isextensible-target" class="header-anchor">#</a> Reflect.isExtensible (target)</h3> <p>Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。</p> <p>如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。</p> <h3 id="reflect-preventextensions-target"><a href="#reflect-preventextensions-target" class="header-anchor">#</a> Reflect.preventExtensions(target)</h3> <p>Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p> <p>如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。</p> <h3 id="reflect-deleteproperty-obj-name"><a href="#reflect-deleteproperty-obj-name" class="header-anchor">#</a> Reflect.deleteProperty(obj, name)</h3> <p>Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。</p> <p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。</p> <p>如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/js/es6-object.html" class="prev">
        ES6对象扩展
      </a></span> <span class="next"><a href="/frontend/js/es6-setAndMapRef.html">
        ES6 Set and Map
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.484f4375.js" defer></script><script src="/assets/js/2.ebbe98b4.js" defer></script><script src="/assets/js/61.bad1d82a.js" defer></script>
  </body>
</html>
