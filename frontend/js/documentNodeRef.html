<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Document 和 Element 文档 | ゼロツー</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="zerotwo">
    <link rel="preload" href="/assets/css/0.styles.f0b7ee7d.css" as="style"><link rel="preload" href="/assets/js/app.484f4375.js" as="script"><link rel="preload" href="/assets/js/2.ebbe98b4.js" as="script"><link rel="preload" href="/assets/js/56.d493a61b.js" as="script"><link rel="prefetch" href="/assets/js/10.91de1805.js"><link rel="prefetch" href="/assets/js/100.1772503e.js"><link rel="prefetch" href="/assets/js/101.b569a1af.js"><link rel="prefetch" href="/assets/js/102.65dffa11.js"><link rel="prefetch" href="/assets/js/103.d7a8cd9e.js"><link rel="prefetch" href="/assets/js/104.0a0e3708.js"><link rel="prefetch" href="/assets/js/105.15bc167a.js"><link rel="prefetch" href="/assets/js/106.8487cf9a.js"><link rel="prefetch" href="/assets/js/107.2310b94b.js"><link rel="prefetch" href="/assets/js/108.781b7ebe.js"><link rel="prefetch" href="/assets/js/109.6225704a.js"><link rel="prefetch" href="/assets/js/11.9c44c6b2.js"><link rel="prefetch" href="/assets/js/110.3c39cb3c.js"><link rel="prefetch" href="/assets/js/111.22bede53.js"><link rel="prefetch" href="/assets/js/112.acb6b722.js"><link rel="prefetch" href="/assets/js/113.c2b6115e.js"><link rel="prefetch" href="/assets/js/114.cbeddf77.js"><link rel="prefetch" href="/assets/js/115.adf2d1b9.js"><link rel="prefetch" href="/assets/js/116.3f23eb5b.js"><link rel="prefetch" href="/assets/js/117.00cb8ac3.js"><link rel="prefetch" href="/assets/js/118.e88e1cfb.js"><link rel="prefetch" href="/assets/js/119.213aaa9b.js"><link rel="prefetch" href="/assets/js/12.878aa51b.js"><link rel="prefetch" href="/assets/js/120.fc12eb0e.js"><link rel="prefetch" href="/assets/js/121.67bafb52.js"><link rel="prefetch" href="/assets/js/122.cca49856.js"><link rel="prefetch" href="/assets/js/123.0e27eb9e.js"><link rel="prefetch" href="/assets/js/124.53383547.js"><link rel="prefetch" href="/assets/js/125.e103d7f1.js"><link rel="prefetch" href="/assets/js/126.adb34a41.js"><link rel="prefetch" href="/assets/js/127.f352dcec.js"><link rel="prefetch" href="/assets/js/128.9aa22460.js"><link rel="prefetch" href="/assets/js/129.02dabe8a.js"><link rel="prefetch" href="/assets/js/13.b4c5b1dd.js"><link rel="prefetch" href="/assets/js/130.7d88cb43.js"><link rel="prefetch" href="/assets/js/14.dce5d003.js"><link rel="prefetch" href="/assets/js/15.ec0f3b1f.js"><link rel="prefetch" href="/assets/js/16.a9597b38.js"><link rel="prefetch" href="/assets/js/17.c8f44f51.js"><link rel="prefetch" href="/assets/js/18.67e67934.js"><link rel="prefetch" href="/assets/js/19.2b8ea36f.js"><link rel="prefetch" href="/assets/js/20.ee5ab76e.js"><link rel="prefetch" href="/assets/js/21.1582f8ed.js"><link rel="prefetch" href="/assets/js/22.130fb5fa.js"><link rel="prefetch" href="/assets/js/23.ecbb4b5d.js"><link rel="prefetch" href="/assets/js/24.0c8b3ecd.js"><link rel="prefetch" href="/assets/js/25.4aae22ea.js"><link rel="prefetch" href="/assets/js/26.4816aa3d.js"><link rel="prefetch" href="/assets/js/27.2e6f0659.js"><link rel="prefetch" href="/assets/js/28.7e0fef24.js"><link rel="prefetch" href="/assets/js/29.dad88d85.js"><link rel="prefetch" href="/assets/js/3.5e8d6a69.js"><link rel="prefetch" href="/assets/js/30.1ecf79ca.js"><link rel="prefetch" href="/assets/js/31.0a97fafc.js"><link rel="prefetch" href="/assets/js/32.8e6151d1.js"><link rel="prefetch" href="/assets/js/33.b5ff95d1.js"><link rel="prefetch" href="/assets/js/34.0d03faf5.js"><link rel="prefetch" href="/assets/js/35.6d4b4665.js"><link rel="prefetch" href="/assets/js/36.b42cbedf.js"><link rel="prefetch" href="/assets/js/37.4de10dce.js"><link rel="prefetch" href="/assets/js/38.9031eb30.js"><link rel="prefetch" href="/assets/js/39.daee868f.js"><link rel="prefetch" href="/assets/js/4.ceb8a314.js"><link rel="prefetch" href="/assets/js/40.df374a26.js"><link rel="prefetch" href="/assets/js/41.563436c6.js"><link rel="prefetch" href="/assets/js/42.b9200ca4.js"><link rel="prefetch" href="/assets/js/43.40ae12a3.js"><link rel="prefetch" href="/assets/js/44.4a0dd48e.js"><link rel="prefetch" href="/assets/js/45.20d657cc.js"><link rel="prefetch" href="/assets/js/46.2d34fe10.js"><link rel="prefetch" href="/assets/js/47.3dcb2d38.js"><link rel="prefetch" href="/assets/js/48.1b0959df.js"><link rel="prefetch" href="/assets/js/49.6652f2b2.js"><link rel="prefetch" href="/assets/js/5.b28c76e0.js"><link rel="prefetch" href="/assets/js/50.30bdc802.js"><link rel="prefetch" href="/assets/js/51.ebe5930a.js"><link rel="prefetch" href="/assets/js/52.02f2caf4.js"><link rel="prefetch" href="/assets/js/53.55df3fc5.js"><link rel="prefetch" href="/assets/js/54.e2bff3b5.js"><link rel="prefetch" href="/assets/js/55.c859c458.js"><link rel="prefetch" href="/assets/js/57.9af46dbf.js"><link rel="prefetch" href="/assets/js/58.46d4e8aa.js"><link rel="prefetch" href="/assets/js/59.82e453fe.js"><link rel="prefetch" href="/assets/js/6.b43fc5c2.js"><link rel="prefetch" href="/assets/js/60.d9652552.js"><link rel="prefetch" href="/assets/js/61.bad1d82a.js"><link rel="prefetch" href="/assets/js/62.8c307334.js"><link rel="prefetch" href="/assets/js/63.7ebafb7e.js"><link rel="prefetch" href="/assets/js/64.bc588101.js"><link rel="prefetch" href="/assets/js/65.6f66d6a2.js"><link rel="prefetch" href="/assets/js/66.ee6f0d41.js"><link rel="prefetch" href="/assets/js/67.0002a9a5.js"><link rel="prefetch" href="/assets/js/68.4a86ea26.js"><link rel="prefetch" href="/assets/js/69.c9e36070.js"><link rel="prefetch" href="/assets/js/7.87b3f924.js"><link rel="prefetch" href="/assets/js/70.40af8c94.js"><link rel="prefetch" href="/assets/js/71.ee207bd6.js"><link rel="prefetch" href="/assets/js/72.c389068e.js"><link rel="prefetch" href="/assets/js/73.c1526d9c.js"><link rel="prefetch" href="/assets/js/74.cd1c9d32.js"><link rel="prefetch" href="/assets/js/75.144c1f5b.js"><link rel="prefetch" href="/assets/js/76.4c36bfbf.js"><link rel="prefetch" href="/assets/js/77.7db5b3f1.js"><link rel="prefetch" href="/assets/js/78.de99e748.js"><link rel="prefetch" href="/assets/js/79.1febcdca.js"><link rel="prefetch" href="/assets/js/8.ab13bda4.js"><link rel="prefetch" href="/assets/js/80.e802c8bb.js"><link rel="prefetch" href="/assets/js/81.960e4a52.js"><link rel="prefetch" href="/assets/js/82.9a35963d.js"><link rel="prefetch" href="/assets/js/83.005e1aad.js"><link rel="prefetch" href="/assets/js/84.d61f7f01.js"><link rel="prefetch" href="/assets/js/85.0906b75c.js"><link rel="prefetch" href="/assets/js/86.dff86ecd.js"><link rel="prefetch" href="/assets/js/87.00755e79.js"><link rel="prefetch" href="/assets/js/88.00604a67.js"><link rel="prefetch" href="/assets/js/89.376832c9.js"><link rel="prefetch" href="/assets/js/9.b83e9e02.js"><link rel="prefetch" href="/assets/js/90.9be39541.js"><link rel="prefetch" href="/assets/js/91.d5eb29c9.js"><link rel="prefetch" href="/assets/js/92.9f5fba68.js"><link rel="prefetch" href="/assets/js/93.670dcf5c.js"><link rel="prefetch" href="/assets/js/94.9d783387.js"><link rel="prefetch" href="/assets/js/95.0fd08cc1.js"><link rel="prefetch" href="/assets/js/96.ae0eb4f1.js"><link rel="prefetch" href="/assets/js/97.1d15ea38.js"><link rel="prefetch" href="/assets/js/98.1bc97ef6.js"><link rel="prefetch" href="/assets/js/99.d91a7a9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f0b7ee7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./favicon.jpg" alt="ゼロツー" class="logo"> <span class="site-name can-hide">ゼロツー</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link router-link-active">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link router-link-active">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/js/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/frontend/js/array.html" class="sidebar-link">数组</a></li><li><a href="/frontend/js/async.html" class="sidebar-link">异步</a></li><li><a href="/frontend/js/copy.html" class="sidebar-link">拷贝</a></li><li><a href="/frontend/js/crossOrigin.html" class="sidebar-link">跨域</a></li><li><a href="/frontend/js/data.html" class="sidebar-link">数据类型</a></li><li><a href="/frontend/js/documentNodeRef.html" aria-current="page" class="active sidebar-link">Document 和 Element 文档</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/documentNodeRef.html#document节点" class="sidebar-link">Document节点⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/js/documentNodeRef.html#element-节点" class="sidebar-link">Element 节点</a></li></ul></li><li><a href="/frontend/js/dom.html" class="sidebar-link">DOM</a></li><li><a href="/frontend/js/domRef.html" class="sidebar-link">DOM接口文档</a></li><li><a href="/frontend/js/es6.html" class="sidebar-link">ES6</a></li><li><a href="/frontend/js/es6-data.html" class="sidebar-link">ES6 数据类型扩展</a></li><li><a href="/frontend/js/es6-object.html" class="sidebar-link">ES6对象扩展</a></li><li><a href="/frontend/js/es6-ref.html" class="sidebar-link">ES6 文档</a></li><li><a href="/frontend/js/es6-setAndMapRef.html" class="sidebar-link">ES6 Set and Map</a></li><li><a href="/frontend/js/event.html" class="sidebar-link">DOM事件</a></li><li><a href="/frontend/js/extension.html" class="sidebar-link">继承</a></li><li><a href="/frontend/js/function.html" class="sidebar-link">函数</a></li><li><a href="/frontend/js/js.html" class="sidebar-link">基础</a></li><li><a href="/frontend/js/module.html" class="sidebar-link">模块化</a></li><li><a href="/frontend/js/object.html" class="sidebar-link">对象</a></li><li><a href="/frontend/js/prototype.html" class="sidebar-link">原型</a></li><li><a href="/frontend/js/q.html" class="sidebar-link">一些输出问题</a></li><li><a href="/frontend/js/regexp.html" class="sidebar-link">正则表达式</a></li><li><a href="/frontend/js/thread.html" class="sidebar-link">多线程</a></li><li><a href="/frontend/js/window.html" class="sidebar-link">浏览器对象</a></li><li><a href="/frontend/js/xhr.html" class="sidebar-link">网络请求</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block warning"><p class="custom-block-title">说明</p> <p>查阅文档使用</p></div> <h2 id="document节点"><a href="#document节点" class="header-anchor">#</a> Document节点⭐️</h2> <p>document节点对象代表整个文档，每张网页都有自己的document对象。</p> <p>window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p> <p>document对象有不同的办法可以获取。</p> <ul><li>正常的网页，直接使用document或window.document。</li> <li>iframe框架里面的网页，使用iframe节点的contentDocument属性。</li> <li>Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。</li> <li>内部节点的ownerDocument属性。</li> <li>Node.prototype.getRootNode()</li></ul> <p>document对象继承了EventTarget接口和Node接口，并且混入（mixin）了ParentNode接口。</p> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <h4 id="document-doctype"><a href="#document-doctype" class="header-anchor">#</a> document.doctype</h4> <p>对于 HTML 文档来说，document对象一般有两个子节点。</p> <p>第一个子节点是document.doctype，指向DOCTYPE节点，即文档类型（Document Type Declaration，简写DTD）节点。</p> <p>HTML 的文档类型节点，一般写成!DOCTYPE html。如果网页没有声明 DTD，该属性返回null。</p> <blockquote><p>document.firstChild通常就返回这个节点。</p></blockquote> <h4 id="document-documentelement"><a href="#document-documentelement" class="header-anchor">#</a> document.documentElement⭐️</h4> <p><strong>document.documentElement属性返回当前文档的根元素节点（root）。</strong></p> <p>它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。</p> <p><strong>HTML网页的该属性，一般是html节点。</strong></p> <h4 id="document-body，document-head"><a href="#document-body，document-head" class="header-anchor">#</a> document.body，document.head</h4> <p>document.body属性指向body节点，document.head属性指向head节点。</p> <p>这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p> <h4 id="document-scrollingelement"><a href="#document-scrollingelement" class="header-anchor">#</a> document.scrollingElement</h4> <p>document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p> <p>标准模式下，这个属性返回的文档的根元素document.documentElement（即html）。</p> <p>兼容（quirk）模式下，返回的是body元素，如果该元素不存在，返回null。</p> <h4 id="document-activeelement"><a href="#document-activeelement" class="header-anchor">#</a> document.activeElement</h4> <p>document.activeElement属性返回获得当前焦点（focus）的 DOM 元素。</p> <p>通常，这个属性返回的是input、textarea、select等表单元素，</p> <p>如果当前没有焦点元素，返回body元素或null。</p> <h4 id="document-fullscreenelement"><a href="#document-fullscreenelement" class="header-anchor">#</a> document.fullscreenElement</h4> <p>document.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。</p> <p>通过document.fullscreenElement可以知道video元素有没有处在全屏状态，从而判断用户行为。</p> <h3 id="节点集合属性"><a href="#节点集合属性" class="header-anchor">#</a> 节点集合属性</h3> <p><strong>HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。</strong></p> <p>如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。</p> <p>以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p> <h4 id="document-links"><a href="#document-links" class="header-anchor">#</a> document.links</h4> <p>document.links属性返回当前文档所有设定了href属性的a及area节点。</p> <h4 id="document-forms"><a href="#document-forms" class="header-anchor">#</a> document.forms</h4> <p>document.forms属性返回所有form表单节点。</p> <p>除了使用位置序号，id属性和name属性也可以用来引用表单</p> <h4 id="document-images"><a href="#document-images" class="header-anchor">#</a> document.images</h4> <p>document.images属性返回页面所有img图片节点。</p> <h4 id="document-embeds，document-plugins"><a href="#document-embeds，document-plugins" class="header-anchor">#</a> document.embeds，document.plugins</h4> <p>document.embeds属性和document.plugins属性，都返回所有embed节点。</p> <h4 id="document-scripts"><a href="#document-scripts" class="header-anchor">#</a> document.scripts</h4> <p>document.scripts属性返回所有script节点。</p> <h3 id="文档静态信息属性"><a href="#文档静态信息属性" class="header-anchor">#</a> 文档静态信息属性</h3> <h4 id="document-documenturi，document-url"><a href="#document-documenturi，document-url" class="header-anchor">#</a> document.documentURI，document.URL</h4> <p>document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。</p> <p>如果文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化。</p> <p>不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；</p> <p>URL继承自HTMLDocument接口，只能用于 HTML 文档。</p> <blockquote><p>Node.prototype.baseURI属性返回一个字符串，表示当前网页的绝对路径。</p></blockquote> <h4 id="document-domain"><a href="#document-domain" class="header-anchor">#</a> document.domain</h4> <p>document.domain属性返回当前文档的域名，不包含协议和端口</p> <p>document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。</p> <p>比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。</p> <p>修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。</p> <p>另外，设置document.domain会导致端口被改成null。</p> <p>因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p> <h4 id="document-location"><a href="#document-location" class="header-anchor">#</a> document.location</h4> <p>Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。</p> <p>通过window.location和document.location属性，可以拿到这个对象。</p> <h4 id="document-lastmodified"><a href="#document-lastmodified" class="header-anchor">#</a> document.lastModified</h4> <p>document.lastModified属性返回一个<strong>字符串</strong>，表示当前文档最后修改的时间。</p> <p>不同浏览器的返回值，日期格式是不一样的。</p> <h4 id="document-title"><a href="#document-title" class="header-anchor">#</a> document.title</h4> <p>document.title属性返回当前文档的标题。</p> <p>默认情况下，返回title节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p> <h4 id="document-characterset"><a href="#document-characterset" class="header-anchor">#</a> document.characterSet</h4> <p>document.characterSet属性返回当前文档的编码</p> <h4 id="document-referrer"><a href="#document-referrer" class="header-anchor">#</a> document.referrer</h4> <p>document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。</p> <p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。</p> <p>document.referrer的值，总是与 HTTP 头信息的Referer字段保持一致。</p> <p>但是，document.referrer的拼写有两个r，而头信息的Referer字段只有一个r（将错就错）。</p> <h3 id="文档状态属性"><a href="#文档状态属性" class="header-anchor">#</a> 文档状态属性</h3> <h4 id="document-hidden"><a href="#document-hidden" class="header-anchor">#</a> document.hidden</h4> <p>document.hidden属性返回一个布尔值，表示当前页面是否可见。</p> <p>如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。</p> <p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p> <h4 id="document-visibilitystate"><a href="#document-visibilitystate" class="header-anchor">#</a> document.visibilityState⭐️</h4> <p>document.visibilityState返回文档的可见状态。</p> <p>它的值有四种可能。</p> <ul><li>visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li> <li>hidden：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li> <li>prerender：页面处于正在渲染状态，对于用户来说，该页面不可见。</li> <li>unloaded：页面从内存里面卸载了。</li></ul> <h4 id="document-readystate"><a href="#document-readystate" class="header-anchor">#</a> document.readyState</h4> <p>document.readyState属性返回当前文档的状态，共有三种可能的值。</p> <ul><li>loading：加载 HTML 代码阶段（尚未完成解析）</li> <li>interactive：加载外部资源阶段</li> <li>complete：加载完成</li></ul> <p>这个属性变化的过程如下。</p> <ol><li>浏览器开始解析 HTML 文档，document.readyState属性等于loading。</li> <li>浏览器遇到 HTML 文档中的script元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。</li> <li>HTML 文档解析完成，document.readyState属性变成interactive。</li> <li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。</li></ol> <h4 id="document-cookie"><a href="#document-cookie" class="header-anchor">#</a> document.cookie</h4> <p>document.cookie属性用来操作浏览器 Cookie</p> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <h4 id="document-open-，document-close"><a href="#document-open-，document-close" class="header-anchor">#</a> document.open()，document.close()</h4> <p>document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。</p> <p>document.close方法用来关闭document.open()打开的文档。</p> <h4 id="document-queryselector-，document-queryselectorall"><a href="#document-queryselector-，document-queryselectorall" class="header-anchor">#</a> document.querySelector()，document.querySelectorAll()⭐️</h4> <p>document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。</p> <p><strong>如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。</strong></p> <p>document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。</p> <p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p> <p>这两个方法都支持复杂的 CSS 选择器。</p> <p><strong>它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。</strong></p> <p>如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。</p> <p><strong>另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。</strong></p> <p>这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。</p> <h4 id="document-getelementsbytagname"><a href="#document-getelementsbytagname" class="header-anchor">#</a> document.getElementsByTagName()⭐️</h4> <p><code>document.getElementsByTagName()</code>方法搜索 HTML 标签名，返回符合条件的元素。</p> <p>它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。</p> <p>如果没有任何匹配的元素，就返回一个空集。</p> <p><strong>HTML 标签名是大小写不敏感的，因此getElementsByTagName()方法的参数也是大小写不敏感的。</strong></p> <p>另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p> <p>如果传入*，就可以返回文档中所有 HTML 元素。</p> <p>元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。</p> <p>也就是说，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。</p> <h4 id="document-getelementsbyclassname"><a href="#document-getelementsbyclassname" class="header-anchor">#</a> document.getElementsByClassName()⭐️</h4> <p><code>document.getElementsByClassName()</code>方法返回一个类似数组的对象（HTMLCollection实例）</p> <p>包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p> <p>由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class。</p> <p>参数可以是多个class，它们之间使用空格分隔。顺序不重要</p> <blockquote><p>正常模式下，CSS 的class是大小写敏感的。</p></blockquote> <h4 id="document-getelementsbyname"><a href="#document-getelementsbyname" class="header-anchor">#</a> document.getElementsByName()</h4> <p>document.getElementsByName()方法用于选择拥有name属性的 HTML 元素</p> <p>返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。</p> <h4 id="document-getelementbyid"><a href="#document-getelementbyid" class="header-anchor">#</a> document.getElementById()</h4> <p>document.getElementById()方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。</p> <p>该方法的参数是大小写敏感的</p> <h4 id="document-createelement"><a href="#document-createelement" class="header-anchor">#</a> document.createElement()</h4> <p>document.createElement方法用来生成元素节点，并返回该节点。</p> <p>createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感</p> <p>document.createElement的参数可以是自定义的标签名。</p> <h4 id="document-createtextnode"><a href="#document-createtextnode" class="header-anchor">#</a> document.createTextNode()</h4> <p>document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。</p> <p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。</p> <h4 id="document-createattribute"><a href="#document-createattribute" class="header-anchor">#</a> document.createAttribute()</h4> <p>document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。</p> <p><code>var attribute = document.createAttribute(name);</code></p> <p>document.createAttribute方法的参数name，是属性的名称。</p> <h4 id="document-createcomment"><a href="#document-createcomment" class="header-anchor">#</a> document.createComment()</h4> <p>document.createComment方法生成一个新的注释节点，并返回该节点。</p> <p><code>var CommentNode = document.createComment(data);</code></p> <p>document.createComment方法的参数是一个字符串，会成为注释节点的内容。</p> <h4 id="document-createdocumentfragment"><a href="#document-createdocumentfragment" class="header-anchor">#</a> document.createDocumentFragment()⭐️</h4> <p>document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。</p> <p><code>var docFragment = document.createDocumentFragment();</code></p> <p>DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。</p> <p>这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p> <h4 id="document-createevent"><a href="#document-createevent" class="header-anchor">#</a> document.createEvent()</h4> <p>document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。</p> <p>document.createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。</p> <h4 id="document-addeventlistener-，document-removeeventlistener-，document-dispatchevent"><a href="#document-addeventlistener-，document-removeeventlistener-，document-dispatchevent" class="header-anchor">#</a> document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4> <p>这三个方法用于处理document节点的事件。它们都继承自EventTarget接口</p> <h4 id="document-hasfocus"><a href="#document-hasfocus" class="header-anchor">#</a> document.hasFocus()</h4> <p>document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p> <h4 id="document-createnodeiterator"><a href="#document-createnodeiterator" class="header-anchor">#</a> document.createNodeIterator()⭐️</h4> <p>document.createNodeIterator方法返回一个子节点遍历器。</p> <p>返回一个“遍历器”对象（NodeFilter实例）。该实例的nextNode()方法和previousNode()方法，可以用来遍历所有子节点。</p> <p>document.createNodeIterator方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型</p> <p>这里指定为元素节点（NodeFilter.SHOW_ELEMENT）。几种主要的节点类型写法如下。</p> <ul><li>所有节点：NodeFilter.SHOW_ALL</li> <li>元素节点：NodeFilter.SHOW_ELEMENT</li> <li>文本节点：NodeFilter.SHOW_TEXT</li> <li>评论节点：NodeFilter.SHOW_COMMENT</li></ul> <h4 id="document-createtreewalker"><a href="#document-createtreewalker" class="header-anchor">#</a> document.createTreeWalker()⭐️</h4> <p>document.createTreeWalker方法返回一个 DOM 的子树遍历器。</p> <p>它与document.createNodeIterator方法基本是类似的，</p> <p>区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。</p> <p>另外，它的第一个节点不是根节点。</p> <p>document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型</p> <blockquote><p>与document.createNodeIterator方法的第二个参数相同。</p></blockquote> <h3 id="新建节点的方法"><a href="#新建节点的方法" class="header-anchor">#</a> 新建节点的方法</h3> <ul><li>document.createElement()</li> <li>document.createTextNode()</li> <li>document.createAttribute()</li> <li>document.createComment()</li> <li>document.createDocumentFragment()(文档片段对象)</li></ul> <h2 id="element-节点"><a href="#element-节点" class="header-anchor">#</a> Element 节点</h2> <p>每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。</p> <p>元素节点的nodeType属性都是1。</p> <p>不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点</p> <h3 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="header-anchor">#</a> 元素特性的相关属性</h3> <h4 id="element-id"><a href="#element-id" class="header-anchor">#</a> Element.id</h4> <p>Element.id属性返回指定元素的id属性，该属性可读写。</p> <p>注意，id属性的值是大小写敏感</p> <h4 id="element-tagname"><a href="#element-tagname" class="header-anchor">#</a> Element.tagName</h4> <p>Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。</p> <h4 id="element-accesskey"><a href="#element-accesskey" class="header-anchor">#</a> Element.accessKey</h4> <p>Element.accessKey属性用于读写分配给当前元素的快捷键。</p> <h4 id="element-draggable"><a href="#element-draggable" class="header-anchor">#</a> Element.draggable</h4> <p>Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p> <h4 id="element-tabindex"><a href="#element-tabindex" class="header-anchor">#</a> Element.tabIndex</h4> <p>Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p> <p>tabIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。</p> <p>如果是正整数，则按照顺序，从小到大遍历。</p> <p>如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。</p> <p>遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，</p> <blockquote><p>顺序为它们在网页中出现的顺序。</p></blockquote> <h4 id="element-title"><a href="#element-title" class="header-anchor">#</a> Element.title</h4> <p>Element.title属性用来读写当前元素的 HTML 属性title。</p> <p>该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p> <h3 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="header-anchor">#</a> 元素状态的相关属性⭐️</h3> <h4 id="element-hidden"><a href="#element-hidden" class="header-anchor">#</a> Element.hidden</h4> <p>Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。</p> <p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。</p> <p>也就是说，这个属性并不能用来判断当前元素的实际可见性。</p> <p>CSS 的设置高于Element.hidden。这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p> <h4 id="element-attributes"><a href="#element-attributes" class="header-anchor">#</a> Element.attributes</h4> <p>Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点</p> <h4 id="element-classname，element-classlist"><a href="#element-classname，element-classlist" class="header-anchor">#</a> Element.className，Element.classList</h4> <p>className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。</p> <p>classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。</p> <p>classList对象有下列方法。</p> <ul><li>add()：增加一个 class。</li> <li>remove()：移除一个 class。</li> <li>contains()：检查当前元素是否包含某个 class。</li> <li>toggle()：将某个 class 移入或移出当前元素。</li> <li>item()：返回指定索引位置的 class。</li> <li>toString()：将 class 的列表转为字符串。</li></ul> <h4 id="element-dataset"><a href="#element-dataset" class="header-anchor">#</a> Element.dataset</h4> <p>网页元素可以自定义data-属性，用来添加数据。</p> <p>Element.dataset属性返回一个对象，可以从这个对象读写data-属性。</p> <blockquote><p>开头的data-会省略。如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</p></blockquote> <p>如，data-abc-def对应dataset.abcDef，data-abc-1对应dataset[&quot;abc-1&quot;]。</p> <p>使用Element.getAttribute()和Element.setAttribute()，通过完整的属性名读写这些属性。</p> <h4 id="element-innerhtml"><a href="#element-innerhtml" class="header-anchor">#</a> Element.innerHTML⭐️</h4> <p>Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。</p> <p>该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括HTML和body元素。</p> <p><strong>如果将innerHTML属性设为空，等于删除所有它包含的所有节点。</strong></p> <p>如果文本节点包含&amp;、小于号（&lt;）和大于号（&gt;），innerHTML属性会将它们转为实体形式&amp;、&lt;、&gt;。</p> <p>如果想得到原文，建议使用element.textContent属性。</p> <p>如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，</p> <p><strong>如果文本之中含有script标签，虽然可以生成script节点，但是插入的代码不会执行。</strong></p> <p>但是，innerHTML还是有安全风险的。比如alert方法是会执行的</p> <h4 id="element-outerhtml"><a href="#element-outerhtml" class="header-anchor">#</a> Element.outerHTML</h4> <p>Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p> <h4 id="element-clientheight，element-clientwidth"><a href="#element-clientheight，element-clientwidth" class="header-anchor">#</a> Element.clientHeight，Element.clientWidth</h4> <p>Element.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素）</p> <p>只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。</p> <p><strong>除了元素本身的高度，它还包括padding部分，但是不包括border、margin。</strong></p> <p>如果有水平滚动条，还要减去水平滚动条的高度。</p> <p>Element.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效</p> <p>也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p> <p><strong>document.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度）</strong></p> <p><strong>等同于window.innerHeight属性减去水平滚动条的高度（如果有的话）。</strong></p> <p><strong>document.body的高度则是网页的实际高度。</strong></p> <p>一般来说，document.body.clientHeight大于document.documentElement.clientHeight。</p> <h4 id="element-clientleft，element-clienttop"><a href="#element-clientleft，element-clienttop" class="header-anchor">#</a> Element.clientLeft，Element.clientTop</h4> <p><strong>Element.clientLeft属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的padding和margin。</strong></p> <p>如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。</p> <p>该属性总是返回整数值，如果是小数，会四舍五入。</p> <p>Element.clientTop属性等于网页元素顶部边框的宽度（单位像素），其他特点都与clientLeft相同。</p> <h4 id="element-scrollheight，element-scrollwidth"><a href="#element-scrollheight，element-scrollwidth" class="header-anchor">#</a> Element.scrollHeight，Element.scrollWidth</h4> <p><strong>Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。</strong></p> <p><strong>它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。</strong></p> <p>Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。</p> <p>整张网页的总高度可以从<strong>document.documentElement或document.body</strong>上读取。</p> <h4 id="element-scrollleft，element-scrolltop"><a href="#element-scrollleft，element-scrolltop" class="header-anchor">#</a> Element.scrollLeft，Element.scrollTop</h4> <p>Element.scrollLeft属性表示当前元素的水平滚动条向<strong>右侧</strong>滚动的像素数量，</p> <p>Element.scrollTop属性表示当前元素的垂直滚动条<strong>向下</strong>滚动的像素数量。</p> <p>对于那些没有滚动条的网页元素，这两个属性总是等于0。</p> <p>如果要查看整张网页的水平的和垂直的滚动距离，要从<strong>document.documentElement元素</strong>上读取。</p> <h4 id="element-offsetparent"><a href="#element-offsetparent" class="header-anchor">#</a> Element.offsetParent</h4> <p><strong>Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。</strong></p> <p>该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。</p> <p><strong>如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。</strong></p> <h4 id="element-offsetheight，element-offsetwidth"><a href="#element-offsetheight，element-offsetwidth" class="header-anchor">#</a> Element.offsetHeight，Element.offsetWidth</h4> <p>Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素）</p> <p><strong>包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。</strong></p> <p>Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。</p> <p><strong>这两个属性都是只读属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。</strong></p> <p><strong>如果元素的 CSS 设为不可见（比如display: none;），则返回0。</strong></p> <h4 id="element-offsetleft，element-offsettop"><a href="#element-offsetleft，element-offsettop" class="header-anchor">#</a> Element.offsetLeft，Element.offsetTop⭐️</h4> <p>Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移</p> <p>Element.offsetTop返回垂直位移，单位为像素。</p> <p>通常，这两个值是指相对于父节点的位移。</p> <p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getElementPosition</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
		x <span class="token operator">+=</span> e<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>
		y <span class="token operator">+=</span> e<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>
		e <span class="token operator">=</span> e<span class="token punctuation">.</span>offsetParent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> x<span class="token punctuation">,</span> y<span class="token operator">:</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="element-children，element-childelementcount"><a href="#element-children，element-childelementcount" class="header-anchor">#</a> Element.children，Element.childElementCount⭐️</h4> <p>Element.children属性返回一个类似数组的对象（HTMLCollection实例）</p> <p>包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p> <p><strong>这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</strong></p> <p>Element.childElementCount属性返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。</p> <h4 id="element-firstelementchild，element-lastelementchild"><a href="#element-firstelementchild，element-lastelementchild" class="header-anchor">#</a> Element.firstElementChild，Element.lastElementChild</h4> <p>Element.firstElementChild属性返回当前元素的第一个元素子节点，</p> <p>Element.lastElementChild返回最后一个元素子节点。</p> <p>如果没有元素子节点，这两个属性返回null。</p> <h4 id="element-nextelementsibling，element-previouselementsibling"><a href="#element-nextelementsibling，element-previouselementsibling" class="header-anchor">#</a> Element.nextElementSibling，Element.previousElementSibling</h4> <p>Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。</p> <p>Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。</p> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <h4 id="属性相关方法"><a href="#属性相关方法" class="header-anchor">#</a> 属性相关方法</h4> <table><thead><tr><th>方法</th> <th>描述</th></tr></thead> <tbody><tr><td>getAttribute()</td> <td>读取某个属性的值</td></tr> <tr><td>getAttributeNames()</td> <td>返回当前元素的所有属性名</td></tr> <tr><td>setAttribute()</td> <td>写入属性值</td></tr> <tr><td>hasAttribute()</td> <td>某个属性是否存在</td></tr> <tr><td>hasAttributes()</td> <td>当前元素是否有属性</td></tr> <tr><td>removeAttribute()</td> <td>删除属性</td></tr></tbody></table> <p>这六个方法对所有属性（包括用户自定义的属性）都适用。</p> <p>getAttribute()只返回字符串，不会返回其他类型的值。</p> <p>这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。</p> <p>另外，这些方法对于属性名是大小写不敏感的。</p> <h4 id="element-queryselector"><a href="#element-queryselector" class="header-anchor">#</a> Element.querySelector()</h4> <p>Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。</p> <p>如果没有找到匹配的子元素，就返回null。</p> <p>注意，这个方法无法选中伪元素。</p> <p>它可以接受多个选择器，它们之间使用逗号分隔。</p> <h4 id="element-queryselectorall"><a href="#element-queryselectorall" class="header-anchor">#</a> Element.querySelectorAll()</h4> <p>Element.querySelectorAll方法接受 CSS 选择器作为参数，<strong>返回一个NodeList实例</strong>，包含所有匹配的子元素。</p> <p>该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。</p> <p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。</p> <p>如果选择器里面有伪元素的选择器，则总是返回一个空的NodeList实例。</p> <h4 id="element-getelementsbyclassname"><a href="#element-getelementsbyclassname" class="header-anchor">#</a> Element.getElementsByClassName()</h4> <p>Element.getElementsByClassName方法<strong>返回一个HTMLCollection实例</strong></p> <p>成员是当前元素节点的所有具有指定 class 的子元素节点。</p> <p>该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p> <p>该方法的参数大小写敏感。</p> <h4 id="element-getelementsbytagname"><a href="#element-getelementsbytagname" class="header-anchor">#</a> Element.getElementsByTagName()</h4> <p>Element.getElementsByTagName()方法返回一个HTMLCollection实例，</p> <p>成员是当前节点的所有匹配指定标签名的子元素节点。</p> <p>该方法与document.getElementsByClassName()方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p> <h4 id="element-matches"><a href="#element-matches" class="header-anchor">#</a> Element.matches()</h4> <p>Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器</p> <h4 id="事件相关方法"><a href="#事件相关方法" class="header-anchor">#</a> 事件相关方法</h4> <p>以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口</p> <ul><li>Element.addEventListener()：添加事件的回调函数</li> <li>Element.removeEventListener()：移除事件监听函数</li> <li>Element.dispatchEvent()：触发事件</li></ul> <h4 id="element-scrollintoview"><a href="#element-scrollintoview" class="header-anchor">#</a> Element.scrollIntoView()</h4> <p>Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。</p> <p>参数：</p> <ul><li><p>alignToTop可选，一个Boolean值：</p> <p>如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的 scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}。这是这个参数的默认值。</p> <p>如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest&quot;}。</p></li> <li><p>scrollIntoViewOptions 可选，一个包含下列属性的对象：</p> <ul><li><p>behavior 可选</p> <p>定义动画过渡效果， &quot;auto&quot;或 &quot;smooth&quot; 之一。默认为 &quot;auto&quot;。</p></li> <li><p>block 可选</p> <p>定义垂直方向的对齐， &quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;start&quot;。</p></li> <li><p>inline 可选</p> <p>定义水平方向的对齐， &quot;start&quot;, &quot;center&quot;, &quot;end&quot;, 或 &quot;nearest&quot;之一。默认为 &quot;nearest&quot;。</p></li></ul></li></ul> <h4 id="element-getboundingclientrect"><a href="#element-getboundingclientrect" class="header-anchor">#</a> Element.getBoundingClientRect()⭐️</h4> <p>Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息</p> <p><strong>用于懒加载判断元素是否进入可视区域</strong></p> <p>getBoundingClientRect方法返回的rect对象，具有以下属性（全部为只读）。</p> <ul><li>x：元素左上角相对于视口的横坐标</li> <li>y：元素左上角相对于视口的纵坐标</li> <li>height：元素高度</li> <li>width：元素宽度</li> <li>left：元素左上角相对于视口的横坐标，与x属性相等</li> <li>right：元素右边界相对于视口的横坐标（等于x + width）</li> <li>top：元素顶部相对于视口的纵坐标，与y属性相等</li> <li>bottom：元素底部相对于视口的纵坐标（等于y + height）</li></ul> <p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。</p> <p>如果想得到绝对位置，可以将left属性加上window.scrollX，top属性加上window.scrollY。</p> <p>getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。</p> <p>都是从边框外缘的各个点来计算。</p> <p>因此，<strong>width和height包括了元素本身 + padding + border。</strong></p> <p><strong>上面的这些属性，都是继承自原型的属性，Object.keys会返回一个空数组</strong></p> <h4 id="element-getclientrects"><a href="#element-getclientrects" class="header-anchor">#</a> Element.getClientRects()</h4> <p>Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。</p> <p>每个矩形都有height、width、left、right、top和bottom六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p> <p>对于盒状元素，该方法返回的对象中只有该元素一个成员。</p> <p>对于行内元素，该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。</p> <p>这是它和Element.getBoundingClientRect()方法的主要区别，后者对于行内元素总是返回一个矩形。</p> <h4 id="element-insertadjacentelement"><a href="#element-insertadjacentelement" class="header-anchor">#</a> Element.insertAdjacentElement()</h4> <p>Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。</p> <p>该方法返回被插入的节点，如果插入失败，返回null。</p> <p><code>element.insertAdjacentElement(position, element);</code></p> <p>Element.insertAdjacentElement方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，</p> <p>第二个参数是将要插入的节点。</p> <h4 id="element-insertadjacenthtml-，element-insertadjacenttext"><a href="#element-insertadjacenthtml-，element-insertadjacenttext" class="header-anchor">#</a> Element.insertAdjacentHTML()，Element.insertAdjacentText()</h4> <p>Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p> <p><code>element.insertAdjacentHTML(position, text);</code></p> <p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。</p> <p>该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p> <p>Element.insertAdjacentText方法在相对于当前节点的指定位置，插入一个文本节点，用法与Element.insertAdjacentHTML方法完全一致。</p> <h4 id="element-remove"><a href="#element-remove" class="header-anchor">#</a> Element.remove()</h4> <p>Element.remove方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</p> <h4 id="element-focus-，element-blur"><a href="#element-focus-，element-blur" class="header-anchor">#</a> Element.focus()，Element.blur()</h4> <p>Element.focus方法用于将当前页面的焦点，转移到指定元素上。</p> <h3 id="属性操作"><a href="#属性操作" class="header-anchor">#</a> 属性操作</h3> <h4 id="element-attributes-属性"><a href="#element-attributes-属性" class="header-anchor">#</a> Element.attributes 属性</h4> <p>元素对象有一个attributes属性，返回一个类似数组的动态对象。</p> <p>成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。</p> <p>其他类型的节点对象，虽然也有attributes属性，但返回的都是null，因此可以把这个属性视为元素对象独有的。</p> <p>单个属性可以通过序号引用，也可以通过属性名引用。</p> <h4 id="element-getattribute"><a href="#element-getattribute" class="header-anchor">#</a> Element.getAttribute()</h4> <p>Element.getAttribute方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。</p> <h4 id="element-getattributenames"><a href="#element-getattributenames" class="header-anchor">#</a> Element.getAttributeNames()</h4> <p>Element.getAttributeNames()返回一个数组，成员是当前元素的所有属性的名字。</p> <p>如果当前元素没有任何属性，则返回一个空数组。</p> <p><strong>使用Element.attributes属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</strong></p> <h4 id="element-setattribute"><a href="#element-setattribute" class="header-anchor">#</a> Element.setAttribute()</h4> <p>Element.setAttribute方法用于为当前元素节点新增属性。</p> <p>如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p> <p>属性值总是字符串，其他类型的值会自动转成字符串</p> <div class="custom-block tip"><p class="custom-block-title">特殊</p> <p>对于button元素来说，布尔属性disable属性不需要属性值，</p> <p>只要设置了就总是会生效，因此setAttribute方法里面可以将disabled属性设成任意值。</p></div> <h4 id="element-hasattribute"><a href="#element-hasattribute" class="header-anchor">#</a> Element.hasAttribute()</h4> <p>Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p> <h4 id="element-hasattributes"><a href="#element-hasattributes" class="header-anchor">#</a> Element.hasAttributes()</h4> <p>Element.hasAttributes方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回false，否则返回true。</p> <h4 id="element-removeattribute"><a href="#element-removeattribute" class="header-anchor">#</a> Element.removeAttribute()</h4> <p>Element.removeAttribute方法移除指定属性。该方法没有返回值。</p> <h4 id="dataset-属性"><a href="#dataset-属性" class="header-anchor">#</a> dataset 属性⭐️</h4> <p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。</p> <p>素节点对象的dataset属性，它指向一个对象，可以用来操作 HTML 元素标签的data-*属性</p> <p>删除一个data-*属性，可以直接使用delete命令。</p> <p>注意，data-后面的属性名有限制，只能包含字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。</p> <p>而且，属性名不应该使用A到Z的大写字母，比如不能有data-helloWorld这样的属性名，而要写成data-hello-world。</p> <p>转成dataset的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。</p> <p>反过来，dataset的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。</p> <blockquote><p>比如，dataset.helloWorld会转成data-hello-world。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/js/data.html" class="prev">
        数据类型
      </a></span> <span class="next"><a href="/frontend/js/dom.html">
        DOM
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.484f4375.js" defer></script><script src="/assets/js/2.ebbe98b4.js" defer></script><script src="/assets/js/56.d493a61b.js" defer></script>
  </body>
</html>
