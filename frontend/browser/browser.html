<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础知识 | ゼロツー</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="zerotwo">
    <link rel="preload" href="/assets/css/0.styles.f0b7ee7d.css" as="style"><link rel="preload" href="/assets/js/app.484f4375.js" as="script"><link rel="preload" href="/assets/js/2.ebbe98b4.js" as="script"><link rel="preload" href="/assets/js/23.ecbb4b5d.js" as="script"><link rel="prefetch" href="/assets/js/10.91de1805.js"><link rel="prefetch" href="/assets/js/100.1772503e.js"><link rel="prefetch" href="/assets/js/101.b569a1af.js"><link rel="prefetch" href="/assets/js/102.65dffa11.js"><link rel="prefetch" href="/assets/js/103.d7a8cd9e.js"><link rel="prefetch" href="/assets/js/104.0a0e3708.js"><link rel="prefetch" href="/assets/js/105.15bc167a.js"><link rel="prefetch" href="/assets/js/106.8487cf9a.js"><link rel="prefetch" href="/assets/js/107.2310b94b.js"><link rel="prefetch" href="/assets/js/108.781b7ebe.js"><link rel="prefetch" href="/assets/js/109.6225704a.js"><link rel="prefetch" href="/assets/js/11.9c44c6b2.js"><link rel="prefetch" href="/assets/js/110.3c39cb3c.js"><link rel="prefetch" href="/assets/js/111.22bede53.js"><link rel="prefetch" href="/assets/js/112.acb6b722.js"><link rel="prefetch" href="/assets/js/113.c2b6115e.js"><link rel="prefetch" href="/assets/js/114.cbeddf77.js"><link rel="prefetch" href="/assets/js/115.adf2d1b9.js"><link rel="prefetch" href="/assets/js/116.3f23eb5b.js"><link rel="prefetch" href="/assets/js/117.00cb8ac3.js"><link rel="prefetch" href="/assets/js/118.e88e1cfb.js"><link rel="prefetch" href="/assets/js/119.213aaa9b.js"><link rel="prefetch" href="/assets/js/12.878aa51b.js"><link rel="prefetch" href="/assets/js/120.fc12eb0e.js"><link rel="prefetch" href="/assets/js/121.67bafb52.js"><link rel="prefetch" href="/assets/js/122.cca49856.js"><link rel="prefetch" href="/assets/js/123.0e27eb9e.js"><link rel="prefetch" href="/assets/js/124.53383547.js"><link rel="prefetch" href="/assets/js/125.e103d7f1.js"><link rel="prefetch" href="/assets/js/126.adb34a41.js"><link rel="prefetch" href="/assets/js/127.f352dcec.js"><link rel="prefetch" href="/assets/js/128.9aa22460.js"><link rel="prefetch" href="/assets/js/129.02dabe8a.js"><link rel="prefetch" href="/assets/js/13.b4c5b1dd.js"><link rel="prefetch" href="/assets/js/130.7d88cb43.js"><link rel="prefetch" href="/assets/js/14.dce5d003.js"><link rel="prefetch" href="/assets/js/15.ec0f3b1f.js"><link rel="prefetch" href="/assets/js/16.a9597b38.js"><link rel="prefetch" href="/assets/js/17.c8f44f51.js"><link rel="prefetch" href="/assets/js/18.67e67934.js"><link rel="prefetch" href="/assets/js/19.2b8ea36f.js"><link rel="prefetch" href="/assets/js/20.ee5ab76e.js"><link rel="prefetch" href="/assets/js/21.1582f8ed.js"><link rel="prefetch" href="/assets/js/22.130fb5fa.js"><link rel="prefetch" href="/assets/js/24.0c8b3ecd.js"><link rel="prefetch" href="/assets/js/25.4aae22ea.js"><link rel="prefetch" href="/assets/js/26.4816aa3d.js"><link rel="prefetch" href="/assets/js/27.2e6f0659.js"><link rel="prefetch" href="/assets/js/28.7e0fef24.js"><link rel="prefetch" href="/assets/js/29.dad88d85.js"><link rel="prefetch" href="/assets/js/3.5e8d6a69.js"><link rel="prefetch" href="/assets/js/30.1ecf79ca.js"><link rel="prefetch" href="/assets/js/31.0a97fafc.js"><link rel="prefetch" href="/assets/js/32.8e6151d1.js"><link rel="prefetch" href="/assets/js/33.b5ff95d1.js"><link rel="prefetch" href="/assets/js/34.0d03faf5.js"><link rel="prefetch" href="/assets/js/35.6d4b4665.js"><link rel="prefetch" href="/assets/js/36.b42cbedf.js"><link rel="prefetch" href="/assets/js/37.4de10dce.js"><link rel="prefetch" href="/assets/js/38.9031eb30.js"><link rel="prefetch" href="/assets/js/39.daee868f.js"><link rel="prefetch" href="/assets/js/4.ceb8a314.js"><link rel="prefetch" href="/assets/js/40.df374a26.js"><link rel="prefetch" href="/assets/js/41.563436c6.js"><link rel="prefetch" href="/assets/js/42.b9200ca4.js"><link rel="prefetch" href="/assets/js/43.40ae12a3.js"><link rel="prefetch" href="/assets/js/44.4a0dd48e.js"><link rel="prefetch" href="/assets/js/45.20d657cc.js"><link rel="prefetch" href="/assets/js/46.2d34fe10.js"><link rel="prefetch" href="/assets/js/47.3dcb2d38.js"><link rel="prefetch" href="/assets/js/48.1b0959df.js"><link rel="prefetch" href="/assets/js/49.6652f2b2.js"><link rel="prefetch" href="/assets/js/5.b28c76e0.js"><link rel="prefetch" href="/assets/js/50.30bdc802.js"><link rel="prefetch" href="/assets/js/51.ebe5930a.js"><link rel="prefetch" href="/assets/js/52.02f2caf4.js"><link rel="prefetch" href="/assets/js/53.55df3fc5.js"><link rel="prefetch" href="/assets/js/54.e2bff3b5.js"><link rel="prefetch" href="/assets/js/55.c859c458.js"><link rel="prefetch" href="/assets/js/56.d493a61b.js"><link rel="prefetch" href="/assets/js/57.9af46dbf.js"><link rel="prefetch" href="/assets/js/58.46d4e8aa.js"><link rel="prefetch" href="/assets/js/59.82e453fe.js"><link rel="prefetch" href="/assets/js/6.b43fc5c2.js"><link rel="prefetch" href="/assets/js/60.d9652552.js"><link rel="prefetch" href="/assets/js/61.bad1d82a.js"><link rel="prefetch" href="/assets/js/62.8c307334.js"><link rel="prefetch" href="/assets/js/63.7ebafb7e.js"><link rel="prefetch" href="/assets/js/64.bc588101.js"><link rel="prefetch" href="/assets/js/65.6f66d6a2.js"><link rel="prefetch" href="/assets/js/66.ee6f0d41.js"><link rel="prefetch" href="/assets/js/67.0002a9a5.js"><link rel="prefetch" href="/assets/js/68.4a86ea26.js"><link rel="prefetch" href="/assets/js/69.c9e36070.js"><link rel="prefetch" href="/assets/js/7.87b3f924.js"><link rel="prefetch" href="/assets/js/70.40af8c94.js"><link rel="prefetch" href="/assets/js/71.ee207bd6.js"><link rel="prefetch" href="/assets/js/72.c389068e.js"><link rel="prefetch" href="/assets/js/73.c1526d9c.js"><link rel="prefetch" href="/assets/js/74.cd1c9d32.js"><link rel="prefetch" href="/assets/js/75.144c1f5b.js"><link rel="prefetch" href="/assets/js/76.4c36bfbf.js"><link rel="prefetch" href="/assets/js/77.7db5b3f1.js"><link rel="prefetch" href="/assets/js/78.de99e748.js"><link rel="prefetch" href="/assets/js/79.1febcdca.js"><link rel="prefetch" href="/assets/js/8.ab13bda4.js"><link rel="prefetch" href="/assets/js/80.e802c8bb.js"><link rel="prefetch" href="/assets/js/81.960e4a52.js"><link rel="prefetch" href="/assets/js/82.9a35963d.js"><link rel="prefetch" href="/assets/js/83.005e1aad.js"><link rel="prefetch" href="/assets/js/84.d61f7f01.js"><link rel="prefetch" href="/assets/js/85.0906b75c.js"><link rel="prefetch" href="/assets/js/86.dff86ecd.js"><link rel="prefetch" href="/assets/js/87.00755e79.js"><link rel="prefetch" href="/assets/js/88.00604a67.js"><link rel="prefetch" href="/assets/js/89.376832c9.js"><link rel="prefetch" href="/assets/js/9.b83e9e02.js"><link rel="prefetch" href="/assets/js/90.9be39541.js"><link rel="prefetch" href="/assets/js/91.d5eb29c9.js"><link rel="prefetch" href="/assets/js/92.9f5fba68.js"><link rel="prefetch" href="/assets/js/93.670dcf5c.js"><link rel="prefetch" href="/assets/js/94.9d783387.js"><link rel="prefetch" href="/assets/js/95.0fd08cc1.js"><link rel="prefetch" href="/assets/js/96.ae0eb4f1.js"><link rel="prefetch" href="/assets/js/97.1d15ea38.js"><link rel="prefetch" href="/assets/js/98.1bc97ef6.js"><link rel="prefetch" href="/assets/js/99.d91a7a9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f0b7ee7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./favicon.jpg" alt="ゼロツー" class="logo"> <span class="site-name can-hide">ゼロツー</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link router-link-active">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link router-link-active">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>browser</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/browser/" aria-current="page" class="sidebar-link">首页</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/browser/browser.html" aria-current="page" class="active sidebar-link">基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#浏览器标准模式和怪异模式之间的区别是什么？（待更新）" class="sidebar-link">浏览器标准模式和怪异模式之间的区别是什么？（待更新）</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#如何实现浏览器内多个标签页的通信" class="sidebar-link">如何实现浏览器内多个标签页的通信</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#页面可见性（pagevisibility）有哪些用途" class="sidebar-link">页面可见性（pageVisibility）有哪些用途</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#输入url到页面显示发生了什么" class="sidebar-link">输入url到页面显示发生了什么⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#回流和重绘" class="sidebar-link">回流和重绘⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#浏览器缓存" class="sidebar-link">浏览器缓存⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#web-push原理" class="sidebar-link">web-push原理</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#sse" class="sidebar-link">SSE</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#单点登录" class="sidebar-link">单点登录⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#webdriver" class="sidebar-link">webdriver</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#服务端渲染" class="sidebar-link">服务端渲染</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#前端与服务端用什么通信" class="sidebar-link">前端与服务端用什么通信</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#正常的网页加载流程" class="sidebar-link">正常的网页加载流程</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#代码嵌入网页的方法" class="sidebar-link">代码嵌入网页的方法</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#uri-是什么" class="sidebar-link">URI 是什么</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#页面自适应的方式" class="sidebar-link">页面自适应的方式</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#如何处理页面异常" class="sidebar-link">如何处理页面异常</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#如何保证页面每次都获取最新资源" class="sidebar-link">如何保证页面每次都获取最新资源</a></li><li class="sidebar-sub-header"><a href="/frontend/browser/browser.html#兼容性问题" class="sidebar-link">兼容性问题</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器内核</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/browser/core.html" class="sidebar-link">内核</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="浏览器标准模式和怪异模式之间的区别是什么？（待更新）"><a href="#浏览器标准模式和怪异模式之间的区别是什么？（待更新）" class="header-anchor">#</a> 浏览器标准模式和怪异模式之间的区别是什么？（待更新）</h2> <ul><li><p>在严格模式中 ：width是内容宽度 ，在怪异模式中 ：width则是元素的实际宽度</p> <div class="language-markdown extra-class"><pre class="language-markdown"><code>元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width + margin-right;

内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width)
</code></pre></div></li> <li><p>可以设置行内元素的高宽</p> <p>在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。</p></li> <li><p>可设置百分比的高度</p> <p>在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p></li> <li><p>盒模型解释不同（对应box-sizing取值分别为content-box和border-box）</p></li> <li><p>quirk模式下设置图片的padding会失效</p></li> <li><p>quirk模式下Table中的字体属性不能继承上层的设置</p></li> <li><p>quirk模式下white-space:pre会失效</p></li></ul> <h2 id="如何实现浏览器内多个标签页的通信"><a href="#如何实现浏览器内多个标签页的通信" class="header-anchor">#</a> 如何实现浏览器内多个标签页的通信</h2> <p>实现浏览器内标签页的方法如下：</p> <h3 id="_1-cookie-setinterval方式"><a href="#_1-cookie-setinterval方式" class="header-anchor">#</a> 1.cookie + setInterval方式</h3> <p>存储到cookie中，另外的页面的轮询的方式获取cookie的值，转换成json格式，方便获取。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//json字符串需要双引号</span>
<span class="token keyword">var</span> cookies <span class="token operator">=</span> <span class="token string">'{&quot;'</span><span class="token operator">+</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/=/g</span><span class="token punctuation">,</span><span class="token string">'&quot;:&quot;'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/;\s+/g</span><span class="token punctuation">,</span><span class="token string">'&quot;, &quot;'</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'&quot;}'</span><span class="token punctuation">;</span>
cookies <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>cookies<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>总结：</p> <ul><li>cookie空间有限，浏览器在每一个域名下最多能设置30-50个cookie，容量最多为4k左右。</li> <li>每次HHTP请求才会把当前域的cookie发送到服务器上，包括只在本地才用到的而服务器不用的，浪费带宽。</li> <li>setInterval频率设置过大会影响浏览器的性能，过小会影响时效性。</li></ul> <h3 id="_2-localstorage方式"><a href="#_2-localstorage方式" class="header-anchor">#</a> 2.localStorage方式</h3> <p>localStorage比cookie好的原因，在于它在setItem存东西时会自动触发整个浏览器的storage事件，除了当前页面之外，所有打开的标签窗口都会受影响。</p> <p>总结：</p> <ul><li><p>缺点：</p> <ul><li>localStorage是h5的属性，高版本的浏览器才支持，而且不同浏览器localStorage大小了限制不统一。</li> <li>localStorage只能监听非己页面的数据变化。</li></ul></li> <li><p>优点：</p> <ul><li>解决了cookie容量小和时效性的问题。</li></ul></li></ul> <h3 id="_3-websocket方式"><a href="#_3-websocket方式" class="header-anchor">#</a> 3.WebSocket方式</h3> <div class="custom-block tip"><p class="custom-block-title">Websocket特点：</p> <ul><li>建设在 TCP 协定之上，服务器端的实现比较容易。</li> <li>与 HTTP 协定有着良好的兼容性。默认端口也是80和443，并且握手阶段采纳 HTTP 协定，因而握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li> <li>数据格式比拟轻量,性能开销小，通信高效。</li> <li>能够发送文本，也能够发送二进制数据。</li> <li>没有同源限度，客户端能够与任意服务器通信。</li> <li>协定标识符是ws (如果加密,则为wss)，服务器网址就是URL。</li></ul></div> <p>send方发送消息到WebSocketServer，WebSocketServer再实时把消息发给receive方。</p> <p>新建websocket连接后，发送方使用send事件，接收方使用onmessage事件</p> <p>WebSocketServer使用on事件，为每个client添加message事件，收到消息后，给其他的client推送消息（send）</p> <p>总结</p> <ul><li>缺点：
<ul><li>它需要服务端的支持才能完成任务。如果socket数据量比较大的话，会严重消耗服务器的资源。</li> <li>必须要在服务端项目中写服务端监听程序才能支持。</li></ul></li> <li>优点：
<ul><li>使用简单（客户端简单），功能灵活、强大，如果部署了WebSocket服务器，可以实现很多实时的功能</li></ul></li></ul> <p>简单实例（旧）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// server.js文件</span>
<span class="token comment">//获得WebSocketServer类型</span>
<span class="token keyword">var</span> WebSocketServer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Server<span class="token punctuation">;</span>
<span class="token comment">//创建WebSocketServer对象实例，监听指定端口</span>
<span class="token keyword">var</span> wss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocketServer</span><span class="token punctuation">(</span><span class="token punctuation">{</span> port<span class="token operator">:</span> <span class="token number">8080</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//创建保存所有已连接到服务器的客户端对象的数组</span>
<span class="token keyword">var</span> clients<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">//为服务器添加connection事件监听，当有客户端连接到服务端时，立刻将客户端对象保存进数组中。</span>
wss<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">client</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;一个客户端连接到服务器&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果没有这个client对象，说明是第一次连接，就加入到clients中</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>clients<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token operator">===</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    clients<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;有&quot;</span><span class="token operator">+</span>clients<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token string">&quot;个客户端在线&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//为每个client对象绑定message事件，当某个客户端发来消息时，自动触发</span>
    client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;收到消息:&quot;</span><span class="token operator">+</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//遍历clients数组中每个其他客户端对象，并发送消息给其他客户端</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> c <span class="token keyword">of</span> clients<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">!=</span>client<span class="token punctuation">)</span><span class="token punctuation">{</span>
          c<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- send.html文件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token property">text-align</span><span class="token punctuation">:</span> right</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>send<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>发送<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token comment">//建立到服务端webSocket连接</span>
    <span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">&quot;ws://localhost:8080&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    send<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!==</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 将消息发到服务器</span>
        ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- receive.html文件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>收到消息：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>recMsg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token comment">//建立到服务端webSocket连接</span>
    <span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">&quot;ws://localhost:8080&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当连接被打开时，注册接收消息的处理函数</span>
    ws<span class="token punctuation">.</span><span class="token function-variable function">onopen</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//当有消息发过来时，就将消息放到显示元素上</span>
      ws<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        recMsg<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span>event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="_4-sharedworker方式"><a href="#_4-sharedworker方式" class="header-anchor">#</a> 4.SharedWorker方式</h3> <p>SharedWorker原理和WebWorker几乎是一样的，只不过SharedWorker可以跨多个页面使用。</p> <p>SharedWorker在客户端有一个自己维护的对象worker.js，消息存储在worker.js中的data中。</p> <p>SharedWorker接收消息不是自动的，也要用定时器实时从worker.js中获取消息。</p> <div class="custom-block warning"><p class="custom-block-title">注意：</p> <p>如果要使 SharedWorker 连接到多个不同的页面，这些页面必须是同源的（相同的协议、host 以及端口）</p></div> <div class="custom-block tip"><p class="custom-block-title">webworker</p> <ul><li><p>webworker作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码，并且不会影响到浏览器用户界面。</p></li> <li><p>普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。</p></li></ul> <p>应用场景：比如页面中包含耗时较大的算法代码时，就会阻塞线程影响浏览器渲染等等。这时候就可把耗时代码，放到webworker(另一个线程)中执行。
注意，这种多线程能力不是JavaScript语言原生具有的，而是浏览器宿主环境提供的。</p></div> <p>简单实例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// worker.js文件</span>
<span class="token comment">//在所有SharedWorker共享的worker.js中，保存一个data变量，用于存储多个worker共享的数据</span>
<span class="token keyword">let</span> data<span class="token operator">=</span><span class="token string">&quot;连接成功&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//必须提供一个名为onconnect的事件处理函数</span>
<span class="token comment">//每当一个页面中new SharedWorker(&quot;worker.js&quot;)时，就会为新创建的worker绑定onconnect事件处理函数</span>
<span class="token function-variable function">onconnect</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//获得当前连接上来的客户端对象</span>
  <span class="token keyword">var</span> client <span class="token operator">=</span> e<span class="token punctuation">.</span>ports<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  client<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//当当前对象收到消息时</span>
  client<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果消息内容为空，说明该客户端想获取共享的数据data</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token operator">===</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">//就给当前客户端发送data数据</span>
      client<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//否则如果消息内容不为空，说明该客户端想要提供新的消息保存在共享的data中，供别人获取</span>
      data<span class="token operator">=</span>e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后两个脚本都通过 MessagePort 对象来访问worker，这个对象用SharedWorker.port 属性获得。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- send.html文件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>msg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>send<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>发送<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">var</span> worker<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token string">&quot;worker.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    worker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    send<span class="token punctuation">.</span><span class="token function-variable function">onclick</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!==</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        worker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- receive.html文件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>收到消息:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>recMsg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">var</span> worker<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token string">&quot;worker.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//3. 当worker.js中给当前客户端返回了data，会触发当前客户端的message事件。data的值，自动保存进事件对象e的data属性中</span>
    worker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      recMsg<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span>e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">//如果已经用 addEventListener 监听了 onmessage 事件，则可以使用 start() 方法手动启动端口：</span>
    worker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//1. 接收端反复向共享的worker.js对象中发送空消息，意为想获取data的值</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      worker<span class="token punctuation">.</span>port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">//2. 只要发送消息，就触发worker.js中的onmessage，onmessage判断是空消息内容，说明客户端想获得data。于是就用postMessage()方法，将data返回给当前客户端</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="页面可见性（pagevisibility）有哪些用途"><a href="#页面可见性（pagevisibility）有哪些用途" class="header-anchor">#</a> 页面可见性（pageVisibility）有哪些用途</h2> <ul><li>通过visibilityState的值检测页面当前是否可见，</li> <li>计算页面打开的时间</li> <li>页面切换到后台进程时，自动暂停音乐或视频的播放（有些浏览自带功能）</li></ul> <h2 id="输入url到页面显示发生了什么"><a href="#输入url到页面显示发生了什么" class="header-anchor">#</a> 输入url到页面显示发生了什么⭐️</h2> <ul><li>浏览器输入url，浏览器主进程接管</li> <li>浏览器进程校验之后,开启网络请求线程</li> <li>查看缓存（强缓存和协商缓存）</li> <li>DNS 域名解析
<ul><li>浏览器的缓存</li> <li>主机缓存</li> <li>路由缓存</li> <li>DNS 域名服务器迭代/递归查询</li></ul></li> <li>拿到 IP，建立 TCP 连接</li> <li>异步请求线程发起HTTP请求</li> <li>服务器收到请求后进行相应处理再返回数据</li> <li>拿到服务端返回的数据后，通知浏览器进程拿到资源了，和渲染进程建立管道</li> <li>DOM树
<ul><li>StyleSheet</li> <li>布局树</li> <li>图层树</li> <li>指令绘制</li> <li>栅格化</li> <li>合成，GPU进程可能会优化</li></ul></li> <li>页面显示</li></ul> <h3 id="渲染流程，精确到标签"><a href="#渲染流程，精确到标签" class="header-anchor">#</a> 渲染流程，精确到标签</h3> <p><img src="/img/1373095523-5a658fc12f1fd.png" alt="渲染流程"></p> <p>得到 render tree 后，开始渲染</p> <p>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</p> <blockquote><p>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</p></blockquote> <p>可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</p> <blockquote><p>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</p></blockquote> <p>PS：渲染树只包含可见的节点</p> <h3 id="渲染图层"><a href="#渲染图层" class="header-anchor">#</a> 渲染图层</h3> <p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p> <p>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘</p> <p>可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果很好的原因。</p> <h3 id="浏览器绘制-dom"><a href="#浏览器绘制-dom" class="header-anchor">#</a> 浏览器绘制 DOM</h3> <ol><li>获取 DOM 并将其分割为多个层（layer）</li> <li>将每个层独立地绘制进位图（bitmap）中</li> <li>将层作为纹理（texture）上传至 GPU</li> <li>复合（composite）多个层来生成最终的屏幕图像</li></ol> <h4 id="开启硬件加速"><a href="#开启硬件加速" class="header-anchor">#</a> 开启硬件加速</h4> <p>将该元素变成一个复合图层，就是使用硬件加速技术</p> <ul><li>最常用的方式：translate3d、translateZ</li> <li>opacity属性、过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li> <li>will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），</li></ul> <h4 id="复合图层的作用？"><a href="#复合图层的作用？" class="header-anchor">#</a> 复合图层的作用？</h4> <p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p> <p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡</p> <h4 id="absolute和硬件加速的区别"><a href="#absolute和硬件加速的区别" class="header-anchor">#</a> absolute和硬件加速的区别</h4> <p>absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。</p> <blockquote><p>absolute中信息改变时不会改变普通文档流中render树</p></blockquote> <p>但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。
（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p> <p>而硬件加速直接就是在另一个复合层另起炉灶l，所以它的信息改变不会影响默认复合层</p> <blockquote><p>会影响属于自己的复合层</p></blockquote> <p>仅仅是引发最后的合成（输出视图）</p> <h3 id="dom树、render树、css加载时遇到js代码怎么办"><a href="#dom树、render树、css加载时遇到js代码怎么办" class="header-anchor">#</a> DOM树、render树、CSS加载时遇到JS代码怎么办</h3> <p>css是由单独的下载线程异步下载的。</p> <ul><li><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</p></li> <li><p>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p> <blockquote><p>因为加载css的时候，可能会修改DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流</p></blockquote> <blockquote><p>media query声明的CSS是不会阻塞渲染的(但是还没有验证过)</p></blockquote></li></ul> <p>JS执行会阻塞DOM树的解析和渲染</p> <p><strong>css加载不会阻塞JS的加载，但是会阻塞后面JS语句的执行</strong></p> <h3 id="css-加载顺序和解析顺序"><a href="#css-加载顺序和解析顺序" class="header-anchor">#</a> css 加载顺序和解析顺序</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span> <span class="token attr-value"><span class="token punctuation">=</span> <span class="token punctuation">&quot;</span>main1.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">rel</span> <span class="token attr-value"><span class="token punctuation">=</span> <span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span> <span class="token attr-value"><span class="token punctuation">=</span> <span class="token punctuation">&quot;</span>main2.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">rel</span> <span class="token attr-value"><span class="token punctuation">=</span> <span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>main1.css 和 main2.css 同时加载，优先加载完的优先进行解析，</p> <p>如果此时 main1.css 和 main2.css 有相同的选择器规则，main2.css 将会覆盖 main1.css 中的规则</p> <h3 id="如何避免js阻塞渲染"><a href="#如何避免js阻塞渲染" class="header-anchor">#</a> 如何避免JS阻塞渲染?</h3> <ul><li><p>defer 属性</p> <p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对script元素加入defer属性。</p> <p>它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p> <p>defer属性的运行流程如下。</p> <ol><li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有defer属性的script元素。</li> <li><strong>浏览器继续往下解析 HTML 网页，同时并行下载script元素加载的外部脚本。</strong></li> <li><strong>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</strong></li></ol> <p>有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。</p> <p>下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完&lt;/html&gt;标签）</p> <p><strong>保证执行顺序就是它们在页面上出现的顺序</strong>。</p> <p><strong>对于内置而不是加载外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。</strong></p> <p>另外，使用defer加载的外部脚本不应该使用document.write方法。</p></li> <li><p>async 属性</p> <p>解决“阻塞效应”的另一个方法是对script元素加入async属性。</p> <p>async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p> <p>解析过程：</p> <ol><li>浏览器开始解析 HTML 网页。</li> <li>解析过程中，发现带有async属性的script标签。</li> <li>浏览器继续往下解析 HTML 网页，同时并行下载script标签中的外部脚本。</li> <li><strong>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</strong></li> <li><strong>脚本执行完毕，浏览器恢复解析 HTML 网页。</strong></li></ol> <p>async属性可以保证脚本下载的同时，浏览器继续渲染。</p> <p><strong>一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。</strong></p> <p>使用async属性的脚本文件里面的代码，不应该使用document.write方法。</p></li></ul> <p>区别：</p> <ul><li>defer，脚本下载完成，浏览器继续解析 HTML 网页直至完成，再回过头执行已经下载完成的脚本，按页面顺序执行。</li> <li>async，脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本，先下载完先执行。</li></ul> <h3 id="img加载会影响渲染吗"><a href="#img加载会影响渲染吗" class="header-anchor">#</a> img加载会影响渲染吗⭐️</h3> <p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p> <h2 id="回流和重绘"><a href="#回流和重绘" class="header-anchor">#</a> 回流和重绘⭐️</h2> <p>渲染树转换为网页布局，称为“布局流”（flow）；</p> <p>布局显示到页面的这个过程，称为“绘制”（paint）。</p> <p>它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p> <p>回流和重绘并不一定一起发生，回流必然导致重绘，重绘不一定需要回流。</p> <blockquote><p>比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p></blockquote> <p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p> <p><strong>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列</strong>，但是当获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。</p> <h3 id="触发回流"><a href="#触发回流" class="header-anchor">#</a> 触发回流</h3> <ul><li>页面第一次渲染</li> <li>DOM树发生变化（添加DOM节点、添加内容）</li> <li>元素位置或大小变化</li> <li>浏览器窗口大小变化</li> <li>获取属性（这个影响不在于改变了页面，而是破坏了浏览器的批处理回流优化）</li></ul> <div class="custom-block tip"><p class="custom-block-title">获取属性触发回流</p> <ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li> <li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li> <li>clientTop、clientLeft、clientWidth、clientHeight</li> <li>getComputedStyle()</li> <li>getBoundingClientRect()</li> <li>scrollIntoView()</li></ul></div> <p>由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算</p> <h3 id="重绘的定义"><a href="#重绘的定义" class="header-anchor">#</a> 重绘的定义</h3> <p>由于节点的几何属性发生改变或由于样式发生改变但是都不会影响到布局的，称为重绘</p> <p>引起重绘：</p> <ul><li>color</li> <li>border-style</li> <li>visibility</li> <li>background、background-image、background-position、background-repeat、background-size</li> <li>text-decoration</li> <li>outline-color、outline-style、outline-width</li> <li>border-radius</li> <li>box-shadow</li></ul> <h3 id="回流的定义"><a href="#回流的定义" class="header-anchor">#</a> 回流的定义</h3> <p>布局或者几何属性需要改变就称为回流</p> <p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流</p> <p>一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。</p> <h3 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="header-anchor">#</a> 如何减少回流和重绘⭐️</h3> <p>从 CSS 和 JS 的角度出发</p> <h4 id="css"><a href="#css" class="header-anchor">#</a> CSS</h4> <ul><li>使用 transform 替代 top</li> <li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局</li> <li>避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。</li> <li>尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。</li> <li>将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame</li> <li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。</li> <li>CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，虽然还是提升了这些动画的性能。</li> <li>避免使用CSS表达式，可能会引发回流。</li></ul> <h4 id="js"><a href="#js" class="header-anchor">#</a> JS</h4> <ul><li><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p> <p>使用cssText</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+=</span> <span class="token string">'border-left: 1px; border-right: 2px; padding: 5px;'</span><span class="token punctuation">;</span>
</code></pre></div><p>修改CSS的class</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
el<span class="token punctuation">.</span>className <span class="token operator">+=</span> <span class="token string">' active'</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>避免频繁操作DOM</p> <p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p> <ol><li>使元素脱离文档流</li> <li>对其进行多次修改</li> <li>将元素添加回文档中。</li></ol> <p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。</p> <p>有三种方式可以让DOM脱离文档流：</p> <ul><li>隐藏元素，应用修改，重新显示</li> <li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li> <li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li></ul> <blockquote><p>其实现代浏览器有做相关的优化</p></blockquote></li> <li><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p></li> <li><p>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p></li></ul> <h2 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存⭐️</h2> <p><img src="/img/3174701-8e74b69ad9376710.webp.jpg" alt="浏览器缓存"></p> <h3 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h3> <p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p> <p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p> <p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p> <h3 id="memory-cache"><a href="#memory-cache" class="header-anchor">#</a> Memory Cache</h3> <p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p> <h3 id="disk-cache"><a href="#disk-cache" class="header-anchor">#</a> Disk Cache</h3> <p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p> <p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache</p> <h3 id="push-cache"><a href="#push-cache" class="header-anchor">#</a> Push Cache</h3> <p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</p> <p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p> <h3 id="浏览器中什么时候缓存到磁盘"><a href="#浏览器中什么时候缓存到磁盘" class="header-anchor">#</a> 浏览器中什么时候缓存到磁盘</h3> <ul><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li> <li>经常访问的内容会在内存中</li></ul> <h2 id="web-push原理"><a href="#web-push原理" class="header-anchor">#</a> web-push原理</h2> <p>推送通知一般指由浏览器实现的消息推送，换个说法，就是用户在打开浏览器时，不需要进入特定的网站，就能收到该网站推送而来的消息</p> <ol><li>客户端完成请求订阅一个用户的逻辑</li> <li>服务端调用遵从web push协议的接口，传送消息推送（push message）到推送服务器（该服务器由浏览器决定，开发者所能做的只有控制发送的数据）</li> <li>推送服务器将该消息推送至对应的浏览器，用户收到该推送</li></ol> <p>服务端推送方法</p> <ul><li>WebSocket</li> <li>Https2.0</li> <li>SSE</li> <li>长轮询</li></ul> <h2 id="sse"><a href="#sse" class="header-anchor">#</a> SSE</h2> <p>服务器向客户端声明，接下来要发送的是流信息（streaming）。</p> <p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流</p> <p>SSE(Server-sent events) 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议</p> <p>SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。</p> <p>总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。</p> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li> <li>SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</li> <li>SSE 默认支持断线重连，WebSocket 需要自己实现。</li> <li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li> <li>SSE 支持自定义发送的消息类型。</li></ul> <h3 id="eventsource-对象"><a href="#eventsource-对象" class="header-anchor">#</a> EventSource 对象</h3> <p>SSE 的客户端 API 部署在EventSource对象上</p> <p>使用 SSE 时，浏览器首先生成一个EventSource实例，向服务器发起连接。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>
</code></pre></div><p>EventSource实例的readyState属性，表明连接的当前状态。该属性只读，可以取以下值。</p> <ul><li><p>0：</p> <p>相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。</p></li> <li><p>1：</p> <p>相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。</p></li> <li><p>2：</p> <p>相当于常量EventSource.CLOSED，表示连接已断，且不会重连。</p></li></ul> <h3 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h3> <p>连接一旦建立，就会触发open事件，可以在onopen属性定义回调函数。</p> <div class="language-js extra-class"><pre class="language-js"><code>source<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 另一种写法</span>
source<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><p>客户端收到服务器发来的数据，就会触发message事件，可以在onmessage属性的回调函数。</p> <div class="language-js extra-class"><pre class="language-js"><code>source<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data
   <span class="token comment">// handle message</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// 另一种写法</span>
source<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data
   <span class="token comment">// handle message</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="服务端方面"><a href="#服务端方面" class="header-anchor">#</a> 服务端方面</h3> <p>服务器向浏览器发送的 SSE 数据，必须是 UTF-8 编码的文本，具有如下的 HTTP 头信息。</p> <ul><li>Content-Type: text/event-stream</li> <li>Cache-Control: no-cache</li> <li>Connection: keep-alive</li></ul> <p>每一次发送的信息，由若干个message组成，每个message之间用\n\n分隔。每个message内部由若干行组成，每一行都是如下格式。</p> <p>上面的field可以取四个值。</p> <ul><li>data</li> <li>event</li> <li>id</li> <li>retry</li></ul> <p>此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。</p> <ul><li><p>data字段</p> <p>数据内容用data字段表示。</p> <div class="language-js extra-class"><pre class="language-js"><code>data<span class="token operator">:</span>  message\n\n
</code></pre></div><p>如果数据很长，可以分成多行，最后一行用\n\n结尾，前面行都用\n结尾。</p></li> <li><p>id字段</p> <p>数据标识符用id字段表示，相当于每一条数据的编号。</p> <div class="language-js extra-class"><pre class="language-js"><code>id<span class="token operator">:</span> msg1\n
data<span class="token operator">:</span> message\n\n
</code></pre></div><p>浏览器用lastEventId属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的Last-Event-ID头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p></li> <li><p>event字段</p> <p>event字段表示自定义的事件类型，默认是message事件。浏览器可以用addEventListener()监听该事件。</p> <p>未取名表示默认类型</p></li> <li><p>retry 字段</p> <p>服务器可以用retry字段，指定浏览器重新发起连接的时间间隔。</p> <div class="language-js extra-class"><pre class="language-js"><code>retry<span class="token operator">:</span> <span class="token number">10000</span>\n
</code></pre></div><p>两种情况会导致浏览器重新发起连接：一种是时间间隔到期，二是由于网络错误等原因，导致连接出错。</p></li></ul> <h3 id="不用websocket，不用http2，不用-woker，那么如何实现服务端推送消息"><a href="#不用websocket，不用http2，不用-woker，那么如何实现服务端推送消息" class="header-anchor">#</a> 不用websocket，不用http2，不用 woker，那么如何实现服务端推送消息</h3> <p>SSE</p> <h2 id="单点登录"><a href="#单点登录" class="header-anchor">#</a> 单点登录⭐️</h2> <p>单点登录，Single Sign On（简称SSO）。</p> <p>顾名思义，它把两个及以上个产品中的用户登录逻辑抽离出来，达到只输入一次用户名密码，就能同时登录多个产品的效果</p> <p>SSO 仅仅是一种架构，一种设计，而 CAS 则是实现 SSO 的一种手段。两者是抽象与具体的关系。</p> <p>CAS （Central Authentication Service）中心授权服务，本身是一个开源协议，分为 1.0 版本和 2.0 版本。</p> <blockquote><p>1.0 称为基础模式，2.0称为代理模式，适用于存在非 Web 应用之间的单点登录</p></blockquote> <p><img src="/img/0e2c2be35de3cf42744bae6f1238d6e7.webp.jpg" alt="单点登录"></p> <h2 id="webdriver"><a href="#webdriver" class="header-anchor">#</a> webdriver</h2> <p>WebDriver 是远程控制接口，可以对用户代理进行控制. 它提供了一个平台和语言中性线协议，作为进程外程序远程指导web浏览器行为的方法</p> <p>能够编写可在不同平台上的许多浏览器中交替运行的指令集，对于向用户提供一致的体验至关重要。随着web平台上新一轮的开发浪潮、设备的多样化以及对技术之间真正的互操作性的需求，WebDriver为跨浏览器测试提供了工具。</p> <p>提供了一组接口，用于发现和操作web文档中的DOM元素，并控制用户代理的行为。它的主要目的是允许web作者编写从单独的控制过程中自动执行用户代理的测试，但也可以这样使用，允许浏览器内脚本控制一个（可能是单独的）浏览器。</p> <h2 id="服务端渲染"><a href="#服务端渲染" class="header-anchor">#</a> 服务端渲染</h2> <p>SSR是Server Side Render简称；页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html就可以了。</p> <p>SSR不仅可以减少白屏时间还可以大幅减少首屏加载时间。（客户端只负责解析HTML）</p> <blockquote><p>同时有利于SEO（搜索引擎优化）</p></blockquote> <p><img src="/img/162f56fdae9b01f6.webp.jpg" alt="服务端渲染"></p> <h3 id="服务端渲染（ssr）-vs-预渲染（prerendering）"><a href="#服务端渲染（ssr）-vs-预渲染（prerendering）" class="header-anchor">#</a> 服务端渲染（SSR） VS 预渲染（Prerendering）</h3> <ul><li><p>相同点：</p> <p>都是解决单页面SEO的问题，更快的内容到达时间。</p></li> <li><p>不同点：</p> <ul><li><p>实现原理和方案不同：</p> <p>SSR的实现依赖于node.js服务器做服务端构建静态资源，</p> <p>prerender的实现依赖于webpack集成为prerender-spa-plugin，将静态资源提取出来展示给前端。</p></li> <li><p>服务端渲染可以做到服务端的实时编译，prerender只是在构建时简单的生成针对特定路由的静态HTML文件，来达到SEO的效果，prerender的优点是配置更简单，并可以把前端作为一个完全静态的站点。</p></li></ul></li></ul> <h2 id="前端与服务端用什么通信"><a href="#前端与服务端用什么通信" class="header-anchor">#</a> 前端与服务端用什么通信</h2> <ul><li>WebSocket</li> <li>Server-sent Events</li></ul> <h3 id="两个客户端怎么通讯"><a href="#两个客户端怎么通讯" class="header-anchor">#</a> 两个客户端怎么通讯</h3> <p>postMessage</p> <h2 id="正常的网页加载流程"><a href="#正常的网页加载流程" class="header-anchor">#</a> 正常的网页加载流程</h2> <ol><li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li> <li>解析过程中，浏览器发现script元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li> <li>如果script元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li> <li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li></ol> <p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，</p> <p>造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p> <h2 id="代码嵌入网页的方法"><a href="#代码嵌入网页的方法" class="header-anchor">#</a> 代码嵌入网页的方法</h2> <h3 id="script-元素嵌入代码"><a href="#script-元素嵌入代码" class="header-anchor">#</a> script 元素嵌入代码</h3> <p>script元素内部可以直接写入 JavaScript 代码。</p> <p>如果type属性的值，浏览器不认识，那么它不会执行其中的代码。</p> <h3 id="script-元素加载外部脚本"><a href="#script-元素加载外部脚本" class="header-anchor">#</a> script 元素加载外部脚本</h3> <p>script标签也可以指定加载外部的脚本文件。</p> <p>所加载的脚本必须是纯的 JavaScript 代码，不能有HTML代码和<script></script></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/browser/" class="prev router-link-active">
        首页
      </a></span> <span class="next"><a href="/frontend/browser/core.html">
        内核
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.484f4375.js" defer></script><script src="/assets/js/2.ebbe98b4.js" defer></script><script src="/assets/js/23.ecbb4b5d.js" defer></script>
  </body>
</html>
