<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webpack 优化 | ゼロツー</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="zerotwo">
    <link rel="preload" href="/assets/css/0.styles.f0b7ee7d.css" as="style"><link rel="preload" href="/assets/js/app.484f4375.js" as="script"><link rel="preload" href="/assets/js/2.ebbe98b4.js" as="script"><link rel="preload" href="/assets/js/119.213aaa9b.js" as="script"><link rel="prefetch" href="/assets/js/10.91de1805.js"><link rel="prefetch" href="/assets/js/100.1772503e.js"><link rel="prefetch" href="/assets/js/101.b569a1af.js"><link rel="prefetch" href="/assets/js/102.65dffa11.js"><link rel="prefetch" href="/assets/js/103.d7a8cd9e.js"><link rel="prefetch" href="/assets/js/104.0a0e3708.js"><link rel="prefetch" href="/assets/js/105.15bc167a.js"><link rel="prefetch" href="/assets/js/106.8487cf9a.js"><link rel="prefetch" href="/assets/js/107.2310b94b.js"><link rel="prefetch" href="/assets/js/108.781b7ebe.js"><link rel="prefetch" href="/assets/js/109.6225704a.js"><link rel="prefetch" href="/assets/js/11.9c44c6b2.js"><link rel="prefetch" href="/assets/js/110.3c39cb3c.js"><link rel="prefetch" href="/assets/js/111.22bede53.js"><link rel="prefetch" href="/assets/js/112.acb6b722.js"><link rel="prefetch" href="/assets/js/113.c2b6115e.js"><link rel="prefetch" href="/assets/js/114.cbeddf77.js"><link rel="prefetch" href="/assets/js/115.adf2d1b9.js"><link rel="prefetch" href="/assets/js/116.3f23eb5b.js"><link rel="prefetch" href="/assets/js/117.00cb8ac3.js"><link rel="prefetch" href="/assets/js/118.e88e1cfb.js"><link rel="prefetch" href="/assets/js/12.878aa51b.js"><link rel="prefetch" href="/assets/js/120.fc12eb0e.js"><link rel="prefetch" href="/assets/js/121.67bafb52.js"><link rel="prefetch" href="/assets/js/122.cca49856.js"><link rel="prefetch" href="/assets/js/123.0e27eb9e.js"><link rel="prefetch" href="/assets/js/124.53383547.js"><link rel="prefetch" href="/assets/js/125.e103d7f1.js"><link rel="prefetch" href="/assets/js/126.adb34a41.js"><link rel="prefetch" href="/assets/js/127.f352dcec.js"><link rel="prefetch" href="/assets/js/128.9aa22460.js"><link rel="prefetch" href="/assets/js/129.02dabe8a.js"><link rel="prefetch" href="/assets/js/13.b4c5b1dd.js"><link rel="prefetch" href="/assets/js/130.7d88cb43.js"><link rel="prefetch" href="/assets/js/14.dce5d003.js"><link rel="prefetch" href="/assets/js/15.ec0f3b1f.js"><link rel="prefetch" href="/assets/js/16.a9597b38.js"><link rel="prefetch" href="/assets/js/17.c8f44f51.js"><link rel="prefetch" href="/assets/js/18.67e67934.js"><link rel="prefetch" href="/assets/js/19.2b8ea36f.js"><link rel="prefetch" href="/assets/js/20.ee5ab76e.js"><link rel="prefetch" href="/assets/js/21.1582f8ed.js"><link rel="prefetch" href="/assets/js/22.130fb5fa.js"><link rel="prefetch" href="/assets/js/23.ecbb4b5d.js"><link rel="prefetch" href="/assets/js/24.0c8b3ecd.js"><link rel="prefetch" href="/assets/js/25.4aae22ea.js"><link rel="prefetch" href="/assets/js/26.4816aa3d.js"><link rel="prefetch" href="/assets/js/27.2e6f0659.js"><link rel="prefetch" href="/assets/js/28.7e0fef24.js"><link rel="prefetch" href="/assets/js/29.dad88d85.js"><link rel="prefetch" href="/assets/js/3.5e8d6a69.js"><link rel="prefetch" href="/assets/js/30.1ecf79ca.js"><link rel="prefetch" href="/assets/js/31.0a97fafc.js"><link rel="prefetch" href="/assets/js/32.8e6151d1.js"><link rel="prefetch" href="/assets/js/33.b5ff95d1.js"><link rel="prefetch" href="/assets/js/34.0d03faf5.js"><link rel="prefetch" href="/assets/js/35.6d4b4665.js"><link rel="prefetch" href="/assets/js/36.b42cbedf.js"><link rel="prefetch" href="/assets/js/37.4de10dce.js"><link rel="prefetch" href="/assets/js/38.9031eb30.js"><link rel="prefetch" href="/assets/js/39.daee868f.js"><link rel="prefetch" href="/assets/js/4.ceb8a314.js"><link rel="prefetch" href="/assets/js/40.df374a26.js"><link rel="prefetch" href="/assets/js/41.563436c6.js"><link rel="prefetch" href="/assets/js/42.b9200ca4.js"><link rel="prefetch" href="/assets/js/43.40ae12a3.js"><link rel="prefetch" href="/assets/js/44.4a0dd48e.js"><link rel="prefetch" href="/assets/js/45.20d657cc.js"><link rel="prefetch" href="/assets/js/46.2d34fe10.js"><link rel="prefetch" href="/assets/js/47.3dcb2d38.js"><link rel="prefetch" href="/assets/js/48.1b0959df.js"><link rel="prefetch" href="/assets/js/49.6652f2b2.js"><link rel="prefetch" href="/assets/js/5.b28c76e0.js"><link rel="prefetch" href="/assets/js/50.30bdc802.js"><link rel="prefetch" href="/assets/js/51.ebe5930a.js"><link rel="prefetch" href="/assets/js/52.02f2caf4.js"><link rel="prefetch" href="/assets/js/53.55df3fc5.js"><link rel="prefetch" href="/assets/js/54.e2bff3b5.js"><link rel="prefetch" href="/assets/js/55.c859c458.js"><link rel="prefetch" href="/assets/js/56.d493a61b.js"><link rel="prefetch" href="/assets/js/57.9af46dbf.js"><link rel="prefetch" href="/assets/js/58.46d4e8aa.js"><link rel="prefetch" href="/assets/js/59.82e453fe.js"><link rel="prefetch" href="/assets/js/6.b43fc5c2.js"><link rel="prefetch" href="/assets/js/60.d9652552.js"><link rel="prefetch" href="/assets/js/61.bad1d82a.js"><link rel="prefetch" href="/assets/js/62.8c307334.js"><link rel="prefetch" href="/assets/js/63.7ebafb7e.js"><link rel="prefetch" href="/assets/js/64.bc588101.js"><link rel="prefetch" href="/assets/js/65.6f66d6a2.js"><link rel="prefetch" href="/assets/js/66.ee6f0d41.js"><link rel="prefetch" href="/assets/js/67.0002a9a5.js"><link rel="prefetch" href="/assets/js/68.4a86ea26.js"><link rel="prefetch" href="/assets/js/69.c9e36070.js"><link rel="prefetch" href="/assets/js/7.87b3f924.js"><link rel="prefetch" href="/assets/js/70.40af8c94.js"><link rel="prefetch" href="/assets/js/71.ee207bd6.js"><link rel="prefetch" href="/assets/js/72.c389068e.js"><link rel="prefetch" href="/assets/js/73.c1526d9c.js"><link rel="prefetch" href="/assets/js/74.cd1c9d32.js"><link rel="prefetch" href="/assets/js/75.144c1f5b.js"><link rel="prefetch" href="/assets/js/76.4c36bfbf.js"><link rel="prefetch" href="/assets/js/77.7db5b3f1.js"><link rel="prefetch" href="/assets/js/78.de99e748.js"><link rel="prefetch" href="/assets/js/79.1febcdca.js"><link rel="prefetch" href="/assets/js/8.ab13bda4.js"><link rel="prefetch" href="/assets/js/80.e802c8bb.js"><link rel="prefetch" href="/assets/js/81.960e4a52.js"><link rel="prefetch" href="/assets/js/82.9a35963d.js"><link rel="prefetch" href="/assets/js/83.005e1aad.js"><link rel="prefetch" href="/assets/js/84.d61f7f01.js"><link rel="prefetch" href="/assets/js/85.0906b75c.js"><link rel="prefetch" href="/assets/js/86.dff86ecd.js"><link rel="prefetch" href="/assets/js/87.00755e79.js"><link rel="prefetch" href="/assets/js/88.00604a67.js"><link rel="prefetch" href="/assets/js/89.376832c9.js"><link rel="prefetch" href="/assets/js/9.b83e9e02.js"><link rel="prefetch" href="/assets/js/90.9be39541.js"><link rel="prefetch" href="/assets/js/91.d5eb29c9.js"><link rel="prefetch" href="/assets/js/92.9f5fba68.js"><link rel="prefetch" href="/assets/js/93.670dcf5c.js"><link rel="prefetch" href="/assets/js/94.9d783387.js"><link rel="prefetch" href="/assets/js/95.0fd08cc1.js"><link rel="prefetch" href="/assets/js/96.ae0eb4f1.js"><link rel="prefetch" href="/assets/js/97.1d15ea38.js"><link rel="prefetch" href="/assets/js/98.1bc97ef6.js"><link rel="prefetch" href="/assets/js/99.d91a7a9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f0b7ee7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./favicon.jpg" alt="ゼロツー" class="logo"> <span class="site-name can-hide">ゼロツー</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link router-link-active">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link router-link-active">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/webpack/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/frontend/webpack/optimize.html" aria-current="page" class="active sidebar-link">Webpack 优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#happypack" class="sidebar-link">happypack</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#热更新" class="sidebar-link">热更新⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#devserver可以自动刷新页面的原理是什么" class="sidebar-link">DevServer可以自动刷新页面的原理是什么⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#为什么生产模式生成的代码会被压缩？" class="sidebar-link">为什么生产模式生成的代码会被压缩？</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#uglifyjs" class="sidebar-link">UglifyJS⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#压缩css" class="sidebar-link">压缩CSS</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#paralleluglifyplugin" class="sidebar-link">ParallelUglifyPlugin</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#提取公共代码" class="sidebar-link">提取公共代码⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#tree-shaking" class="sidebar-link">Tree Shaking</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#webpack-怎么区分线上环境测试环境生产环境，并能通过-js-变量访问到？" class="sidebar-link">webpack 怎么区分线上环境测试环境生产环境，并能通过 JS 变量访问到？</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#用-webpack-实现-cdn-的接入" class="sidebar-link">用 Webpack 实现 CDN 的接入⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#按需加载" class="sidebar-link">按需加载⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/webpack/optimize.html#输出分析" class="sidebar-link">输出分析</a></li></ul></li><li><a href="/frontend/webpack/webpack.html" class="sidebar-link">基础</a></li><li><a href="/frontend/webpack/whole.html" class="sidebar-link">整体配置</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="happypack"><a href="#happypack" class="header-anchor">#</a> happypack</h2> <p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。</p> <p>HappyPack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。</p> <p>接入 HappyPack 的相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> HappyPack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'happypack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
        <span class="token comment">// 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'happypack/loader?id=babel'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment">// 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</span>
        exclude<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'node_modules'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</span>
        test<span class="token operator">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'happypack/loader?id=css'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span>
      id<span class="token operator">:</span> <span class="token string">'babel'</span><span class="token punctuation">,</span>
      <span class="token comment">// 如何处理 .js 文件，用法和 Loader 配置中一样</span>
      loaders<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader?cacheDirectory'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// ... 其它配置项</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      id<span class="token operator">:</span> <span class="token string">'css'</span><span class="token punctuation">,</span>
      <span class="token comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span>
      loaders<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[name].css</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>PS: 好像已经停止更新了</p> <h3 id="其他参数"><a href="#其他参数" class="header-anchor">#</a> 其他参数</h3> <p>在实例化 HappyPack 插件的时候，除了可以传入 id 和 loaders 两个参数外，HappyPack 还支持如下参数：</p> <ul><li>threads 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。</li> <li>verbose 是否允许 HappyPack 输出日志，默认是 true。</li> <li>threadPool 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多，相关代码如下：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> HappyPack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'happypack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 构造出共享进程池，进程池中包含5个子进程</span>
<span class="token keyword">const</span> happyThreadPool <span class="token operator">=</span> HappyPack<span class="token punctuation">.</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">{</span> size<span class="token operator">:</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</span>
      id<span class="token operator">:</span> <span class="token string">'babel'</span><span class="token punctuation">,</span>
      <span class="token comment">// 如何处理 .js 文件，用法和 Loader 配置中一样</span>
      loaders<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader?cacheDirectory'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// 使用共享进程池中的子进程去处理任务</span>
      threadPool<span class="token operator">:</span> happyThreadPool<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      id<span class="token operator">:</span> <span class="token string">'css'</span><span class="token punctuation">,</span>
      <span class="token comment">// 如何处理 .css 文件，用法和 Loader 配置中一样</span>
      loaders<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token comment">// 使用共享进程池中的子进程去处理任务</span>
      threadPool<span class="token operator">:</span> happyThreadPool<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[name].css</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="热更新"><a href="#热更新" class="header-anchor">#</a> 热更新⭐️</h2> <p>原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。</p> <p>模块热替换的原理和自动刷新原理类似，都需要往要开发的网页中注入一个代理客户端用于连接 DevServer 和网页，不同在于模块热替换独特的模块替换机制。</p> <p>DevServer 默认不会开启模块热替换模式，要开启该模式，只需在启动时带上参数 --hot，完整命令是 <code>webpack-dev-server --hot</code>。</p> <p>除了通过在启动时带上 --hot 参数，还可以通过接入 Plugin 实现，相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> HotModuleReplacementPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack/lib/HotModuleReplacementPlugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token comment">// 为每个入口都注入代理客户端</span>
    main<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'webpack-dev-server/client?http://localhost:8080/'</span><span class="token punctuation">,</span> <span class="token string">'webpack/hot/dev-server'</span><span class="token punctuation">,</span><span class="token string">'./src/main.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 该插件的作用就是实现模块热替换，实际上当启动时带上 `--hot` 参数，会注入该插件，生成 .hot-update.json 文件。</span>
    <span class="token keyword">new</span> <span class="token class-name">HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  devServer<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token comment">// 告诉 DevServer 要开启模块热替换模式</span>
    hot<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>不要把模块热替换技术用于线上环境，它是专门为提升开发效率生的。</strong></p> <p><img src="/img/28FRQimjwzfPAJnjuwHaXYHTyO.png" alt="热更新"></p> <h3 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h3> <ul><li>实时预览反应更快，等待时间更短。</li> <li>不刷新浏览器能保留当前网页的运行状态，例如在使用 Redux 来管理数据的应用中搭配模块热替换能做到代码更新时 Redux 中的数据还保持不变。</li></ul> <h2 id="devserver可以自动刷新页面的原理是什么"><a href="#devserver可以自动刷新页面的原理是什么" class="header-anchor">#</a> DevServer可以自动刷新页面的原理是什么⭐️</h2> <ol><li>文件监听</li> <li>自动刷新浏览器</li></ol> <h3 id="文件监听"><a href="#文件监听" class="header-anchor">#</a> 文件监听</h3> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>export <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 只有在开启监听模式时，watchOptions 才有意义</span>
  <span class="token comment">// 默认为 false，也就是不开启</span>
  watch<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token comment">// 监听模式运行时的参数</span>
  <span class="token comment">// 在开启监听模式时，才有意义</span>
  watchOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不监听的文件或文件夹，支持正则匹配</span>
    <span class="token comment">// 默认为空</span>
    ignored<span class="token operator">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>
    <span class="token comment">// 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高</span>
    <span class="token comment">// 默认为 300ms</span>
    aggregateTimeout<span class="token operator">:</span> <span class="token number">300</span><span class="token punctuation">,</span>
    <span class="token comment">// 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的</span>
    <span class="token comment">// 默认每秒问 1000 次</span>
    poll<span class="token operator">:</span> <span class="token number">1000</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要让 Webpack 开启监听模式，有两种方式：</p> <ul><li>在配置文件 webpack.config.js 中设置 watch: true。</li> <li>在执行启动 Webpack 命令时，带上 --watch 参数，完整命令是 webpack --watch。</li></ul> <h4 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h4> <p>在 Webpack 中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化。 配置项中的 <code>watchOptions.poll</code> 就是用于控制定时检查的周期，具体含义是每秒检查多少次。</p> <p>当发现某个文件发生了变化时，并不会立刻告诉监听者，而是先缓存起来，收集一段时间的变化后，再一次性告诉监听者。 配置项中的 <code>watchOptions.aggregateTimeout</code>就是用于配置这个等待时间。 这样做的目的是因为我们在编辑代码的过程中可能会高频的输入文字导致文件变化的事件高频的发生，如果每次都重新执行构建就会让构建卡死。</p> <p>对于多个文件来说，原理相似，只不过会对列表中的每一个文件都定时的执行检查。 但是这个需要监听的文件列表是怎么确定的呢？ 默认情况下 Webpack 会从配置的 Entry 文件出发，递归解析出 Entry 文件所依赖的文件，把这些依赖的文件都加入到监听列表中去。 可见 Webpack 这一点还是做的很智能的，不是粗暴的直接监听项目目录下的所有文件。</p> <p>由于保存文件的路径和最后编辑时间需要占用内存，定时检查周期检查需要占用 CPU 以及文件 I/O，所以最好减少需要监听的文件数量和降低检查频率。</p> <p>除了忽略掉部分文件的优化外，还有如下两种方法：</p> <ul><li><code>watchOptions.aggregateTimeout</code> 值越大性能越好，因为这能降低重新构建的频率。</li> <li><code>watchOptions.poll</code> 值越小越好，因为这能降低检查的频率。</li></ul> <p>但两种优化方法的后果是会让你感觉到监听模式的反应和灵敏度降低了。</p> <p>PS:忽略掉 node_modules 下的文件，不监听它们</p> <h3 id="自动刷新浏览器"><a href="#自动刷新浏览器" class="header-anchor">#</a> 自动刷新浏览器</h3> <p>监听到文件更新后的下一步是去刷新浏览器，webpack 模块负责监听文件，webpack-dev-server 模块则负责刷新浏览器。 在使用 webpack-dev-server 模块去启动 webpack 模块时，webpack 模块的监听模式默认会被开启。 webpack 模块会在文件发生变化时告诉 webpack-dev-server 模块。</p> <h4 id="原理-2"><a href="#原理-2" class="header-anchor">#</a> 原理</h4> <p>控制浏览器刷新有三种方法：</p> <ul><li><p>借助浏览器扩展去通过浏览器提供的接口刷新，WebStorm IDE 的 LiveEdit 功能就是这样实现的。</p></li> <li><p>往要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面。</p> <p>网页和 DevServer 之间通过 WebSocket 协议通信， 以方便 DevServer 主动向客户端发送命令。 DevServer 在收到来自 Webpack 的文件变化通知时通过注入的客户端控制网页刷新。</p> <p>如果尝试修改 index.html 文件并保存，你这并不会触发以上机制，导致这个问题的原因是 Webpack 在启动时会以配置里的 entry 为入口去递归解析出 entry 所依赖的文件，只有 entry 本身和依赖的文件才会被 Webpack 添加到监听列表里。 而 index.html 文件是脱离了 JavaScript 模块化系统的，所以 Webpack 不知道它的存在。</p></li> <li><p>把要开发的网页装进一个 iframe 中，通过刷新 iframe 去看到最新效果。</p></li></ul> <p>DevServer 支持第2、3种方法，第2种是 DevServer 默认采用的刷新方法。</p> <p><code>devServer.inline</code> 配置项，就是用来控制是否往 Chunk 中注入代理客户端的，默认会注入。</p> <p>事实上，在开启 inline 时，DevServer 会为每个输出的 Chunk 中注入代理客户端的代码，当你的项目需要输出的 Chunk 有很多个时，这会导致你的构建缓慢。 其实要完成自动刷新，一个页面只需要一个代理客户端就行了，DevServer 之所以粗暴的为每个 Chunk 都注入，是因为它不知道某个网页依赖哪几个 Chunk，索性就全部都注入一个代理客户端。 网页只要依赖了其中任何一个 Chunk，代理客户端就被注入到网页中去。</p> <p>这里优化的思路是关闭还不够优雅的 inline 模式，只注入一个代理客户端。 为了关闭 inline 模式，在启动 DevServer 时，可通过执行命令 <code>webpack-dev-server --inline false</code>（也可以在配置文件中设置）</p> <p>如果不想通过 iframe 的方式去访问，但同时又想让网页保持自动刷新功能，就需要手动往网页中注入代理客户端脚本，往 index.html 中插入以下标签：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!--注入 DevServer 提供的代理客户端脚本，这个服务是 DevServer 内置的--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://localhost:8080/webpack-dev-server.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="为什么生产模式生成的代码会被压缩？"><a href="#为什么生产模式生成的代码会被压缩？" class="header-anchor">#</a> 为什么生产模式生成的代码会被压缩？</h2> <p>浏览器从服务器访问网页时获取的 JavaScript、CSS 资源都是文本形式的，文件越大网页加载时间越长。</p> <p>为了提升网页加速速度和减少网络传输流量，可以对这些资源进行压缩。</p> <p>压缩的方法除了可以通过 GZIP 算法对文件压缩外，还可以对文本本身进行压缩。</p> <p>对文本本身进行压缩的作用除了有提升网页加载速度的优势外，还具有混淆源码的作用。 由于压缩后的代码可读性非常差，就算别人下载到了网页的代码，也大大增加了代码分析和改造的难度。</p> <h2 id="uglifyjs"><a href="#uglifyjs" class="header-anchor">#</a> UglifyJS⭐️</h2> <p>目前最成熟的 JavaScript 代码压缩工具是 UglifyJS ， 它会分析 JavaScript 代码语法树，理解代码含义，从而能做到诸如去掉无效代码、去掉日志输出代码、缩短变量名等优化。</p> <p>要在 Webpack 中接入 UglifyJS 需要通过插件的形式，目前有两个成熟的插件，分别是：</p> <ul><li>UglifyJsPlugin：通过封装 UglifyJS 实现压缩。</li> <li>ParallelUglifyPlugin：多进程并行处理压缩。</li></ul> <h3 id="常用配置"><a href="#常用配置" class="header-anchor">#</a> 常用配置</h3> <p>UglifyJS 提供了非常多的选择用于配置在压缩过程中采用哪些规则，常用的：</p> <ul><li><p><code>sourceMap</code>：</p> <p>是否为压缩后的代码生成对应的 Source Map，默认为不生成，开启后耗时会大大增加。一般不会把压缩后的代码的 Source Map 发送给网站用户的浏览器，而是用于内部开发人员调试线上代码时使用。</p></li> <li><p><code>beautify</code>：</p> <p>是否输出可读性较强的代码，即会保留空格和制表符，默认为是，为了达到更好的压缩效果，可以设置为 false。</p></li> <li><p><code>comments</code>：</p> <p>是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为 false。</p></li> <li><p><code>compress.warnings</code>：</p> <p>是否在 UglifyJs 删除没有用到的代码时输出警告信息，默认为输出，可以设置为 false 以关闭这些作用不大的警告。</p></li> <li><p><code>drop_console</code>：</p> <p>是否剔除代码中所有的 console 语句，默认为不剔除。开启后不仅可以提升代码压缩效果，也可以兼容不支持 console 语句 IE 浏览器。</p></li> <li><p><code>collapse_vars</code>：</p> <p>是否内嵌定义了但是只用到一次的变量，例如把 <code>var x = 5; y = x</code>转换成 <code>y = 5</code>，默认为不转换。为了达到更好的压缩效果，可以设置为 false。</p></li> <li><p><code>reduce_vars</code>：</p> <p>是否提取出出现多次但是没有定义成变量去引用的静态值，例如把 <code>x = 'Hello'; y = 'Hello'</code> 转换成 <code>var a = 'Hello'; x = a; y = b</code>，默认为不转换。为了达到更好的压缩效果，可以设置为 false。</p></li></ul> <p>通常配置如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//Webpack 内置了 UglifyJsPlugin</span>
<span class="token keyword">const</span> UglifyJSPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack/lib/optimize/UglifyJsPlugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 压缩输出的 JS 代码</span>
    <span class="token keyword">new</span> <span class="token class-name">UglifyJSPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      compress<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在UglifyJs删除没有用到的代码时不输出警告</span>
        warnings<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span>
        drop_console<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token comment">// 内嵌定义了但是只用到一次的变量</span>
        collapse_vars<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span>
        reduce_vars<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      output<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 最紧凑的输出</span>
        beautify<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token comment">// 删除所有的注释</span>
        comments<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="压缩es"><a href="#压缩es" class="header-anchor">#</a> 压缩ES</h3> <p>UglifyES 和 UglifyJS 来自同一个项目的不同分支，它们的配置项基本相同，只是接入 Webpack 时有所区别。 在给 Webpack 接入 UglifyES 时，不能使用内置的 UglifyJsPlugin，而是需要单独安装和使用最新版本的 uglifyjs-webpack-plugin</p> <p>Webpack 相关配置代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> UglifyESPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'uglifyjs-webpack-plugin'</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">UglifyESPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 多嵌套了一层</span>
      uglifyOptions<span class="token operator">:</span> <span class="token punctuation">{</span>
        compress<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// 在UglifyJs删除没有用到的代码时不输出警告</span>
          warnings<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
          <span class="token comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span>
          drop_console<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token comment">// 内嵌定义了但是只用到一次的变量</span>
          collapse_vars<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span>
          reduce_vars<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        output<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// 最紧凑的输出</span>
          beautify<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
          <span class="token comment">// 删除所有的注释</span>
          comments<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同时，为了不让 babel-loader 输出 ES5 语法的代码，需要去掉 <code>.babelrc</code> 配置文件中的 <code>babel-preset-env</code>，但是其它的 Babel 插件，比如 <code>babel-preset-react</code> 还是要保留， 因为正是 <code>babel-preset-env</code> 负责把 ES6 代码转换为 ES5 代码。</p> <h3 id="提升压缩速度"><a href="#提升压缩速度" class="header-anchor">#</a> 提升压缩速度</h3> <h2 id="压缩css"><a href="#压缩css" class="header-anchor">#</a> 压缩CSS</h2> <p>CSS 代码也可以像 JavaScript 那样被压缩，以达到提升加载速度和代码混淆的作用。 目前比较成熟可靠的 CSS 压缩工具是 cssnano，基于 PostCSS。</p> <p>cssnano 能理解 CSS 代码的含义，而不仅仅是删掉空格，例如：</p> <ul><li><code>margin: 10px 20px 10px 20px</code> 被压缩成 <code>margin: 10px 20px</code></li> <li><code>color: #ff0000</code> 被压缩成 <code>color:red</code></li></ul> <p>把 cssnano 接入到 Webpack 中也非常简单，因为 css-loader 已经将其内置了，要开启 cssnano 去压缩代码只需要开启 css-loader 的 minimize 选项。 相关 Webpack 配置如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>WebPlugin<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'web-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex">/\.css/</span><span class="token punctuation">,</span><span class="token comment">// 增加对 CSS 文件的支持</span>
        <span class="token comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span>
        use<span class="token operator">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          <span class="token comment">// 通过 minimize 选项压缩 CSS 代码</span>
          use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'css-loader?minimize'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 用 WebPlugin 生成对应的 HTML 文件</span>
    <span class="token keyword">new</span> <span class="token class-name">WebPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      template<span class="token operator">:</span> <span class="token string">'./template.html'</span><span class="token punctuation">,</span> <span class="token comment">// HTML 模版文件所在的文件路径</span>
      filename<span class="token operator">:</span> <span class="token string">'index.html'</span> <span class="token comment">// 输出的 HTML 的文件名称</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      filename<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[name]_[contenthash:8].css</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span><span class="token comment">// 给输出的 CSS 文件名称加上 Hash 值</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="paralleluglifyplugin"><a href="#paralleluglifyplugin" class="header-anchor">#</a> ParallelUglifyPlugin</h2> <p>由于压缩 JavaScript 代码需要先把代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST，导致这个过程计算量巨大，耗时非常多。</p> <p>ParallelUglifyPlugin 把多进程并行处理的思想也引入到代码压缩中。 当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。 所以 ParallelUglifyPlugin 能更快的完成对多个文件的压缩工作。</p> <p>使用 ParallelUglifyPlugin 也非常简单，把原来 Webpack 配置文件中内置的 UglifyJsPlugin 去掉后，再替换成 ParallelUglifyPlugin，相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> DefinePlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack/lib/DefinePlugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ParallelUglifyPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-parallel-uglify-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</span>
    <span class="token keyword">new</span> <span class="token class-name">ParallelUglifyPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 传递给 UglifyJS 的参数</span>
      uglifyJS<span class="token operator">:</span> <span class="token punctuation">{</span>
        output<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// 最紧凑的输出</span>
          beautify<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
          <span class="token comment">// 删除所有的注释</span>
          comments<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        compress<span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// 在UglifyJs删除没有用到的代码时不输出警告</span>
          warnings<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
          <span class="token comment">// 删除所有的 `console` 语句，可以兼容ie浏览器</span>
          drop_console<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token comment">// 内嵌定义了但是只用到一次的变量</span>
          collapse_vars<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token comment">// 提取出出现多次但是没有定义成变量去引用的静态值</span>
          reduce_vars<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在通过 new ParallelUglifyPlugin() 实例化时，支持以下参数：</p> <ul><li>test：使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 <code>/.js$/</code>，也就是默认压缩所有的 .js 文件。</li> <li>include：使用正则去命中需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。</li> <li>exclude：使用正则去命中不需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。</li> <li>cacheDir：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。</li> <li>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。</li> <li>sourceMap：是否输出 Source Map，这会导致压缩过程变慢。</li> <li>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</li> <li>uglifyES：用于压缩 ES6 代码时的配置，Object 类型，直接透传给 UglifyES 的参数。</li></ul> <p>UglifyES 是 UglifyJS 的变种，专门用于压缩 ES6 代码，它们两都出自于同一个项目，并且它们两不能同时使用。</p> <p>ParallelUglifyPlugin 同时内置了 UglifyJS 和 UglifyES，也就是说 ParallelUglifyPlugin 支持并行压缩 ES6 代码。</p> <h2 id="提取公共代码"><a href="#提取公共代码" class="header-anchor">#</a> 提取公共代码⭐️</h2> <p>大型网站通常会由多个页面组成，每个页面都是一个独立的单页应用。 但由于所有页面都采用同样的技术栈，以及使用同一套样式代码，这导致这些页面之间有很多相同的代码。</p> <p>如果每个页面的代码都把这些公共的部分包含进去，会造成以下问题：</p> <ul><li>相同的资源被重复的加载，浪费用户的流量和服务器的成本；</li> <li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</li></ul> <p>如果把多个页面公共的代码抽离成单独的文件，就能优化以上问题。 原因是假如用户访问了网站的其中一个网页，那么访问这个网站下的其它网页的概率将非常大。 在用户第一次访问后，这些页面公共代码的文件已经被浏览器缓存起来，在用户切换到其它页面时，存放公共代码的文件就不会再重新加载，而是直接从缓存中获取。 这样做后有如下好处：</p> <ul><li>减少网络传输流量，降低服务器成本；</li> <li>虽然用户第一次打开网站的速度得不到优化，但之后访问其它页面的速度将大大提升。</li></ul> <h3 id="原则"><a href="#原则" class="header-anchor">#</a> 原则</h3> <p>通常可以采用以下原则去为网站提取公共代码：</p> <ul><li><p>根据网站所使用的技术栈，找出网站所有页面都需要用到的基础库，以采用 React 技术栈的网站为例，所有页面都会依赖 react、react-dom 等库，把它们提取到一个单独的文件。 一般把这个文件叫做 base.js，因为它包含所有网页的基础运行环境；</p></li> <li><p>在剔除了各个页面中被 base.js 包含的部分代码外，再找出所有页面都依赖的公共部分的代码提取出来放到 common.js 中去。</p></li> <li><p>再为每个网页都生成一个单独的文件，这个文件中不再包含 base.js 和 common.js 中包含的部分，而只包含各个页面单独需要的部分代码。</p></li></ul> <p>为什么还需要再把网站所有页面都需要用到的基础库提取到 base.js 去呢，为了长期的缓存 base.js 这个文件。</p> <p>发布到线上的文件都会采用CDN加速，对静态文件的文件名都附加根据文件内容计算出 Hash 值，也就是最终 base.js 的文件名会变成 base_3b1682ac.js（假定），以长期缓存文件。 网站通常会不断的更新发布，每次发布都会导致 common.js 和各个网页的 JavaScript 文件都会因为文件内容发生变化而导致其 Hash 值被更新，也就是缓存被更新。</p> <p>把所有页面都需要用到的基础库提取到 base.js 的好处在于只要不升级基础库的版本， base.js 的文件内容就不会变化，Hash 值不会被更新，缓存就不会被更新。 每次发布浏览器都会使用被缓存的 base.js 文件，而不用去重新下载 base.js 文件。 由于 base.js 通常会很大，这对提升网页加速速度能起到很大的效果。</p> <h3 id="通过webpack提取公共代码"><a href="#通过webpack提取公共代码" class="header-anchor">#</a> 通过Webpack提取公共代码</h3> <p>Webpack 内置了专门用于提取多个 Chunk 中公共部分的插件 CommonsChunkPlugin，CommonsChunkPlugin 大致使用方法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//以下配置就能从网页 A 和网页 B 中抽离出公共部分，放到 common 中。</span>
<span class="token keyword">const</span> CommonsChunkPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack/lib/optimize/CommonsChunkPlugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">CommonsChunkPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 从哪些 Chunk 中提取</span>
  chunks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">// 提取出的公共部分形成一个新的 Chunk，这个新 Chunk 的名称</span>
  name<span class="token operator">:</span> <span class="token string">'common'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>每个 CommonsChunkPlugin 实例都会生成一个新的 Chunk，这个新 Chunk 中包含了被提取出的代码，在使用过程中必须指定 name 属性，以告诉插件新生成的 Chunk 的名称。 其中 chunks 属性指明从哪些已有的 Chunk 中提取，如果不填该属性，则默认会从所有已知的 Chunk 中提取。</p> <p>Chunk 是一系列文件的集合，一个 Chunk 中会包含这个 Chunk 的入口文件和入口文件依赖的文件。</p> <p>通过以上配置输出的 common Chunk 中会包含所有页面都依赖的基础运行库 <code>react、react-dom</code>(以react为例)，为了把基础运行库从 common 中抽离到 base 中去，还需要做一些处理。</p> <p>首先需要先配置一个 Chunk，这个 Chunk 中只依赖所有页面都依赖的基础库以及所有页面都使用的样式，为此需要在项目中写一个文件 base.js 来描述 base Chunk 所依赖的模块，文件内容如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 所有页面都依赖的基础库</span>
<span class="token keyword">import</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token comment">// 所有页面都使用的样式</span>
<span class="token keyword">import</span> <span class="token string">'./base.css'</span><span class="token punctuation">;</span>
</code></pre></div><p>接着再修改 Webpack 配置，在 entry 中加入 base，相关修改如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    base<span class="token operator">:</span> <span class="token string">'./base.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>为了从 common 中提取出 base 也包含的部分，还需要配置一个 CommonsChunkPlugin，相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">CommonsChunkPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 从 common 和 base 两个现成的 Chunk 中提取公共的部分</span>
  chunks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'common'</span><span class="token punctuation">,</span> <span class="token string">'base'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">// 把公共的部分放到 base 中</span>
  name<span class="token operator">:</span> <span class="token string">'base'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>由于 common 和 base 公共的部分就是 base 目前已经包含的部分，所以这样配置后 common 将会变小，而 base 将保持不变。</p> <p>以上都配置好后重新执行构建，将会得到四个文件，它们分别是：</p> <ul><li>base.js：所有网页都依赖的基础库组成的代码；</li> <li>common.js：网页A、B都需要的，但又不在 base.js 文件中出现过的代码；</li> <li>a.js：网页 A 单独需要的代码；</li> <li>b.js：网页 B 单独需要的代码。</li></ul> <p>为了让网页正常运行，以网页 A 为例，需要在其 HTML 中按照以下顺序引入以下文件才能让网页正常运行：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>base.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>common.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>以上方法可能会出现 common.js 中没有代码的情况，原因是去掉基础运行库外很难再找到所有页面都会用上的模块。</p> <div class="custom-block warning"><p class="custom-block-title">说明</p> <p>在webpack4抛弃了CommonsChunkPlugin，换成了更先进的SplitChunksPlugin。它们的区别就在于，CommonChunksPlugin 会找到多数模块中都共有的东西，并且把它提取出来（common.js），也就意味着如果你加载了 common.js，那么里面可能会存在一些当前模块不需要的东西。</p> <p>而 SplitChunksPlugin 采用了完全不同的 heuristics 方法，它会根据模块之间的依赖关系，自动打包出很多很多（而不是单个）通用模块，可以保证加载进来的代码一定是会被依赖到的。</p></div> <h2 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> Tree Shaking</h2> <p>要让 Tree Shaking 正常工作的前提是交给 Webpack 的 JavaScript 代码必须是采用 ES6 模块化语法的， 因为 ES6 模块化语法是静态的（导入导出语句中的路径必须是静态的字符串，而且不能放入其它代码块中），这让 Webpack 可以简单的分析出哪些 export 的被 import 过了。</p> <p>如果采用 ES5 中的模块化，例如 <code>module.export={...}</code>、 <code>require(x+y)</code>、 <code>if(x){require('./util')}</code>，Webpack 无法分析出哪些代码可以剔除。</p> <h3 id="接入-tree-shaking"><a href="#接入-tree-shaking" class="header-anchor">#</a> 接入 Tree Shaking</h3> <p>为了把采用 ES6 模块化的代码交给 Webpack，需要配置 Babel 让其保留 ES6 模块化语句，修改 .babelrc 文件为如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">[</span>
      <span class="token string">&quot;env&quot;</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token string">&quot;modules&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中 <code>&quot;modules&quot;: false</code> 的含义是关闭 Babel 的模块转换功能，保留原本的 ES6 模块化语法。</p> <p>Webpack 只是指出了哪些函数用上了哪些没用上，要剔除用不上的代码还得经过 UglifyJS 去处理一遍。 要接入 UglifyJS 也很简单，不仅可以通过 UglifyJSPlugin 去实现， 也可以简单的通过在启动 Webpack 时带上 --optimize-minimize 参数</p> <p>mainFields 用于配置采用哪个字段作为模块的入口描述。 为了让 Tree Shaking 对第三方库生效，需要配置 Webpack 的文件寻找规则为如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  resolve<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件</span>
    mainFields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'jsnext:main'</span><span class="token punctuation">,</span> <span class="token string">'browser'</span><span class="token punctuation">,</span> <span class="token string">'main'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>以上配置的含义是优先使用 jsnext:main 作为入口，如果不存在 jsnext:main 就采用 browser 或者 main 作为入口。 虽然并不是每个 Npm 中的第三方模块都会提供 ES6 模块化语法的代码，但对于提供了的不能放过，能优化的就优化。</p> <p>目前越来越多的 Npm 中的第三方模块考虑到了 Tree Shaking，并对其提供了支持。 采用 <code>jsnext:main</code>作为 ES6 模块化代码的入口是社区的一个约定</p> <h2 id="webpack-怎么区分线上环境测试环境生产环境，并能通过-js-变量访问到？"><a href="#webpack-怎么区分线上环境测试环境生产环境，并能通过-js-变量访问到？" class="header-anchor">#</a> webpack 怎么区分线上环境测试环境生产环境，并能通过 JS 变量访问到？</h2> <p>在开发网页的时候，一般都会有多套运行环境，例如：</p> <ul><li>在开发过程中方便开发调试的环境。</li> <li>发布到线上给用户使用的运行环境。</li></ul> <p>这两套不同的环境虽然都是由同一套源代码编译而来，但是代码内容却不一样，差异包括：</p> <ul><li>线上代码被压缩过。</li> <li>开发用的代码包含一些用于提示开发者的提示日志，这些日志普通用户不可能去看它。</li> <li>开发用的代码所连接的后端数据接口地址也可能和线上环境不同，因为要避免开发过程中造成对线上数据的影响。</li></ul> <p>为了尽可能的复用代码，在构建的过程中需要根据目标代码要运行的环境而输出不同的代码</p> <h3 id="区分方法"><a href="#区分方法" class="header-anchor">#</a> 区分方法</h3> <p>具体区分方法很简单，在源码中通过如下方式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你正在线上环境'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你正在使用开发环境'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其大概原理是借助于环境变量的值去判断执行哪个分支。</p> <p>当代码中出现了使用 process 模块的语句时，Webpack 就自动打包进 process 模块的代码以支持非 Node.js 的运行环境。</p> <p>当代码中没有使用 process 时就不会打包进 process 模块的代码。这个注入的 process 模块作用是为了模拟 Node.js 中的 process，以支持上面使用的 <code>process.env.NODE_ENV === 'production'</code>语句。</p> <p>在构建线上环境代码时，需要给当前运行环境设置环境变量 NODE_ENV = 'production'，Webpack 相关配置如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> DefinePlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack/lib/DefinePlugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 定义 NODE_ENV 环境变量为 production</span>
      <span class="token string">'process.env'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token comment">//注意在定义环境变量的值时用 JSON.stringify 包裹字符串的原因是环境变量的值需要是一个由双引号包裹的字符串，</span>
		<span class="token comment">//而 JSON.stringify('production')的值正好等于'&quot;production&quot;'</span>
        <span class="token constant">NODE_ENV</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'production'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>process.env.NODE_ENV !== 'production'</code> 中的 <code>NODE_ENV</code> 和 <code>'production'</code> 两个值是社区的约定，通常使用这条判断语句在区分开发环境和线上环境。</p> <h2 id="用-webpack-实现-cdn-的接入"><a href="#用-webpack-实现-cdn-的接入" class="header-anchor">#</a> 用 Webpack 实现 CDN 的接入⭐️</h2> <p>构建需要实现以下几点：</p> <ul><li>静态资源的导入 URL 需要变成指向 CDN 服务的绝对路径的 URL 而不是相对于 HTML 文件的 URL。</li> <li>静态资源的文件名称需要带上有文件内容算出来的 Hash 值，以防止被缓存。</li> <li>不同类型的资源放到不同域名的 CDN 服务上去，以防止资源的并行加载被阻塞。</li></ul> <p>先来看下要实现以上要求的最终 Webpack 配置：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>WebPlugin<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'web-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 省略 entry 配置...</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 给输出的 JavaScript 文件名称加上 Hash 值</span>
    filename<span class="token operator">:</span> <span class="token string">'[name]_[chunkhash:8].js'</span><span class="token punctuation">,</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 指定存放 JavaScript 文件的 CDN 目录 URL</span>
    publicPath<span class="token operator">:</span> <span class="token string">'//js.cdn.com/id/'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// 增加对 CSS 文件的支持</span>
        test<span class="token operator">:</span> <span class="token regex">/\.css/</span><span class="token punctuation">,</span>
        <span class="token comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span>
        use<span class="token operator">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          <span class="token comment">// 压缩 CSS 代码</span>
          use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'css-loader?minimize'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          <span class="token comment">// 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL</span>
          publicPath<span class="token operator">:</span> <span class="token string">'//img.cdn.com/id/'</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// 增加对 PNG 文件的支持</span>
        test<span class="token operator">:</span> <span class="token regex">/\.png/</span><span class="token punctuation">,</span>
        <span class="token comment">// 给输出的 PNG 文件名称加上 Hash 值</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'file-loader?name=[name]_[hash:8].[ext]'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment">// 省略其它 Loader 配置...</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 使用 WebPlugin 自动生成 HTML</span>
    <span class="token keyword">new</span> <span class="token class-name">WebPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// HTML 模版文件所在的文件路径</span>
      template<span class="token operator">:</span> <span class="token string">'./template.html'</span><span class="token punctuation">,</span>
      <span class="token comment">// 输出的 HTML 的文件名称</span>
      filename<span class="token operator">:</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span>
      <span class="token comment">// 指定存放 CSS 文件的 CDN 目录 URL</span>
      stylePublicPath<span class="token operator">:</span> <span class="token string">'//css.cdn.com/id/'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 给输出的 CSS 文件名称加上 Hash 值</span>
      filename<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[name]_[contenthash:8].css</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 省略代码压缩插件配置...</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>核心的部分是通过 publicPath 参数设置存放静态资源的 CDN 目录 URL， 为了让不同类型的资源输出到不同的 CDN，需要分别在：</p> <ul><li>output.publicPath 中设置 JavaScript 的地址。</li> <li>css-loader.publicPath 中设置被 CSS 导入的资源的的地址。</li> <li>WebPlugin.stylePublicPath 中设置 CSS 文件的地址。</li></ul> <p>设置好 publicPath 后，WebPlugin 在生成 HTML 文件和 css-loader 转换 CSS 代码时，会考虑到配置中的 publicPath，用对应的线上地址替换原来的相对地址。</p> <h2 id="按需加载"><a href="#按需加载" class="header-anchor">#</a> 按需加载⭐️</h2> <p>随着互联网的发展，一个网页需要承载的功能越来越多。 对于采用单页应用作为前端架构的网站来说，会面临着一个网页需要加载的代码量很大的问题，因为许多功能都集中的做到了一个 HTML 里。 这会导致网页加载缓慢、交互卡顿，用户体验将非常糟糕。</p> <p>导致这个问题的根本原因在于一次性的加载所有功能对应的代码，但其实用户每一阶段只可能使用其中一部分功能。 所以解决以上问题的方法就是用户当前需要用什么功能就只加载这个功能对应的代码，也就是所谓的按需加载。</p> <h3 id="原则-2"><a href="#原则-2" class="header-anchor">#</a> 原则</h3> <p>在给单页应用做按需加载优化时，一般采用以下原则：</p> <ul><li>把整个网站划分成一个个小功能，再按照每个功能的相关程度把它们分成几类。</li> <li>把每一类合并为一个 Chunk，按需加载对应的 Chunk。</li> <li>对于用户首次打开网站时需要看到的画面所对应的功能，不要对它们做按需加载，而是放到执行入口所在的 Chunk 中，以降低用户能感知的网页加载时间。</li> <li>对于个别依赖大量代码的功能点，例如依赖 Chart.js 去画图表、依赖 flv.js 去播放视频的功能点，可再对其进行按需加载。</li></ul> <p>被分割出去的代码的加载需要一定的时机去触发，也就是当用户操作到了或者即将操作到对应的功能时再去加载对应的代码。 被分割出去的代码的加载时机需要开发者自己去根据网页的需求去衡量和确定。</p> <p>由于被分割出去进行按需加载的代码在加载的过程中也需要耗时，可以预言用户接下来可能会进行的操作，并提前加载好对应的代码，从而让用户感知不到网络加载时间。</p> <h3 id="用-webpack-实现按需加载"><a href="#用-webpack-实现按需加载" class="header-anchor">#</a> 用 Webpack 实现按需加载</h3> <p>Webpack 内置了强大的分割代码的功能去实现按需加载，实现起来非常简单。</p> <p>举个例子，现在需要做这样一个进行了按需加载优化的网页：</p> <ul><li>网页首次加载时只加载 main.js 文件，网页会展示一个按钮，main.js 文件中只包含监听按钮事件和加载按需加载的代码。</li> <li>当按钮被点击时才去加载被分割出去的 show.js 文件，加载成功后再执行 show.js 里的函数。</li></ul> <p>其中 main.js 文件内容如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当按钮被点击后才去加载 show.js 文件，文件加载成功后执行文件导出的函数</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;show&quot; */</span> <span class="token string">'./show'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">show</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">show</span><span class="token punctuation">(</span><span class="token string">'Webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>show.js 文件内容如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Hello '</span> <span class="token operator">+</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>代码中最关键的一句是</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;show&quot; */</span> <span class="token string">'./show'</span><span class="token punctuation">)</span>
</code></pre></div><p>Webpack 内置了对 <code>import(*)</code> 语句的支持，当 Webpack 遇到了类似的语句时会这样处理：</p> <ul><li>以 <code>./show.js</code> 为入口新生成一个 Chunk；</li> <li>当代码执行到 import 所在语句时才会去加载由 Chunk 对应生成的文件。</li> <li>import 返回一个 Promise，当文件加载成功时可以在 Promise 的 then 方法中获取到 show.js 导出的内容。</li></ul> <p>在使用 import() 分割代码后，返回一个 Promise。对于不原生支持 Promise 的浏览器，需要注入 Promise polyfill。</p> <p><code>/* webpackChunkName: &quot;show&quot; */</code> 的含义是为动态生成的 Chunk 赋予一个名称，以方便追踪和调试代码。</p> <p>如果不指定动态生成的 Chunk 的名称，默认名称将会是 <code>[id].js</code>。</p> <p><code>/* webpackChunkName: &quot;show&quot; */</code> 是在 Webpack3 中引入的新特性，在 Webpack3 之前是无法为动态生成的 Chunk 赋予名称的。</p> <p>为了正确的输出在 <code>/* webpackChunkName: &quot;show&quot; */</code> 中配置的 ChunkName，还需要配置下 Webpack，配置如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// JS 执行入口文件</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    main<span class="token operator">:</span> <span class="token string">'./main.js'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为从 entry 中配置生成的 Chunk 配置输出文件的名称</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>
    <span class="token comment">// 为动态加载的 Chunk 配置输出文件的名称</span>
    chunkFilename<span class="token operator">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>其中最关键的一行是 <code>chunkFilename: '[name].js'</code>,，它专门指定动态生成的 Chunk 在输出时的文件名称。</p> <p>如果没有这行，分割出的代码的文件名称将会是 <code>[id].js</code>。</p> <h2 id="输出分析"><a href="#输出分析" class="header-anchor">#</a> 输出分析</h2> <p>在启动 Webpack 时，支持两个参数，分别是：</p> <ul><li>--profile：记录下构建过程中的耗时信息；</li> <li>--json：以 JSON 的格式输出构建结果，最后只输出一个 .json 文件，这个文件中包括所有构建相关的信息。
在启动 Webpack 时带上以上两个参数，启动命令如下 <code>webpack --profile --json &gt; stats.json</code>，你会发现项目中多出了一个 stats.json 文件。 这个 stats.json 文件是给后面介绍的可视化分析工具使用的。</li></ul> <p><code>webpack --profile --json</code> 会输出字符串形式的 JSON， <code>&gt; stats.json</code> 是 UNIX/Linux 系统中的管道命令、含义是把 <code>webpack --profile --json</code> 输出的内容通过管道输出到 stats.json 文件中。</p> <h3 id="webpack-analyse"><a href="#webpack-analyse" class="header-anchor">#</a> Webpack Analyse</h3> <p>Webpack 官方提供了一个可视化分析工具 Webpack Analyse，它是一个在线 Web 应用。</p> <p>打开 Webpack Analyse 链接的网页后，就会看到一个弹窗提示你上传 JSON 文件，也就是需要上传上面讲到的 stats.json 文件</p> <p>它分为了六大板块，分别是：</p> <ul><li>Modules：展示所有的模块，每个模块对应一个文件。并且还包含所有模块之间的依赖关系图、模块路径、模块ID、模块所属 Chunk、模块大小；</li> <li>Chunks：展示所有的代码块，一个代码块中包含多个模块。并且还包含代码块的ID、名称、大小、每个代码块包含的模块数量，以及代码块之间的依赖关系图；</li> <li>Assets：展示所有输出的文件资源，包括 .js、 .css、图片等。并且还包括文件名称、大小、该文件来自哪个代码块；</li> <li>Warnings：展示构建过程中出现的所有警告信息；</li> <li>Errors：展示构建过程中出现的所有错误信息；</li> <li>Hints：展示处理每个模块的过程中的耗时。</li></ul> <h3 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="header-anchor">#</a> webpack-bundle-analyzer</h3> <p>webpack-bundle-analyzer 是另一个可视化分析工具， 它虽然没有官方那样有那么多功能，但比官方的要更加直观。</p> <p>它能方便知道：</p> <ul><li>打包出的文件中都包含了什么；</li> <li>每个文件的尺寸在总体中的占比，一眼看出哪些文件尺寸大；</li> <li>模块之间的包含关系；</li> <li>每个文件的 Gzip 后的大小。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/webpack/" class="prev router-link-active">
        首页
      </a></span> <span class="next"><a href="/frontend/webpack/webpack.html">
        基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.484f4375.js" defer></script><script src="/assets/js/2.ebbe98b4.js" defer></script><script src="/assets/js/119.213aaa9b.js" defer></script>
  </body>
</html>
