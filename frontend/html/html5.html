<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>html5 | ゼロツー</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/favicon.jpg">
    <meta name="description" content="zerotwo">
    <link rel="preload" href="/assets/css/0.styles.f0b7ee7d.css" as="style"><link rel="preload" href="/assets/js/app.484f4375.js" as="script"><link rel="preload" href="/assets/js/2.ebbe98b4.js" as="script"><link rel="preload" href="/assets/js/49.6652f2b2.js" as="script"><link rel="prefetch" href="/assets/js/10.91de1805.js"><link rel="prefetch" href="/assets/js/100.1772503e.js"><link rel="prefetch" href="/assets/js/101.b569a1af.js"><link rel="prefetch" href="/assets/js/102.65dffa11.js"><link rel="prefetch" href="/assets/js/103.d7a8cd9e.js"><link rel="prefetch" href="/assets/js/104.0a0e3708.js"><link rel="prefetch" href="/assets/js/105.15bc167a.js"><link rel="prefetch" href="/assets/js/106.8487cf9a.js"><link rel="prefetch" href="/assets/js/107.2310b94b.js"><link rel="prefetch" href="/assets/js/108.781b7ebe.js"><link rel="prefetch" href="/assets/js/109.6225704a.js"><link rel="prefetch" href="/assets/js/11.9c44c6b2.js"><link rel="prefetch" href="/assets/js/110.3c39cb3c.js"><link rel="prefetch" href="/assets/js/111.22bede53.js"><link rel="prefetch" href="/assets/js/112.acb6b722.js"><link rel="prefetch" href="/assets/js/113.c2b6115e.js"><link rel="prefetch" href="/assets/js/114.cbeddf77.js"><link rel="prefetch" href="/assets/js/115.adf2d1b9.js"><link rel="prefetch" href="/assets/js/116.3f23eb5b.js"><link rel="prefetch" href="/assets/js/117.00cb8ac3.js"><link rel="prefetch" href="/assets/js/118.e88e1cfb.js"><link rel="prefetch" href="/assets/js/119.213aaa9b.js"><link rel="prefetch" href="/assets/js/12.878aa51b.js"><link rel="prefetch" href="/assets/js/120.fc12eb0e.js"><link rel="prefetch" href="/assets/js/121.67bafb52.js"><link rel="prefetch" href="/assets/js/122.cca49856.js"><link rel="prefetch" href="/assets/js/123.0e27eb9e.js"><link rel="prefetch" href="/assets/js/124.53383547.js"><link rel="prefetch" href="/assets/js/125.e103d7f1.js"><link rel="prefetch" href="/assets/js/126.adb34a41.js"><link rel="prefetch" href="/assets/js/127.f352dcec.js"><link rel="prefetch" href="/assets/js/128.9aa22460.js"><link rel="prefetch" href="/assets/js/129.02dabe8a.js"><link rel="prefetch" href="/assets/js/13.b4c5b1dd.js"><link rel="prefetch" href="/assets/js/130.7d88cb43.js"><link rel="prefetch" href="/assets/js/14.dce5d003.js"><link rel="prefetch" href="/assets/js/15.ec0f3b1f.js"><link rel="prefetch" href="/assets/js/16.a9597b38.js"><link rel="prefetch" href="/assets/js/17.c8f44f51.js"><link rel="prefetch" href="/assets/js/18.67e67934.js"><link rel="prefetch" href="/assets/js/19.2b8ea36f.js"><link rel="prefetch" href="/assets/js/20.ee5ab76e.js"><link rel="prefetch" href="/assets/js/21.1582f8ed.js"><link rel="prefetch" href="/assets/js/22.130fb5fa.js"><link rel="prefetch" href="/assets/js/23.ecbb4b5d.js"><link rel="prefetch" href="/assets/js/24.0c8b3ecd.js"><link rel="prefetch" href="/assets/js/25.4aae22ea.js"><link rel="prefetch" href="/assets/js/26.4816aa3d.js"><link rel="prefetch" href="/assets/js/27.2e6f0659.js"><link rel="prefetch" href="/assets/js/28.7e0fef24.js"><link rel="prefetch" href="/assets/js/29.dad88d85.js"><link rel="prefetch" href="/assets/js/3.5e8d6a69.js"><link rel="prefetch" href="/assets/js/30.1ecf79ca.js"><link rel="prefetch" href="/assets/js/31.0a97fafc.js"><link rel="prefetch" href="/assets/js/32.8e6151d1.js"><link rel="prefetch" href="/assets/js/33.b5ff95d1.js"><link rel="prefetch" href="/assets/js/34.0d03faf5.js"><link rel="prefetch" href="/assets/js/35.6d4b4665.js"><link rel="prefetch" href="/assets/js/36.b42cbedf.js"><link rel="prefetch" href="/assets/js/37.4de10dce.js"><link rel="prefetch" href="/assets/js/38.9031eb30.js"><link rel="prefetch" href="/assets/js/39.daee868f.js"><link rel="prefetch" href="/assets/js/4.ceb8a314.js"><link rel="prefetch" href="/assets/js/40.df374a26.js"><link rel="prefetch" href="/assets/js/41.563436c6.js"><link rel="prefetch" href="/assets/js/42.b9200ca4.js"><link rel="prefetch" href="/assets/js/43.40ae12a3.js"><link rel="prefetch" href="/assets/js/44.4a0dd48e.js"><link rel="prefetch" href="/assets/js/45.20d657cc.js"><link rel="prefetch" href="/assets/js/46.2d34fe10.js"><link rel="prefetch" href="/assets/js/47.3dcb2d38.js"><link rel="prefetch" href="/assets/js/48.1b0959df.js"><link rel="prefetch" href="/assets/js/5.b28c76e0.js"><link rel="prefetch" href="/assets/js/50.30bdc802.js"><link rel="prefetch" href="/assets/js/51.ebe5930a.js"><link rel="prefetch" href="/assets/js/52.02f2caf4.js"><link rel="prefetch" href="/assets/js/53.55df3fc5.js"><link rel="prefetch" href="/assets/js/54.e2bff3b5.js"><link rel="prefetch" href="/assets/js/55.c859c458.js"><link rel="prefetch" href="/assets/js/56.d493a61b.js"><link rel="prefetch" href="/assets/js/57.9af46dbf.js"><link rel="prefetch" href="/assets/js/58.46d4e8aa.js"><link rel="prefetch" href="/assets/js/59.82e453fe.js"><link rel="prefetch" href="/assets/js/6.b43fc5c2.js"><link rel="prefetch" href="/assets/js/60.d9652552.js"><link rel="prefetch" href="/assets/js/61.bad1d82a.js"><link rel="prefetch" href="/assets/js/62.8c307334.js"><link rel="prefetch" href="/assets/js/63.7ebafb7e.js"><link rel="prefetch" href="/assets/js/64.bc588101.js"><link rel="prefetch" href="/assets/js/65.6f66d6a2.js"><link rel="prefetch" href="/assets/js/66.ee6f0d41.js"><link rel="prefetch" href="/assets/js/67.0002a9a5.js"><link rel="prefetch" href="/assets/js/68.4a86ea26.js"><link rel="prefetch" href="/assets/js/69.c9e36070.js"><link rel="prefetch" href="/assets/js/7.87b3f924.js"><link rel="prefetch" href="/assets/js/70.40af8c94.js"><link rel="prefetch" href="/assets/js/71.ee207bd6.js"><link rel="prefetch" href="/assets/js/72.c389068e.js"><link rel="prefetch" href="/assets/js/73.c1526d9c.js"><link rel="prefetch" href="/assets/js/74.cd1c9d32.js"><link rel="prefetch" href="/assets/js/75.144c1f5b.js"><link rel="prefetch" href="/assets/js/76.4c36bfbf.js"><link rel="prefetch" href="/assets/js/77.7db5b3f1.js"><link rel="prefetch" href="/assets/js/78.de99e748.js"><link rel="prefetch" href="/assets/js/79.1febcdca.js"><link rel="prefetch" href="/assets/js/8.ab13bda4.js"><link rel="prefetch" href="/assets/js/80.e802c8bb.js"><link rel="prefetch" href="/assets/js/81.960e4a52.js"><link rel="prefetch" href="/assets/js/82.9a35963d.js"><link rel="prefetch" href="/assets/js/83.005e1aad.js"><link rel="prefetch" href="/assets/js/84.d61f7f01.js"><link rel="prefetch" href="/assets/js/85.0906b75c.js"><link rel="prefetch" href="/assets/js/86.dff86ecd.js"><link rel="prefetch" href="/assets/js/87.00755e79.js"><link rel="prefetch" href="/assets/js/88.00604a67.js"><link rel="prefetch" href="/assets/js/89.376832c9.js"><link rel="prefetch" href="/assets/js/9.b83e9e02.js"><link rel="prefetch" href="/assets/js/90.9be39541.js"><link rel="prefetch" href="/assets/js/91.d5eb29c9.js"><link rel="prefetch" href="/assets/js/92.9f5fba68.js"><link rel="prefetch" href="/assets/js/93.670dcf5c.js"><link rel="prefetch" href="/assets/js/94.9d783387.js"><link rel="prefetch" href="/assets/js/95.0fd08cc1.js"><link rel="prefetch" href="/assets/js/96.ae0eb4f1.js"><link rel="prefetch" href="/assets/js/97.1d15ea38.js"><link rel="prefetch" href="/assets/js/98.1bc97ef6.js"><link rel="prefetch" href="/assets/js/99.d91a7a9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f0b7ee7d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./favicon.jpg" alt="ゼロツー" class="logo"> <span class="site-name can-hide">ゼロツー</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link router-link-active">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><span class="title">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/js/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/html/" class="nav-link router-link-active">
  HTML
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/vue/" class="nav-link">
  VUE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/frontend/miniProgram/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/frontend/mobile/" class="nav-link">
  移动端
</a></li><li class="dropdown-item"><!----> <a href="/frontend/ts/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/node/" class="nav-link">
  NODE
</a></li><li class="dropdown-item"><!----> <a href="/frontend/native/" class="nav-link">
  原生开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其余" class="dropdown-title"><span class="title">其余</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/computerNetwork/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/frontend/browser/" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/frontend/performance/" class="nav-link">
  性能
</a></li><li class="dropdown-item"><!----> <a href="/frontend/safety/" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/frontend/axios/" class="nav-link">
  axios
</a></li><li class="dropdown-item"><!----> <a href="/frontend/API/" class="nav-link">
  api
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/code/" class="nav-link">
  手写源码
</a></li><li class="dropdown-item"><!----> <a href="/frontend/algorithm/" class="nav-link">
  编码和算法
</a></li><li class="dropdown-item"><!----> <a href="/frontend/leetcode/" class="nav-link">
  leetcode
</a></li></ul></div></div><div class="nav-item"><a href="/frontend/others/" class="nav-link">
  开发
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os/" class="nav-link">
  os
</a></li><li class="dropdown-item"><!----> <a href="/markdown/" class="nav-link">
  md
</a></li><li class="dropdown-item"><!----> <a href="/git/" class="nav-link">
  git
</a></li><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">
  linux
</a></li><li class="dropdown-item"><!----> <a href="/view/" class="nav-link">
  view
</a></li><li class="dropdown-item"><!----> <a href="/server/" class="nav-link">
  server
</a></li><li class="dropdown-item"><!----> <a href="/guide/" class="nav-link">
  guide
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>html</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/html/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/frontend/html/html.html" class="sidebar-link">基础</a></li><li><a href="/frontend/html/html5.html" aria-current="page" class="active sidebar-link">html5</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#语义化" class="sidebar-link">语义化</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#表单input" class="sidebar-link">表单input</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#表单元素" class="sidebar-link">表单元素</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#表单属性" class="sidebar-link">表单属性</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#video-元素" class="sidebar-link">video 元素</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#audio-元素" class="sidebar-link">audio 元素</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#html5存储方式（客户端）" class="sidebar-link">HTML5存储方式（客户端）</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#cookie" class="sidebar-link">cookie</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#storage接口" class="sidebar-link">Storage接口</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#sessionstorage" class="sidebar-link">sessionStorage</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#localstorage" class="sidebar-link">localStorage</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#cookie-与-webstorage-的区别" class="sidebar-link">Cookie 与 webStorage 的区别</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#indexdb" class="sidebar-link">indexDB</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#离线缓存" class="sidebar-link">离线缓存</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#application-cache（已经从web标准删除）" class="sidebar-link">application cache（已经从web标准删除）</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#websocket" class="sidebar-link">WebSocket</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#web-worker" class="sidebar-link">Web Worker⭐️</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#canvas绘图" class="sidebar-link">canvas绘图</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#svg绘图" class="sidebar-link">SVG绘图</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#html5和html的区别" class="sidebar-link">html5和html的区别</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#html5自定义属性" class="sidebar-link">HTML5自定义属性</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#拖放" class="sidebar-link">拖放</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#哪些方式有利于seo" class="sidebar-link">哪些方式有利于SEO</a></li><li class="sidebar-sub-header"><a href="/frontend/html/html5.html#area" class="sidebar-link">area</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="语义化"><a href="#语义化" class="header-anchor">#</a> 语义化</h2> <h3 id="语义化的优点有："><a href="#语义化的优点有：" class="header-anchor">#</a> 语义化的优点有：</h3> <ul><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来确定上下文和各个关键字的权重。</li> <li>代码结构清晰，易于阅读，利于开发和维护。</li> <li>提高用户体验，在样式加载失败时，页面结构清晰。</li> <li>方便其他设备（如屏幕阅读器，盲人阅读器）解析，根据语义渲染网页。</li></ul> <h3 id="语义化标签"><a href="#语义化标签" class="header-anchor">#</a> 语义化标签</h3> <table><thead><tr><th>标签</th> <th>描述</th></tr></thead> <tbody><tr><td>title</td> <td>定义文档的标题，浏览器窗口的标题栏或状态栏的标题，当把文档加入用户的链接列表或者收藏夹或书签列表时，标题将成为该文档链接的默认名称。</td></tr> <tr><td>header</td> <td>页眉通常包括网站标志、主导航、全站链接以及搜索框</td></tr> <tr><td>footer</td> <td>定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。联系信息应该位于 address标签中。</td></tr> <tr><td>main</td> <td>规定文档的主要内容。元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏或搜索表单。</td></tr> <tr><td>article</td> <td>规定独立的自包含内容。一篇文章应有其自身的意义，论坛帖子、报纸文章、博客条目、用户评论</td></tr> <tr><td>address</td> <td>定义文档或文章的作者/拥有者的联系信息。元素中的文本通常呈现为斜体</td></tr> <tr><td>canvas</td> <td>定义图形，比如图表和其他图像，canvas只是图形容器，您必须使用脚本来绘制图形。</td></tr> <tr><td>dialog</td> <td>定义对话框或窗口。单属性open 规定 dialog元素是活动的，用户可与之交互。</td></tr> <tr><td>audio</td> <td>定义声音，比如音乐或其他音频流。</td></tr> <tr><td>video</td> <td>标签定义视频，比如电影片段或其他视频流。</td></tr> <tr><td>aside</td> <td>定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。</td></tr> <tr><td>section</td> <td>定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。单属性cite为section 的 URL，假如 section 摘自 web 的话。</td></tr> <tr><td>figure</td> <td>规定独立的流内容（图像、图表、照片、代码等等。元素的内容应该与主内容相关，figcation定义 figure的标题。</td></tr> <tr><td>mark</td> <td>高亮</td></tr></tbody></table> <h2 id="表单input"><a href="#表单input" class="header-anchor">#</a> 表单input</h2> <p>新增表单input类型</p> <table><thead><tr><th>输入类型</th> <th>描述</th></tr></thead> <tbody><tr><td>color</td> <td>用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。</td></tr> <tr><td>date</td> <td>输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</td></tr> <tr><td>datetime-local</td> <td>输入日期和时间的控件，不包括时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</td></tr> <tr><td>month</td> <td>输入年和月的控件，没有时区。</td></tr> <tr><td>range</td> <td>此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用<code>htmlattrdefmin</code>和<code>htmlattrdefmax</code>来规定值的范围</td></tr> <tr><td>search</td> <td>用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。</td></tr> <tr><td>tel</td> <td>用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。</td></tr> <tr><td>time</td> <td>用于输入时间的控件，不包括时区。</td></tr> <tr><td>url</td> <td>用于输入 URL 的控件。类似 text 输入，但有验证参数，在支持动态键盘的设备上有相应的键盘。</td></tr></tbody></table> <p>比较特殊的type有，color、tel、url、range、search</p> <blockquote><p>datetime被废弃了</p></blockquote> <h3 id="完整input类型"><a href="#完整input类型" class="header-anchor">#</a> 完整input类型</h3> <table><thead><tr><th>输入类型</th> <th>描述</th></tr></thead> <tbody><tr><td>button</td> <td>没有默认行为的按钮，上面显示 value 属性的值，默认为空。</td></tr> <tr><td>checkbox</td> <td>复选框，可设为选中或未选中。</td></tr> <tr><td>email</td> <td>编辑邮箱地址的区域。类似 text 输入，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘。</td></tr> <tr><td>file</td> <td>让用户选择文件的控件。使用accept属性规定控件能选择的文件类型。</td></tr> <tr><td>hidden</td> <td>不显示的控件，其值仍会提交到服务器。</td></tr> <tr><td>image</td> <td>带图像的 submit 按钮。显示的图像由 src 属性规定。如果 src 缺失，alt 属性就会显示。</td></tr> <tr><td>number</td> <td>用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘。</td></tr> <tr><td>password</td> <td>单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户。</td></tr> <tr><td>radio</td> <td>单选按钮，允许在多个拥有相同 name 值的选项中选中其中一个。</td></tr> <tr><td>reset</td> <td>此按钮将表单的所有内容重置为默认值。不推荐。</td></tr> <tr><td>submit</td> <td>用于提交表单的按钮。</td></tr> <tr><td>text</td> <td>默认值。单行的文本区域，输入中的换行会被自动去除。</td></tr> <tr><td>week</td> <td>用于输入以年和周数组成的日期，不带时区。</td></tr></tbody></table> <h2 id="表单元素"><a href="#表单元素" class="header-anchor">#</a> 表单元素</h2> <p>新增表单元素</p> <table><thead><tr><th>表单元素</th> <th>描述</th></tr></thead> <tbody><tr><td>datalist</td> <td>元素规定输入域的选项列表，使用元素的list 属性与元素的id 绑定</td></tr> <tr><td>keygen</td> <td>提供一种验证用户的可靠方法，标签规定用于表单的密钥对生成器字段。</td></tr> <tr><td>output</td> <td>用于不同类型的输出</td></tr></tbody></table> <h2 id="表单属性"><a href="#表单属性" class="header-anchor">#</a> 表单属性</h2> <p>新增表单属性</p> <table><thead><tr><th>表单属性</th> <th>描述</th></tr></thead> <tbody><tr><td>placehoder</td> <td>简短的提示在用户输入值前会显示在输入域上。在用户输入后消失。</td></tr> <tr><td>required</td> <td>boolean值。为true时要求填写的输入域不能为空</td></tr> <tr><td>pattern</td> <td>描述了一个正则表达式用于验证元素的值。</td></tr> <tr><td>min/max</td> <td>设置元素最小值/最大值。</td></tr> <tr><td>step</td> <td>为输入域规定合法的数字间隔。</td></tr> <tr><td>height/width</td> <td>用于image类型的标签的图像高度/宽度。</td></tr> <tr><td>autofocus</td> <td>boolean值。为true时规定在页面加载时，域自动地获得焦点。</td></tr> <tr><td>multiple</td> <td>boolean值。规定 元素中是否可选择多个值。</td></tr></tbody></table> <h2 id="video-元素"><a href="#video-元素" class="header-anchor">#</a> video 元素</h2> <p>video 元素 用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放</p> <blockquote><p>也可以将 video 标签用于音频内容，但是 audio素可能在用户体验上更合适。</p></blockquote> <p>和 img 元素的使用类似，在 src 属性里加入一个需要展示的视频地址，同时也可以用其他属性来定义视频的宽度高度、是否自动或者循环播放、是否展示浏览器默认的视频控件等信息。</p> <p>在 video 标签中间的内容，是针对浏览器不支持此元素时候的降级处理。</p> <p>浏览器并不是都支持相同的视频格式，所以你可以在 source 元素里提供多个视频源，然后浏览器将会使用它所支持的第一个源。</p> <p>如果没有指定 controls 属性，那么视频不会展示浏览器自带的控件，当然也可以用 JavaScript 和 HTMLMediaElement API 来创建自己的控件</p> <p>可以用CSS 属性 object-position 来调整视频在元素内部的位置，它可以控制视频尺寸适应于元素外框的方式。</p> <p>如果想在视频里展示字幕或者标题，可以在 track 元素和 WebVTT 格式的基础上使用 JavaScript 来实现</p> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <ul><li><p>autoplay</p> <p>布尔属性；指定后，视频会马上自动开始播放，不会停下来等着数据载入结束。</p></li> <li><p>controls</p> <p>加上这个属性，浏览器会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。</p></li> <li><p>currentTime</p> <p>读取CurentTime返回一个双精度浮点值，指示以秒为单位的媒体的当前播放位置。</p> <p>如果video尚未开始播放，则会在开始播放后返回偏移量。通过CurentTime将当前播放位置设置为给定时间，会在加载媒体时将媒体查找到该位置（从指定的位置开始播放）。</p> <p>媒体正在播放的情况下，如果媒体缓冲区的数据已经过期（视频已经播放完），则 user agent有可能无法正常拿到数据。有些媒体可能有一个不以0秒开始的媒体时间线（不是从头开始播放的），因此应该将currentTime的时间设置在其数据失效之前。</p></li> <li><p>duration 只读</p> <p>一个双精度浮点值，它指示媒体的持续时间(总长度)，以秒为单位，在媒体的时间线上。如果元素上没有媒体，或者媒体无效，则返回的值为NaN。</p> <p>如果媒体没有已知终点(例如时间未知的实时流、网络广播、来自WebRTC的媒体等等)，那么这个值就是Infinity。</p></li> <li><p>muted</p> <p>布尔属性，指明了视频里的音频的默认设置。设置后，音频会初始化为静音。默认值是false,意味着视频播放的时候音频也会播放 。</p></li> <li><p>height</p> <p>视频展示区域的高度，单位是CSS像素。</p></li> <li><p>preload</p> <p>预加载相关</p></li></ul> <h3 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h3> <table><thead><tr><th>事件名</th> <th>描述</th></tr></thead> <tbody><tr><td>durationchange</td> <td>duration 属性的值改变时触发。</td></tr> <tr><td>ended</td> <td>视频停止，因为media已经到达结束点。</td></tr> <tr><td>loadeddata</td> <td>media中的首帧已经加载。</td></tr></tbody></table> <blockquote><p>MDN上没有看到seek事件</p></blockquote> <h2 id="audio-元素"><a href="#audio-元素" class="header-anchor">#</a> audio 元素</h2> <p>audio 元素用于在文档中嵌入音频内容。</p> <p>audio 元素可以包含一个或多个音频资源， 这些音频资源可以使用 src 属性或者source 元素来进行描述：浏览器将会选择最合适的一个来使用。也可以使用 MediaStream 将这个元素用于流式媒体。</p> <p>与 img 元素类似，在 src 属性中添加了嵌入媒体的路径；也可以使用其他属性来规定一些功能，例如是否自动播放、是否循环播放、是否显示浏览器的默认音频空间等等。</p> <p>在浏览器不支持该元素时，会显示 audio 标签之间的内容作为回退。</p> <h3 id="属性-2"><a href="#属性-2" class="header-anchor">#</a> 属性</h3> <ul><li><p>autoplay</p> <p>布尔值属性；声明该属性，音频会尽快自动播放，不会等待整个音频文件下载完成。</p> <blockquote><p>自动播放音频（或有声视频）可能会破坏用户体验，所以应该尽可能避免。</p></blockquote></li> <li><p>controls</p> <p>如果声明了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。</p></li> <li><p>crossorigin</p> <p>表示音频资源是否可以通过CORS加载</p></li> <li><p>currentTime</p> <p>读取 currentTime 属性将返回一个双精度浮点值，用以标明以秒为单位的当前音频的播放位置。</p> <p>如果音频的元数据暂时无法访问——这意味着你无法的知道媒体的开始或持续时间。这时，currentTime 相对应的，能够被用于改变重播的时间。</p> <p>否则，设置 currentTime 将设置当前的播放位置，并且会自动搜寻到媒体的那个位置，如果媒体目前已经被加载的话。</p> <p>如果音频是以流的形式加载的，并且数据超出了媒体的缓冲区（buffer），user agent 可能无法获取资源的某些部分。另一些音频的时间轴可能并非从 0 秒开始，所以设置 currentTime 到一个开始时间之前的时间可能会失败。举个例子，如果音频媒体的时间轴从 12 小时开始，把 currentTime 设置到 3600 将会尝试把当前播放位置设置到媒体的开始位置之前，从而导致错误。getStartDate() 方法能够用于确定媒体时间轴的开始位置。</p></li> <li><p>duration 只读</p> <p>这是一个双精度浮点数，指明了音频在时间轴中的持续时间（总长度），以秒为单位。</p> <p>如果元素上没有媒体，或者媒体是不可用的，那么会返回 NaN。如果媒体找不到确切的结尾（比如不确定长度的直播流，网络电台，或者是通过 WebRTC 连接的流），那么这个值将返回 +Infinity。</p></li> <li><p>muted</p> <p>表示是否静音的布尔值。默认值为 false，表示有声音。</p></li> <li><p>src</p> <p>嵌入的音频的URL。 该URL应遵从 HTTP access controls. 这是一个可选属性；可以在audio元素中使用 source 元素来替代该属性指定嵌入的音频</p></li></ul> <h3 id="事件-2"><a href="#事件-2" class="header-anchor">#</a> 事件</h3> <table><thead><tr><th>事件名</th> <th>描述</th></tr></thead> <tbody><tr><td>pause</td> <td>播放暂停。</td></tr> <tr><td>play</td> <td>播放开始。</td></tr> <tr><td>playing</td> <td>因为缺少数据而暂停或延迟的状态结束，播放准备开始。</td></tr> <tr><td>ratechange</td> <td>播放速度变化。</td></tr> <tr><td>seeked</td> <td>一次获取 操作结束。</td></tr> <tr><td>seeking</td> <td>一次获取 操作开始。</td></tr> <tr><td>durationchange</td> <td>duration 属性发生了变化。</td></tr></tbody></table> <h2 id="html5存储方式（客户端）"><a href="#html5存储方式（客户端）" class="header-anchor">#</a> HTML5存储方式（客户端）</h2> <p>在客户端存储数据，可以在需要的时候重新取得需要的数据。这有很多明显的用处，比如：</p> <ul><li>个性化网站偏好（比如显示一个用户选择的窗口小部件，颜色主题，或者字体）。</li> <li>保存之前的站点行为 (比如从先前的session中获取购物车中的内容， 记住用户是否之前已经登陆过)。</li> <li>本地化保存数据和静态资源可以使一个站点更快（至少让资源变少）的下载， 甚至可以在网络失去链接的时候变得暂时可用。</li> <li>保存web已经生产的文档可以在离线状态下访问。</li></ul> <p>通常客户端和服务端存储是结合在一起使用的。例如，你可以从数据库中下载一个由网络游戏或音乐播放器应用程序使用的音乐文件，将它们存储在客户端数据库中，并按需要播放它们。用户只需下载音乐文件一次——在随后的访问中，它们将从数据库中检索。</p> <h2 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h2> <p>Cookie 是服务器保存在浏览器的一小段文本信息，一般大小不能超过4KB。</p> <p>浏览器每次向服务器发出请求，就会自动附上cookie。</p> <p>Cookie 主要保存状态信息，以下是一些主要用途。</p> <ul><li>对话（session）管理：保存登录、购物车等需要记录的信息。</li> <li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li> <li>追踪用户：记录和分析用户行为。</li></ul> <p>Cookie 不是一种理想的客户端储存机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。</p> <p>客户端储存应该使用 Web storage API 和 IndexedDB。</p> <p>只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p> <p>用户可以设置浏览器不接受 Cookie，也可以设置不向服务器发送 Cookie。</p> <p>window.navigator.cookieEnabled属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p> <h3 id="元数据"><a href="#元数据" class="header-anchor">#</a> 元数据</h3> <p>每个 Cookie 都有以下几方面的元数据。</p> <ul><li>Cookie 的名字</li> <li>Cookie 的值（真正的数据写在这里面）</li> <li>到期时间（超过这个时间会失效）</li> <li>所属域名（默认为当前域名）</li> <li>生效的路径（默认为当前网址）</li></ul> <h3 id="document-cookie"><a href="#document-cookie" class="header-anchor">#</a> document.cookie</h3> <p>document.cookie属性用于读写当前网页的 Cookie。</p> <p>读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有HttpOnly属性。</p> <blockquote><p>cookie之间使用分号分隔</p></blockquote> <p>document.cookie属性是可写的，可以通过它为当前网站添加 Cookie。</p> <p>写入的时候，Cookie 的值必须写成key=value的形式。注意，等号两边不能有空格。</p> <p>另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用encodeURIComponent方法达到。</p> <p><strong>document.cookie一次只能写入一个 Cookie。</strong></p> <p>可以同时设置属性，各个属性要符合相应格式</p> <blockquote><p>path属性必须为绝对路径，默认为当前路径, domain属性值必须是当前发送 Cookie 的域名的一部分</p></blockquote> <blockquote><p>一串字符串</p></blockquote> <h3 id="大小"><a href="#大小" class="header-anchor">#</a> 大小</h3> <p>不同浏览器对 Cookie 数量和大小的限制，是不一样的。</p> <p>一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。</p> <p>超过限制以后，Cookie 将被忽略，不会被设置。</p> <h3 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h3> <p>Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。</p> <p>它的值是 UTC 格式，可以使用Date.prototype.toUTCString()进行格式转换。</p> <p>如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除</p> <h3 id="max-age"><a href="#max-age" class="header-anchor">#</a> Max-Age</h3> <p>Max-Age属性指定从现在开始 Cookie 存在的秒数</p> <p><strong>如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。</strong></p> <blockquote><p>expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替</p></blockquote> <p>如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，</p> <p>即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p> <h3 id="domain，path"><a href="#domain，path" class="header-anchor">#</a> Domain，Path</h3> <p>Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。</p> <p>如果没有指定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。</p> <blockquote><p>比如，example.com不设置 Cookie 的domain属性，那么sub.example.com将不会附带这个 Cookie。</p></blockquote> <p>如果指定了domain属性，那么子域名也会附带这个 Cookie。</p> <p>如果服务器指定的域名不属于当前域名，浏览器会拒绝这个 Cookie。</p> <p>Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。</p> <p>只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。</p> <blockquote><p>比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。</p></blockquote> <h3 id="secure，httponly"><a href="#secure，httponly" class="header-anchor">#</a> Secure，HttpOnly</h3> <p>Secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。</p> <p>另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的Secure属性。</p> <p>该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p> <p><strong>HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到</strong></p> <p><strong>在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。</strong></p> <p>主要是document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。</p> <p>这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p> <p>通过 JavaScript 创建的 Cookie 不能包含 HttpOnly 标志。</p> <h3 id="samsite属性"><a href="#samsite属性" class="header-anchor">#</a> samsite属性</h3> <p>Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值。</p> <ul><li><p>Strict</p> <p>Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。</p> <p>换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p></li> <li><p>Lax</p> <p>Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p> <ul><li>链接</li> <li>预加载请求, <code>link rel=&quot;prerender&quot;</code></li> <li>GET 表单, <code>form method = 'GET'</code></li></ul></li> <li><p>None</p> <p>这时，网站可以选择显式关闭SameSite属性，将其设为None。</p> <p>不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p></li></ul> <h3 id="如何让一个cookie失效、如何让一个cookie销毁"><a href="#如何让一个cookie失效、如何让一个cookie销毁" class="header-anchor">#</a> 如何让一个cookie失效、如何让一个cookie销毁</h3> <p><strong>删除一个现存 Cookie 的唯一方法，是设置它的expires属性为一个过去的日期。</strong></p> <blockquote><p>过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p></blockquote> <h3 id="cookie会有跨域问题吗？子域能获取到父域的cookie吗？"><a href="#cookie会有跨域问题吗？子域能获取到父域的cookie吗？" class="header-anchor">#</a> cookie会有跨域问题吗？子域能获取到父域的cookie吗？</h3> <p>存在跨域问题，在不同的域名中，访问的cookie的时候，只能访问对应的域名的cookie。</p> <p>假设domain 为 .study.com, 那么子域名 A.study.com 以及B.study.com 都能获取到这个 Cookie。</p> <h3 id="cookie维持登录态是怎么做到的"><a href="#cookie维持登录态是怎么做到的" class="header-anchor">#</a> cookie维持登录态是怎么做到的</h3> <p>http是无状态的网络协议,请求响应而后断开TCP连接，下一次连接与上一次无关。</p> <p>为了识别不同的请求是否来自同一客户，引用HTTP会话机制,而维持这个会话则主要靠session和cookie。</p> <p>简单来说，cookie机制采用的是在客户端保持状态的方案（session机制采用的是在服务器端保持状态的方案。）</p> <p>使用cookie在客户端保存用户信息（不建议保存用户密码，即使进行加密）</p> <h3 id="每次请求都会带cookie吗？什么时候会带"><a href="#每次请求都会带cookie吗？什么时候会带" class="header-anchor">#</a> 每次请求都会带cookie吗？什么时候会带</h3> <p>当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。</p> <h3 id="cookie保存在哪里"><a href="#cookie保存在哪里" class="header-anchor">#</a> cookie保存在哪里</h3> <p>Cookie就是存储在客户端的一小段数据，它可以存在硬盘中（永久Cookie），也可以存在内存中（临时Cookie）</p> <h3 id="能不能在浏览器端修改cookie"><a href="#能不能在浏览器端修改cookie" class="header-anchor">#</a> 能不能在浏览器端修改cookie</h3> <p>可以，通过document.cookie修改，客户端可以设置cookie 的下列选项：</p> <ul><li>expires</li> <li>domain</li> <li>path</li> <li>secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功）</li></ul> <p>设置多个cookie分开写document.cookie</p> <h3 id="共享cookie"><a href="#共享cookie" class="header-anchor">#</a> 共享cookie</h3> <ul><li>中间域名，浏览器的同源政策规定，两个网址只要域名相同，就可以共享 Cookie，<strong>注意，这里不要求协议相同</strong></li> <li>cors</li></ul> <h3 id="cookie-与-http-协议"><a href="#cookie-与-http-协议" class="header-anchor">#</a> Cookie 与 HTTP 协议</h3> <p>Cookie 由 HTTP 协议生成，也主要是供 HTTP 协议使用。</p> <h4 id="cookie-的生成"><a href="#cookie-的生成" class="header-anchor">#</a> Cookie 的生成</h4> <p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。</p> <p>HTTP 回应可以包含多个Set-Cookie字段，即在浏览器生成多个 Cookie</p> <p>除了 Cookie 的值，Set-Cookie字段还可以附加 Cookie 的属性。</p> <p>一个Set-Cookie字段里面，可以同时包括多个属性，没有次序的要求。</p> <p>如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的key、domain、path和secure都匹配。</p> <p><strong>允许存在同名的cookie</strong></p> <h4 id="cookie发送"><a href="#cookie发送" class="header-anchor">#</a> cookie发送</h4> <p>使用 HTTP 头信息的Cookie字段。</p> <p>Cookie字段可以包含多个 Cookie，使用分号（;）分隔。</p> <p>服务器收到浏览器发来的 Cookie 时，</p> <p>有两点是无法知道的。</p> <ul><li>Cookie 的各种属性，比如何时过期。</li> <li>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。</li></ul> <blockquote><p>因为不包含这些信息</p></blockquote> <h2 id="storage接口"><a href="#storage接口" class="header-anchor">#</a> Storage接口</h2> <p>Web Storage 中的数据仅仅存储在本地，不会与服务器发生任何交互行为，不存在网络带宽的占用问题。</p> <h3 id="storage-length"><a href="#storage-length" class="header-anchor">#</a> Storage.length</h3> <p>返回保存的数据项个数。</p> <h3 id="storage-setitem"><a href="#storage-setitem" class="header-anchor">#</a> Storage.setItem()</h3> <p>Storage.setItem()方法用于存入数据。</p> <p>它接受两个参数，第一个是键名，第二个是保存的数据。</p> <p>如果键名已经存在，该方法会更新已有的键值。</p> <p>该方法没有返回值。</p> <p><strong>Storage.setItem()两个参数都是字符串。如果不是字符串，会自动转成字符串，再存入浏览器。</strong></p> <p>如果储存空间已满，该方法会抛错。</p> <p>写入不一定要用这个方法，直接赋值也是可以的。</p> <h3 id="storage-getitem"><a href="#storage-getitem" class="header-anchor">#</a> Storage.getItem()</h3> <p>Storage.getItem()方法用于读取数据。</p> <p>它只有一个参数，就是键名。如果键名不存在，该方法返回null。</p> <h3 id="storage-removeitem"><a href="#storage-removeitem" class="header-anchor">#</a> Storage.removeItem()</h3> <p>Storage.removeItem()方法用于清除某个键名对应的键值。</p> <p><strong>它接受键名作为参数，如果键名不存在，该方法不会做任何事情。</strong></p> <h3 id="storage-clear"><a href="#storage-clear" class="header-anchor">#</a> Storage.clear()</h3> <p>Storage.clear()方法用于清除所有保存的数据。该方法的返回值是undefined。</p> <h3 id="storage-key"><a href="#storage-key" class="header-anchor">#</a> Storage.key()</h3> <p>Storage.key()接受一个整数作为参数（从零开始），返回该位置对应的键值。</p> <h3 id="事件-3"><a href="#事件-3" class="header-anchor">#</a> 事件</h3> <p>Storage 接口储存的数据发生变化时，会触发 storage 事件，可以指定这个事件的监听函数。</p> <p><code>window.addEventListener('storage', onStorageChange);</code></p> <p>监听函数接受一个event实例对象作为参数。这个实例对象继承了 StorageEvent 接口，</p> <p>有几个特有的属性，都是只读属性。</p> <ul><li><p>StorageEvent.key：</p> <p>字符串，表示发生变动的键名。如果 storage 事件是由clear()方法引起，该属性返回null。</p></li> <li><p>StorageEvent.newValue：</p> <p>字符串，表示新的键值。如果 storage 事件是由clear()方法或删除该键值对引发的，该属性返回null。</p></li> <li><p>StorageEvent.oldValue：</p> <p>字符串，表示旧的键值。如果该键值对是新增的，该属性返回null。</p></li> <li><p>StorageEvent.storageArea：</p> <p>对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。</p></li> <li><p>StorageEvent.url：</p> <p>字符串，表示原始触发 storage 事件的那个网页的网址。</p></li></ul> <p><strong>该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。</strong></p> <p>也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。</p> <p>比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。</p> <p><strong>可以通过这种机制，实现多个窗口之间的通信。</strong></p> <h2 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> sessionStorage</h2> <p>sessionStorage保存的数据用于浏览器的一次会话（session），<strong>当会话结束（通常是窗口关闭），数据被清空</strong>；</p> <p>保存的数据都以“键值对”的形式存在。所有的数据都是以文本格式保存。</p> <p>受同源策略限制</p> <p>它与 localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除。</p> <p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</p> <p><strong>打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。</strong></p> <p>关闭对应浏览器窗口（Window）/ tab，会清除对应的sessionStorage。</p> <p>存储在sessionStorage或localStorage中的数据特定于页面的协议。也就是说http://example.com 与 https://example.com的sessionStorage相互隔离。</p> <h3 id="存放在哪"><a href="#存放在哪" class="header-anchor">#</a> 存放在哪</h3> <p>储存在客户端</p> <h3 id="什么情况下可以共享sessionstroge？是根据什么判断是可以共享的？"><a href="#什么情况下可以共享sessionstroge？是根据什么判断是可以共享的？" class="header-anchor">#</a> 什么情况下可以共享sessionStroge？是根据什么判断是可以共享的？</h3> <p>通过跳转的页面可以继承sessionStorage值，跳转有多种方式：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>同源页面<span class="token punctuation">&quot;</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>_self<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>同源页面<span class="token punctuation">&quot;</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>_blank<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'同源页面'</span>      <span class="token comment">//原窗口</span>
window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'同源页面'</span><span class="token punctuation">)</span>   <span class="token comment">//原窗口</span>
window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'同源页面'</span><span class="token punctuation">)</span>       <span class="token comment">//新开窗口</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token operator">:</span> <span class="token string">'同源页面'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment">//通过路由跳转共享值</span>
</code></pre></div><p>所以还是得通过cookie或localStorage实现（监听storage事件）</p> <h2 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> localStorage</h2> <p>localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</p> <p>除了保存期限的长短不同，与sessionStorage的其他方面都一致。</p> <p>保存的数据都以“键值对”的形式存在。所有的数据都是以文本格式保存。</p> <p>受同源策略限制</p> <h3 id="存放在哪-2"><a href="#存放在哪-2" class="header-anchor">#</a> 存放在哪</h3> <p>储存在客户端</p> <h3 id="localstorage的api有哪些"><a href="#localstorage的api有哪些" class="header-anchor">#</a> localstorage的api有哪些</h3> <ul><li>getItem</li> <li>setItem</li> <li>removeItem</li> <li>key</li></ul> <h3 id="localstorage-中-getitem-获取的数据格式是什么？"><a href="#localstorage-中-getitem-获取的数据格式是什么？" class="header-anchor">#</a> localStorage 中 getItem 获取的数据格式是什么？⭐️</h3> <p>字符串，setItem的时候会自动转换字符串的步骤（如果参数、存储数据不是字符串的话）</p> <h3 id="localstorage怎么跨域共享"><a href="#localstorage怎么跨域共享" class="header-anchor">#</a> localstorage怎么跨域共享</h3> <p>postMessage + iframe</p> <p>postMessage(data,origin)方法允许来自不同源的脚本采用异步方式进行通信，可以实现跨文本档、多窗口、跨域消息传递。</p> <h3 id="如何写一个会过期的localstorage"><a href="#如何写一个会过期的localstorage" class="header-anchor">#</a> 如何写一个会过期的localStorage</h3> <p>给localStorage加上一个有效的时间，惰性删除。</p> <h3 id="localstorge的上限是多少？"><a href="#localstorge的上限是多少？" class="header-anchor">#</a> localStorge的上限是多少？</h3> <p>各浏览器支持的 localStorage 和 sessionStorage 容量上限不同，一般是单个域名5MB左右</p> <blockquote><p>length返回数据项个数、setItem在容量满时会抛出错误</p></blockquote> <p>MDN上相关页面有个链接可以进行测试</p> <h3 id="如何知道localstorage目前的剩余内存量？"><a href="#如何知道localstorage目前的剩余内存量？" class="header-anchor">#</a> 如何知道localStorage目前的剩余内存量？</h3> <p>由于localStorage存储的数据项是字符串，以通过取出所有的localStorage的内容，计算已用容量大小（即字符串长度）</p> <p>然后通过清空localStorage，往里添加数据直至饱和，可以计算最大上限，从而可以计算剩余的储存量</p> <h3 id="不同页面的localstroge和sessionsorge是否可以共享？"><a href="#不同页面的localstroge和sessionsorge是否可以共享？" class="header-anchor">#</a> 不同页面的localStroge和sessionSorge是否可以共享？</h3> <p>不同浏览器无法共享localStorage或sessionStorage中的信息。</p> <p>相同浏览器下，并且是同源窗口（协议、域名、端口一致），不同页面可以共享localStorage值，但是不同页面或标签页间无法共享sessionStorage的信息</p> <blockquote><p>这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p></blockquote> <p>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取或修改到同一份localStorage的数据。</p> <p>sessionStorage比localStorage更严格，除了协议、主机名、端口外，还要求在同一窗口下</p> <h2 id="cookie-与-webstorage-的区别"><a href="#cookie-与-webstorage-的区别" class="header-anchor">#</a> Cookie 与 webStorage 的区别</h2> <table><thead><tr><th></th> <th>Cookie</th> <th>sessionStorage</th> <th>localStorage</th></tr></thead> <tbody><tr><td>有效期</td> <td>默认会话（关闭浏览器后消失，也可设置时间）</td> <td>会话（关闭浏览器一会后消失）</td> <td>始终有效</td></tr> <tr><td>作用域</td> <td>同站（端口号和协议可以不同，后面会说明）</td> <td>当前页面</td> <td>同源</td></tr> <tr><td>大小</td> <td>4kb 左右（各浏览器不同）</td> <td>5mb（各浏览器不同）</td> <td>5mb（各浏览器不同）</td></tr></tbody></table> <h2 id="indexdb"><a href="#indexdb" class="header-anchor">#</a> indexDB</h2> <p>现有的浏览器数据储存方案，都不适合储存大量数据：</p> <p>Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；</p> <p>LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。</p> <p>这就是 IndexedDB 诞生的背景。</p> <p>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。</p> <p>IndexedDB 允许储存大量数据，提供查找接口，还能建立索引</p> <p><strong>IndexedDB 不属于关系型数据库（不支持 SQL 查询语句）</strong></p> <p>IndexedDB 具有以下特点。</p> <ul><li><p>键值对储存。</p> <p>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。</p> <p>对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p></li> <li><p>异步。</p> <p>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。</p> <p>异步设计是为了防止大量数据的读写，拖慢网页的表现。</p></li> <li><p>支持事务。</p> <p>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p></li> <li><p>同源限制。</p> <p>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p></li> <li><p>储存空间大。</p> <p>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p></li> <li><p>支持二进制储存。</p> <p>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p></li></ul> <p>IDBTransaction 对象用来异步操作数据库事务，所有的读写操作都要通过这个对象进行。</p> <p>不同之处</p> <ul><li><p>更新数据要使用IDBObject.put()方法。不是update</p></li> <li><p>IDBObjectStore.keyPath：返回当前对象仓库的主键。不是key</p></li></ul> <p><a href="https://wangdoc.com/javascript/bom/indexeddb.html" target="_blank" rel="noopener noreferrer">&quot;详细介绍&quot;<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="离线缓存"><a href="#离线缓存" class="header-anchor">#</a> 离线缓存</h2> <ul><li>application cache（已经从web标准删除，不推荐使用）</li> <li>service worker</li></ul> <h2 id="application-cache（已经从web标准删除）"><a href="#application-cache（已经从web标准删除）" class="header-anchor">#</a> application cache（已经从web标准删除）</h2> <p>随着移动端H5的流行，HTML5 提供一种 应用程序缓存（Cache Manifest） 机制，使得基于web的应用程序可以离线运行。开发人员需要为浏览器指定需要缓存的文件，在客户端离线的情况下，即使刷新页面，相关资源也可以正常加载和使用。</p> <p>离线缓存具有以下优势：</p> <ul><li>离线浏览: 用户可以在离线状态下浏览网站内容。</li> <li>更快的速度: 因为数据被存储在本地，所以速度会更快。</li> <li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li></ul> <p>要实现离线存储，需要几个简单的设置步骤：</p> <ol><li>在服务器上添加manifest文件对应扩展名的MIME-TYPE支持，让服务器能够识别该manifest文件。manifest文件可以是任意扩展名，但必须以正确的 MIME 类型提供，默认扩展名为.manifest</li> <li>创建一个后缀名为.manifest 的文件，把需要缓存的文件按格式写在里面，并用注释行标注版本</li> <li>给 html 标签添加 manifest 属性，并引用 manifest 文件</li></ol> <h3 id="使用及更新"><a href="#使用及更新" class="header-anchor">#</a> 使用及更新</h3> <ol><li>第一次访问HTML页面（引用了manifest文件）时，发送请求，将获取到的 manifest 文件缓存在本地，并获取文件中需要缓存的资源进行缓存。</li> <li>下次访问时，无论客户端是否离线，都会直接从缓存中获取入口页 HTML 和其他缓存的文件进行展示。与此同时，如果在线，浏览器会异步发送请求到服务器请求manifest文件，并与缓存的manifest副本进行比对，如果发现版本不一致，会陆续发送请求重新拉取入口文件HTML和需要缓存的文件并更新本地缓存副本</li></ol> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ul><li>更新的资源，需要二次刷新才会被页面采用（在有网络的时候，浏览器也会优先使用已离线存储的文件）</li> <li>不支持增量更新，只有manifest发生变化，所有资源全部重新下载一次</li> <li>缺乏足够容错机制，当清单中任意资源文件出现加载异常，都会导致整个manifest策略运行异常</li></ul> <h2 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h2> <p>WebSocket是一种通信协议，可在单个TCP连接上进行全双工通信</p> <ul><li>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</li> <li>建立在 TCP 协议之上，服务器端的实现比较容易。</li> <li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li> <li>数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。（HTTP每次都需要携带完整头部。）</li> <li>没有同源限制，客户端可以与任意服务器通信。</li> <li>协议标识符是ws（如果加密，则为wss，与https加密相同，也是TLS），服务器网址就是 URL。</li></ul> <p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p> <h3 id="websocket连接过程"><a href="#websocket连接过程" class="header-anchor">#</a> WebSocket连接过程</h3> <p>客户端发起HTTP握手，告诉服务端进行WebSocket协议通讯，并告知WebSocket协议版本。服务端确认协议版本，升级为WebSocket协议。之后如果有数据需要推送，会主动推送给客户端。</p> <p>连接开始时，客户端使用HTTP协议和服务端升级协议，升级完成后，后续数据交换遵循WebSocket协议。</p> <blockquote><p>WebSocket的握手被翻译成HTTP的升级请求。通过 HTTP/1.1 协议的101状态码进行握手。</p></blockquote> <h3 id="websocket-readystate"><a href="#websocket-readystate" class="header-anchor">#</a> webSocket.readyState</h3> <p>readyState属性返回实例对象的当前状态，共有四种。</p> <ul><li>CONNECTING：值为0，表示正在连接。</li> <li>OPEN：值为1，表示连接成功，可以通信了。</li> <li>CLOSING：值为2，表示连接正在关闭。</li> <li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul> <h3 id="属性和方法"><a href="#属性和方法" class="header-anchor">#</a> 属性和方法</h3> <table><thead><tr><th>属性或方法</th> <th>描述</th></tr></thead> <tbody><tr><td>webSocket.onopen</td> <td>实例对象的onopen属性，用于指定连接成功后的回调函数。</td></tr> <tr><td>webSocket.onclose</td> <td>实例对象的onclose属性，用于指定连接关闭后的回调函数。</td></tr> <tr><td>webSocket.onmessage</td> <td>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</td></tr> <tr><td>webSocket.send()</td> <td>实例对象的send()方法用于向服务器发送数据。</td></tr> <tr><td>webSocket.bufferedAmount</td> <td>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</td></tr> <tr><td>webSocket.onerror</td> <td>实例对象的onerror属性，用于指定报错时的回调函数。</td></tr></tbody></table> <h3 id="与http的区别"><a href="#与http的区别" class="header-anchor">#</a> 与http的区别</h3> <p>http 协议通信只能由客户端发起。（当然2.0加入了服务端推送）</p> <p>http 连接的时间比较短，而websocket可以持续很长时间</p> <div class="custom-block tip"><p class="custom-block-title">说明</p> <p>HTTP1.1的连接默认使用长连接（persistent connection），</p> <p>即在一定的期限内保持链接，客户端会需要在短时间内向服务端请求大量的资源，保持TCP连接不断开。</p> <blockquote><p>客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p></blockquote> <p>在一个TCP连接上可以传输多个Request/Response消息对，所以本质上还是Request/Response消息对，仍然会造成资源的浪费、实时性不强等问题。</p> <p>只需建立一次Request/Response消息对，之后都是TCP连接，避免了需要多次建立Request/Response消息对而产生的冗余头部信息。</p></div> <h3 id="与轮询的区别"><a href="#与轮询的区别" class="header-anchor">#</a> 与轮询的区别</h3> <ul><li><p>轮询：就是客户端每隔一段时间就向服务端询问是否有新数据</p></li> <li><p>长轮询：当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。</p></li></ul> <p>长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p> <p>WebSocket协议，能更好的节省服务器资源和带宽（用于协议控制的数据包头部相对较小），并且能够更实时地进行通讯。(协议是全双工的)</p> <h3 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h3> <p>WebSocket是一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。</p> <p>它与HTTP一样通过已建立的TCP连接来传输数据</p> <h3 id="websocket里面用的协议"><a href="#websocket里面用的协议" class="header-anchor">#</a> websocket里面用的协议</h3> <ul><li>ip</li> <li>tcp</li> <li>http</li> <li>tls</li></ul> <h3 id="常用的api"><a href="#常用的api" class="header-anchor">#</a> 常用的api</h3> <ul><li>onopen</li> <li>onclose</li> <li>onmesssage</li> <li>onerror</li></ul> <h3 id="常用的websocket状态码有哪些"><a href="#常用的websocket状态码有哪些" class="header-anchor">#</a> 常用的websocket状态码有哪些</h3> <table><thead><tr><th>状态码</th> <th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>1000</td> <td>CLOSE_NORMAL</td> <td>正常关闭; 无论为何目的而创建, 该链接都已成功完成任务.</td></tr> <tr><td>1001</td> <td>CLOSE_GOING_AWAY</td> <td>终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开.</td></tr> <tr><td>1002</td> <td>CLOSE_PROTOCOL_ERROR</td> <td>由于协议错误而中断连接.</td></tr> <tr><td>1003</td> <td>CLOSE_UNSUPPORTED</td> <td>由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据).</td></tr></tbody></table> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent" target="_blank" rel="noopener noreferrer">websocket状态码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="web-worker"><a href="#web-worker" class="header-anchor">#</a> Web Worker⭐️</h2> <p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。</p> <p>在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。</p> <p>等到 Worker 线程完成计算任务，再把结果返回给主线程。</p> <p>这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p> <p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。</p> <p>这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p> <h3 id="使用注意点。"><a href="#使用注意点。" class="header-anchor">#</a> 使用注意点。</h3> <ul><li><p>同源限制</p> <p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p></li> <li><p>DOM 限制</p> <p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。</p> <p>但是，Worker 线程可以使用navigator对象和location对象。</p></li> <li><p>全局对象限制</p> <p>Worker 的全局对象WorkerGlobalScope，不同于网页的全局对象Window，很多接口拿不到。</p> <p>比如，理论上 Worker 线程不能使用console.log，因为标准里面没有提到 Worker 的全局对象存在console接口，只定义了Navigator接口和Location接口。</p> <p>不过，浏览器实际上支持 Worker 线程使用console.log，保险的做法还是不使用这个方法。</p></li> <li><p>通信联系</p> <p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p></li> <li><p>脚本限制</p> <p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p></li> <li><p>文件限制</p> <p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p></li></ul> <h3 id="主线程"><a href="#主线程" class="header-anchor">#</a> 主线程</h3> <p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。</p> <p><code>var worker = new Worker('work.js');</code></p> <p>Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。</p> <p>由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p> <p>然后，主线程调用worker.postMessage()方法，向 Worker 发消息。</p> <p>worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p> <p>接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p> <p>Worker 完成任务以后，主线程就可以把它关掉。</p> <p><code>worker.terminate();</code></p> <h3 id="worker-线程"><a href="#worker-线程" class="header-anchor">#</a> Worker 线程</h3> <p>Worker 线程内部需要有一个监听函数，监听message事件。</p> <p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。</p> <blockquote><p>elf代表子线程自身，即子线程的全局对象，等同于this</p></blockquote> <p>监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p> <h3 id="worker-加载脚本"><a href="#worker-加载脚本" class="header-anchor">#</a> Worker 加载脚本</h3> <p>Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。</p> <p>可以加载多个脚本</p> <h3 id="错误处理"><a href="#错误处理" class="header-anchor">#</a> 错误处理</h3> <p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。</p> <h3 id="关闭-worker"><a href="#关闭-worker" class="header-anchor">#</a> 关闭 Worker</h3> <p>使用完毕，为了节省系统资源，必须关闭 Worker。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 主线程</span>
worker<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Worker 线程</span>
self<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="api"><a href="#api" class="header-anchor">#</a> API</h3> <p>浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。</p> <p><code>var myWorker = new Worker(jsUrl, options);</code></p> <p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。</p> <p>第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p> <p>Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。</p> <p>因此定义在window上面的对象和方法不是全部都可以使用。</p> <p>Worker 线程有一些自己的全局属性和方法。</p> <ul><li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li> <li>self.onmessage：指定message事件的监听函数。</li> <li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li> <li>self.close()：关闭 Worker 线程。</li> <li>self.postMessage()：向产生这个 Worker 的线程发送消息。</li> <li>self.importScripts()：加载 JS 脚本。</li></ul> <h3 id="数据通信"><a href="#数据通信" class="header-anchor">#</a> 数据通信</h3> <p>主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。</p> <p>需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。</p> <p>事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p> <p>拷贝方式发送二进制数据，会造成性能问题</p> <h2 id="canvas绘图"><a href="#canvas绘图" class="header-anchor">#</a> canvas绘图</h2> <p>canvas是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素</p> <p>canvas 元素创造了一个固定大小的画布，公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容</p> <blockquote><p>Canvas API主要聚焦于2D图形，而同样使用canvas元素的 WebGL API 则用于绘制硬件加速的2D和3D图形。</p></blockquote> <p><strong>不同于 SVG，canvas 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）</strong></p> <ol><li>Document.getElementById() 方法获取HTML canvas 元素的引用。</li> <li>接着，HTMLCanvasElement.getContext() 方法获取这个元素的context——图像稍后将在此被渲染。
<blockquote><p>这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数，上下文的格式。</p></blockquote></li></ol> <h3 id="绘制矩形"><a href="#绘制矩形" class="header-anchor">#</a> 绘制矩形</h3> <p>canvas提供了三种方法绘制矩形：</p> <ul><li><p>fillRect(x, y, width, height)</p> <p>绘制一个填充的矩形</p></li> <li><p>strokeRect(x, y, width, height)</p> <p>绘制一个矩形的边框</p></li> <li><p>clearRect(x, y, width, height)</p> <p>清除指定矩形区域，让清除部分完全透明。</p></li></ul> <h3 id="上色"><a href="#上色" class="header-anchor">#</a> 上色</h3> <ul><li><p>fillStyle = color</p> <p>设置图形的填充颜色。</p></li> <li><p>strokeStyle = color</p> <p>设置图形轮廓的颜色。</p></li></ul> <h2 id="svg绘图"><a href="#svg绘图" class="header-anchor">#</a> SVG绘图</h2> <p>可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述二维的矢量图形，基于 XML 的标记语言。</p> <p>作为一个基于文本的开放网络标准，SVG能够优雅而简洁地渲染不同大小的图形，并和CSS，DOM，JavaScript和SMIL等其他网络标准无缝衔接。</p> <p>本质上，SVG 相对于图像，就好比 HTML 相对于文本。</p> <p>SVG 图像及其相关行为被定义于 XML 文本文件之中，这意味着可以对它们进行搜索、索引、编写脚本以及压缩。此外，这也意味着可以使用任何文本编辑器和绘图软件来创建和编辑它们。</p> <p>和传统的点阵图像模式，像JPEG和PNG不同，SVG格式提供的是矢量图，这意味着它的图像能够被无限放大而不失真或降低质量，并且可以方便地修改内容。</p> <p>SVG 图像是使用各种元素创建的，这些元素分别应用于矢量图像的结构、绘制与布局。</p> <p>现代浏览器支持在 CSS 样式中使用 SVG 来对HTML内容应用图像效果。</p> <h3 id="使用svg样式"><a href="#使用svg样式" class="header-anchor">#</a> 使用SVG样式</h3> <p>可以在同一文件中使用SVG样式，也可以通过外部样式表引入。有三个属性可以使用： mask, clip-path, 和 filter。</p> <p>注意: 在外部文件引入的SVG必须与原始文件同源 。</p> <h3 id="svg-和-canvas"><a href="#svg-和-canvas" class="header-anchor">#</a> svg 和 canvas</h3> <ul><li>SVG适用于描述XML中的2D图形的语言，Canvas使用javaScript绘制2D图形</li> <li>Canvas是位图；SVG是矢量图</li> <li>Canvas内容不能使用CSS；SVG内容可以使用CSS；</li> <li>Canvas适合图像密集型的游戏，其中的许多对象会被频繁重绘；SVG适合带有大型渲染区域的应用程序（比如谷歌地图）</li></ul> <table><thead><tr><th></th> <th>cnavas绘图</th> <th>svg绘图</th></tr></thead> <tbody><tr><td>类型</td> <td>2D位图（放大会失真）</td> <td>2D矢量图（放大不会失真）</td></tr> <tr><td>绘图方式</td> <td>使用JS代码绘图</td> <td>使用标签绘图</td></tr> <tr><td>事件绑定</td> <td>每个图形不是元素，无法直接绑定事件</td> <td>每个图形都是元素，可以直接绑定事件监听</td></tr> <tr><td>应用场合</td> <td>游戏</td> <td>图标；地图</td></tr></tbody></table> <h2 id="html5和html的区别"><a href="#html5和html的区别" class="header-anchor">#</a> html5和html的区别</h2> <p>:::
不完全总结
:::</p> <ul><li>html5新增了语义化标签：footer 、nav、section…</li> <li>支持本地离线存储。</li> <li>新增了canvas绘图、SVG绘图。</li> <li>新增视频和音频标签。</li> <li>新增表单input类型</li> <li>新增表单元素</li> <li>新增表单属性</li> <li>移除的元素（big，font，center，frame，frameset）</li> <li>DOCTYPE声明不同。<div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!--html5--&gt;</span>
<span class="token doctype">&lt;!DOCTYPE html&gt;</span>

<span class="token comment">&lt;!--html4--&gt;</span>
<span class="token doctype">&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 4.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”&gt;</span>
</code></pre></div><blockquote><p>在HTML4中 !DOCTYPE声明，引用了DTD，因为HTML4是基于SGML的，而HTML5不基于SGML，所以H5不需要引入DTD。</p></blockquote></li></ul> <h2 id="html5自定义属性"><a href="#html5自定义属性" class="header-anchor">#</a> HTML5自定义属性</h2> <p>data-* 全局属性 是一类被称为自定义数据属性的属性，可以在所有 HTML 元素上嵌入自定义数据属性</p> <p>所有这些自定义数据属性都可以通过所属元素的 HTMLElement 接口来访问。HTMLElement.dataset 属性可以访问它们。</p> <p>data属性还可以应用在CSS中，前提是你的浏览器支持after伪类，以及content的attr属性</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token punctuation">{</span>
	<span class="token property">content</span><span class="token punctuation">:</span> <span class="token function">attr</span><span class="token punctuation">(</span>data-attribute<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="获取值"><a href="#获取值" class="header-anchor">#</a> 获取值</h3> <ul><li>getAttribute</li> <li>自定义属性对象的Dataset属性</li></ul> <h2 id="拖放"><a href="#拖放" class="header-anchor">#</a> 拖放</h2> <p>HTML 拖放（Drag and Drop）接口使应用程序能够在浏览器中使用拖放功能。例如，用户可使用鼠标选择可拖拽（draggable）元素，将元素拖拽到可放置（droppable）元素，并释放鼠标按钮以放置这些元素。拖拽操作期间，会有一个可拖拽元素的半透明快照跟随着鼠标指针。</p> <p>一个典型的拖拽操作是这样的：用户选中一个可拖拽的（draggable）元素，并将其拖拽（鼠标不放开）到一个可放置的（droppable）元素，然后释放鼠标。</p> <p>在操作期间，会触发一些事件类型，有一些事件类型可能会被多次触发（比如drag 和 dragover 事件类型）。</p> <h3 id="拖放步骤"><a href="#拖放步骤" class="header-anchor">#</a> 拖放步骤</h3> <p>在一个网页中，有几种特定情况会使用默认拖拽行为，其中包括拖拽选中文本、拖拽图像和拖拽链接。当一个图像或链接被拖拽时，图像或链接的 URL 被设定为拖拽数据。对于其他元素，只当它们是被选中的一部分时，才会触发默认拖拽行为。</p> <ol><li>将想要拖拽的元素的 draggable 属性设置成 draggable=&quot;true&quot;。
<blockquote><p>如果该属性被省略或被设置为 &quot;false&quot;，则该元素将不可拖拽，此时拖拽只会选中文本。</p></blockquote></li> <li>为 dragstart 事件添加一个监听程序。</li> <li>在上一步定义的监听程序中设置拖拽数据。</li></ol> <p>当一个元素被设置成可拖拽时， 元素中的文本和其他子元素不能再以正常的方式（通过鼠标点击和拖拽）被选中。用户必须按住 alt 键，再用鼠标选择文本，或者使用键盘选择。</p> <h3 id="拖放效果"><a href="#拖放效果" class="header-anchor">#</a> 拖放效果</h3> <p>拖拽过程中可能会执行一些操作。</p> <ul><li>copy 操作用来指示被拖拽的数据将从当前位置复制到放置位置。</li> <li>move 操作指示被拖拽的数据会被移动，</li> <li>link 操作表示在源和放置位置之间将会创建某种形式的关系或连接。</li></ul> <h3 id="设定放置目标"><a href="#设定放置目标" class="header-anchor">#</a> 设定放置目标</h3> <p>dragenter 或 dragover 事件的监听程序用于表示有效的放置目标，也就是被拖拽项目可能放置的地方。</p> <p>网页或应用程序的大多数区域都不是放置数据的有效位置。因此，这些事件的默认处理是不允许放置。</p> <p>如果想要允许放置，必须取消 dragenter 和 dragover 事件来阻止默认的处理，调用事件的 preventDefault() 方法来实现这一点。</p> <blockquote><p>可以在属性定义的事件监听程序返回 false</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>通常希望只在某些情况下调用 preventDefault() 方法（如只当拖拽的是链接时）。</p> <p>要做到这一点，调用一个函数以检查条件，并且只在满足条件时取消事件。如果条件未满足，则不取消事件，此时用户释放鼠标按钮不会执行放置。</p></div> <h3 id="执行放置"><a href="#执行放置" class="header-anchor">#</a> 执行放置</h3> <p>如果在有效的放置目标元素（即取消了 dragenter 或 dragover 的元素）上放开鼠标，放置会成功实现，drop 事件在目标元素上被触发。</p> <p>否则，拖拽会被取消，不会触发 drop 事件。</p> <h3 id="完成拖放"><a href="#完成拖放" class="header-anchor">#</a> 完成拖放</h3> <p>一旦拖拽完成，dragend 事件会在拖拽源头（即触发 dragstart 的元素）上发生。</p> <blockquote><p>无论拖拽是成功还是被取消，这个事件都会被触发</p></blockquote> <h3 id="拖放接口"><a href="#拖放接口" class="header-anchor">#</a> 拖放接口</h3> <p>DragEvent 接口有一个构造函数和一个 dataTransfer 属性，dataTransfer 属性是一个 DataTransfer 对象。</p> <p>DataTransfer 对象包含了拖拽事件的状态，例如拖拽事件的类型（如拷贝 copy 或者移动 move），拖拽的数据（一个或者多个项）和每个拖拽项的类型（MIME类型）。 DataTransfer 对象也有向拖拽数据中添加或删除项目的方法。</p> <p>每个 DataTransfer 都包含一个 items 属性，这个属性是 DataTransferItem 对象的 list。一个 DataTransferItem 代表一个拖拽项目，每个项目都有一个 kind 属性（string 或 file） 和一个表示数据项目 MIME 类型的 type 属性。</p> <p>给应用程序添加 HTML 拖放功能，DragEvent 和 DataTransfer 接口应该是唯二需要的接口</p> <h3 id="涉及的事件"><a href="#涉及的事件" class="header-anchor">#</a> 涉及的事件</h3> <p>mousedown mouseover mouseup
ondragstart ondrag ondragend</p> <h3 id="事件一览"><a href="#事件一览" class="header-anchor">#</a> 事件一览</h3> <table><thead><tr><th>事件</th> <th>on回调</th> <th>描述</th></tr></thead> <tbody><tr><td>drag</td> <td>ondrag</td> <td>当拖拽元素或选中的文本时触发。</td></tr> <tr><td>dragstart</td> <td>ondragstart</td> <td>当用户开始拖拽一个元素或选中的文本时触发。</td></tr> <tr><td>dragenter</td> <td>ondragenter</td> <td>当拖拽元素或选中的文本到一个可释放目标时触发。</td></tr> <tr><td>dragover</td> <td>ondragover</td> <td>当元素或选中的文本被拖到一个可释放目标上时触发（每100毫秒触发一次）。</td></tr> <tr><td>dragleave</td> <td>ondragleave</td> <td>当拖拽元素或选中的文本离开一个可释放目标时触发。</td></tr> <tr><td>dragend</td> <td>ondragend</td> <td>当拖拽操作结束时触发 (比如松开鼠标按键或敲“Esc”键).</td></tr> <tr><td>drop</td> <td>ondrop</td> <td>当元素或选中的文本在可释放目标上被释放时触发。</td></tr> <tr><td>dragexit</td> <td>ondragexit</td> <td>当元素变得不再是拖拽操作的选中目标时触发。</td></tr></tbody></table> <h2 id="哪些方式有利于seo"><a href="#哪些方式有利于seo" class="header-anchor">#</a> 哪些方式有利于SEO</h2> <ul><li>语义化标签</li> <li>高质量原创，内容，外链</li> <li>结构层次优化</li></ul> <h2 id="area"><a href="#area" class="header-anchor">#</a> area</h2> <p>HTML area 元素 在图片上定义一个热点区域，可以关联一个超链接。</p> <p>area元素仅在map元素内部使用。</p> <h3 id="coords"><a href="#coords" class="header-anchor">#</a> coords</h3> <p>给热点区域设定具体的坐标值。这个值的数值和意义取决于这个值所描述的形状属性.。</p> <p>对于矩形或长方形, 这个coords 值为两个X,Y对：左上、右下。 对于圆形, 这个值是 x,y,r</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/html/html.html" class="prev">
        基础
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.484f4375.js" defer></script><script src="/assets/js/2.ebbe98b4.js" defer></script><script src="/assets/js/49.6652f2b2.js" defer></script>
  </body>
</html>
