(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{383:function(t,a,s){"use strict";s.r(a);var e=s(9),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("说明")]),t._v(" "),s("p",[t._v("待更新")])]),t._v(" "),s("h2",{attrs:{id:"git"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git"}},[t._v("#")]),t._v(" git")]),t._v(" "),s("p",[t._v("Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。")]),t._v(" "),s("ul",[s("li",[t._v("已修改表示修改了文件，但还没保存到数据库中。")]),t._v(" "),s("li",[t._v("已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。")]),t._v(" "),s("li",[t._v("已提交表示数据已经安全地保存在本地数据库中。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/areas.png",alt:"git 三个阶段"}})]),t._v(" "),s("p",[t._v("工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。")]),t._v(" "),s("p",[t._v("暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。")]),t._v(" "),s("p",[t._v("Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/git.png",alt:"git",title:"git"}})]),t._v(" "),s("p",[t._v("基本的 Git 工作流程如下：")]),t._v(" "),s("ol",[s("li",[t._v("在工作区中修改文件。")]),t._v(" "),s("li",[t._v("将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。")]),t._v(" "),s("li",[t._v("提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://git-scm.com/book/en/v2",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方 git book"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"常用命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("命令")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("$ git init")]),t._v(" "),s("td",[t._v("在当前目录新建一个Git代码库")])]),t._v(" "),s("tr",[s("td",[t._v("$ git commit -m [message]")]),t._v(" "),s("td",[t._v("提交暂存区到仓库区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git commit -a")]),t._v(" "),s("td",[t._v("提交工作区自上次commit之后的变化，直接到仓库区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git commit -v")]),t._v(" "),s("td",[t._v("提交时显示所有diff信息")])]),t._v(" "),s("tr",[s("td",[t._v("$ git commit --amend -m [message]")]),t._v(" "),s("td",[t._v("使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息")])]),t._v(" "),s("tr",[s("td",[t._v("$ git add .")]),t._v(" "),s("td",[t._v("添加当前目录的所有文件到暂存区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git add [file1] [file2] ...")]),t._v(" "),s("td",[t._v("添加指定文件到暂存区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git add [dir]")]),t._v(" "),s("td",[t._v("添加指定目录到暂存区，包括子目录")])]),t._v(" "),s("tr",[s("td",[t._v("$ git rm [file1] [file2] ...")]),t._v(" "),s("td",[t._v("删除工作区文件，并且将这次删除放入暂存区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git rm --cached [file]")]),t._v(" "),s("td",[t._v("停止追踪指定文件，但该文件会保留在工作区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch")]),t._v(" "),s("td",[t._v("列出所有本地分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch -r")]),t._v(" "),s("td",[t._v("列出所有远程分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch -a")]),t._v(" "),s("td",[t._v("列出所有本地分支和远程分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch [branch-name]")]),t._v(" "),s("td",[t._v("新建一个分支，但依然停留在当前分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git checkout -b [branch]")]),t._v(" "),s("td",[t._v("新建一个分支，并切换到该分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git checkout [branch-name]")]),t._v(" "),s("td",[t._v("切换到指定分支，并更新工作区")])]),t._v(" "),s("tr",[s("td",[s("div",{staticStyle:{width:"290pt"}},[t._v("$ git branch --set-upstream [branch] [remote-branch]")])]),t._v(" "),s("td",[t._v("建立追踪关系，在现有分支与指定的远程分支之间")])]),t._v(" "),s("tr",[s("td",[t._v("$ git merge [branch]")]),t._v(" "),s("td",[t._v("合并指定分支到当前分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch -d [branch-name]")]),t._v(" "),s("td",[t._v("删除分支，删除前检查分支状态")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch -D [branch-name]")]),t._v(" "),s("td",[t._v("删除分支，直接删除")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push origin --delete [branch-name]")]),t._v(" "),s("td",[t._v("删除远程分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git branch -dr [remote/branch]")]),t._v(" "),s("td",[t._v("删除远程分支")])]),t._v(" "),s("tr",[s("td",[t._v("$ git tag")]),t._v(" "),s("td",[t._v("列出所有tag")])]),t._v(" "),s("tr",[s("td",[t._v("$ git tag [tag]")]),t._v(" "),s("td",[t._v("新建一个tag在当前commit")])]),t._v(" "),s("tr",[s("td",[t._v("$ git tag [tag] [commit]")]),t._v(" "),s("td",[t._v("新建一个tag在指定commit")])]),t._v(" "),s("tr",[s("td",[t._v("$ git tag -d [tag]")]),t._v(" "),s("td",[t._v("删除本地tag")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push origin :refs/tags/[tagName]")]),t._v(" "),s("td",[t._v("删除远程tag")])]),t._v(" "),s("tr",[s("td",[t._v("$ git show [tag]")]),t._v(" "),s("td",[t._v("查看tag信息")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push [remote] [tag]")]),t._v(" "),s("td",[t._v("提交指定tag")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push [remote] --tags")]),t._v(" "),s("td",[t._v("提交所有tag")])]),t._v(" "),s("tr",[s("td",[t._v("$ git status")]),t._v(" "),s("td",[t._v("显示有变更的文件")])]),t._v(" "),s("tr",[s("td",[t._v("$ git log")]),t._v(" "),s("td",[t._v("显示当前分支的版本历史")])]),t._v(" "),s("tr",[s("td",[t._v("$ git log --stat")]),t._v(" "),s("td",[t._v("显示commit历史，以及每次commit发生变更的文件")])]),t._v(" "),s("tr",[s("td",[t._v("$ git log -S [keyword]")]),t._v(" "),s("td",[t._v("搜索提交历史，根据关键词")])]),t._v(" "),s("tr",[s("td",[t._v("$ git log --follow [file]")]),t._v(" "),s("td",[t._v("显示某个文件的版本历史，包括文件改名")])]),t._v(" "),s("tr",[s("td",[t._v("$ git whatchanged [file]")]),t._v(" "),s("td",[t._v("显示某个文件的版本历史，包括文件改名")])]),t._v(" "),s("tr",[s("td",[t._v("$ git log -p [file]")]),t._v(" "),s("td",[t._v("显示指定文件相关的每一次diff")])]),t._v(" "),s("tr",[s("td",[t._v("$ git log -5 --pretty --oneline")]),t._v(" "),s("td",[t._v("显示过去5次提交")])]),t._v(" "),s("tr",[s("td",[t._v("$ git shortlog -sn")]),t._v(" "),s("td",[t._v("显示所有提交过的用户，按提交次数排序")])]),t._v(" "),s("tr",[s("td",[t._v("$ git blame [file]")]),t._v(" "),s("td",[t._v("显示指定文件是什么人在什么时间修改过")])]),t._v(" "),s("tr",[s("td",[t._v("$ git diff")]),t._v(" "),s("td",[t._v("显示暂存区和工作区的差异")])]),t._v(" "),s("tr",[s("td",[t._v("$ git diff --cached [file]")]),t._v(" "),s("td",[t._v("显示暂存区和上一个commit的差异")])]),t._v(" "),s("tr",[s("td",[t._v("$ git diff HEAD")]),t._v(" "),s("td",[t._v("显示工作区与当前分支最新commit之间的差异")])]),t._v(" "),s("tr",[s("td",[t._v("$ git diff [first-branch]...[second-branch]")]),t._v(" "),s("td",[t._v("显示两次提交之间的差异")])]),t._v(" "),s("tr",[s("td",[t._v('$ git diff --shortstat "@{0 day ago}"')]),t._v(" "),s("td",[t._v("显示今天你写了多少行代码")])]),t._v(" "),s("tr",[s("td",[t._v("$ git fetch [remote]")]),t._v(" "),s("td",[t._v("下载远程仓库的所有变动")])]),t._v(" "),s("tr",[s("td",[t._v("$ git remote -v")]),t._v(" "),s("td",[t._v("显示所有远程仓库")])]),t._v(" "),s("tr",[s("td",[t._v("$ git remote show [remote]")]),t._v(" "),s("td",[t._v("显示某个远程仓库的信息")])]),t._v(" "),s("tr",[s("td",[t._v("$ git remote add [shortname] [url]")]),t._v(" "),s("td",[t._v("增加一个新的远程仓库，并命名")])]),t._v(" "),s("tr",[s("td",[t._v("$ git pull [remote] [branch]")]),t._v(" "),s("td",[t._v("取回远程仓库的变化，并与本地分支合并")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push [remote] [branch]")]),t._v(" "),s("td",[t._v("上传本地指定分支到远程仓库")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push [remote] --force")]),t._v(" "),s("td",[t._v("强行推送当前分支到远程仓库，即使有冲突")])]),t._v(" "),s("tr",[s("td",[t._v("$ git push [remote] --all")]),t._v(" "),s("td",[t._v("推送所有分支到远程仓库")])]),t._v(" "),s("tr",[s("td",[t._v("$ git checkout [file]")]),t._v(" "),s("td",[t._v("恢复暂存区的指定文件到工作区")])]),t._v(" "),s("tr",[s("td",[t._v("$ git reset [file]")]),t._v(" "),s("td",[t._v("重置暂存区的指定文件，与上一次commit保持一致，但工作区不变")])]),t._v(" "),s("tr",[s("td",[t._v("$ git stash")]),t._v(" "),s("td",[t._v("暂时将未提交的变化移除，稍后再移入")])]),t._v(" "),s("tr",[s("td",[t._v("$ git stash pop")]),t._v(" "),s("td",[t._v("暂时将未提交的变化移除，稍后再移入")])])])]),t._v(" "),s("h2",{attrs:{id:"git-add-i"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-add-i"}},[t._v("#")]),t._v(" git add -i")]),t._v(" "),s("p",[t._v("如果运行 git add 时使用 -i 或者 --interactive 选项, Git 将会进入一个交互式终端模式")]),t._v(" "),s("p",[t._v("当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时可以使用")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging",target:"_blank",rel:"noopener noreferrer"}},[t._v("交互式暂存"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"git-grep"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-grep"}},[t._v("#")]),t._v(" git grep")]),t._v(" "),s("p",[t._v("Git 提供了一个 grep 命令，你可以很方便地从提交历史、工作目录、甚至索引中查找一个字符串或者正则表达式。")]),t._v(" "),s("h2",{attrs:{id:"git-merge和git-rebase区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-merge和git-rebase区别"}},[t._v("#")]),t._v(" git merge和git rebase区别")]),t._v(" "),s("p",[t._v("git-merge - Join two or more development histories together")]),t._v(" "),s("p",[t._v("git-rebase - Reapply commits on top of another base tip")]),t._v(" "),s("p",[t._v('rebase的最大好处并不是消除merge，而是避免merge的"交织"。')]),t._v(" "),s("p",[t._v("简单来说，git rebase提取操作有点像git cherry-pick一样，执行rebase后依次将当前的提交cherry-pick到目标分支上，然后将在原始分支上的已提取的commit删除。commit的历史记录变成‘一根单线’")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/3780844738-5cb2a43e39ea9_fix732.png",alt:"初始状态"}})]),t._v(" "),s("p",[t._v("假设现在HEAD在（6.added hello.txt file）处，也就是在master分支最近的一次提交处，此时执行git merge develop, 结果如下图所示。\n"),s("img",{attrs:{src:"/img/1875421923-5cb2a4fa31e20_fix732.png",alt:"git merge"}})]),t._v(" "),s("p",[t._v("工作原理就是：git 会自动根据两个分支的共同祖先即 (3.added merge.txt file)这个 commit 和两个分支的最新提交即 (6.added hello.txt file) 和 (5.added test.txt file) 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即图二的(7.Merge branch ‘develop’)。")]),t._v(" "),s("p",[t._v("这是merge的效果，简单来说就合并两个分支并生成一个新的提交。")]),t._v(" "),s("p",[t._v("此时HEAD在（6.added hello.txt file）处，现在执行git rebase develop,结果如下图所示。\n"),s("img",{attrs:{src:"/img/1020559684-5cb2aad8a3fe2_fix732.png",alt:"git rebase"}})]),t._v(" "),s("p",[t._v("在执行git rebase develop之前，HEAD在（6.added hello.txt file）处，当执行rebase操作时，git 会从两个分支的共同祖先 (3.added merge.txt file)开始提取 当前分支（此时是master分支）上的修改，即 （6.added hello.txt file）这个commit，再将 master 分支指向 目标分支的最新提交（此时是develop分支）即（5.added test.txt file） 处，然后将刚刚提取的修改应用到这个最新提交后面。如果提取的修改有多个（多个分支都有），那git将依次应用到最新的提交后面")]),t._v(" "),s("p",[s("strong",[t._v("如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行rebase")]),t._v("。")]),t._v(" "),s("p",[t._v("有一种观点认为，仓库的提交历史即是记录实际发生过什么。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用 谎言掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。")]),t._v(" "),s("p",[t._v("另一种观点则正好相反，他们认为提交历史是项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。")]),t._v(" "),s("p",[t._v("现在，让我们回到之前的问题上来，到底合并还是变基好？这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。")]),t._v(" "),s("p",[t._v("总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。")]),t._v(" "),s("h2",{attrs:{id:"git-merge"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-merge"}},[t._v("#")]),t._v(" git merge")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("fast-forward")])])]),t._v(" "),s("p",[t._v("Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward）不过这种情况如果删除分支，则会丢失merge分支信息。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("–squash")])])]),t._v(" "),s("p",[t._v("把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用–squash进行合并，此时文件已经同合并后一样了，但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("–no-ff")])])]),t._v(" "),s("p",[t._v("关闭fast-forward模式，在提交的时候，会创建一个merge的commit信息，然后合并的和master分支")]),t._v(" "),s("p",[t._v("merge的不同行为，向后看，其实最终都会将代码合并到master分支，而区别仅仅只是分支上的简洁清晰的问题，然后，向前看，也就是我们使用reset 的时候，就会发现，不同的行为就带来了不同的影响")]),t._v(" "),s("p",[t._v("使用 merge --no-ff的时候的效果，此时git reset HEAD^ --hard 的时候，整个分支会回退到 dev2-commit-2\n"),s("img",{attrs:{src:"/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210323233446.png",alt:""}})]),t._v(" "),s("p",[t._v("使用 fast-forward 模式的时候，即 git merge ，这时候 git reset HEAD^ --hard，整个分支会回退到 dev1-commit-3\n"),s("img",{attrs:{src:"/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210323233530.png",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"撤销合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#撤销合并"}},[t._v("#")]),t._v(" 撤销合并")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/undomerge-start.png",alt:"错误合并"}})]),t._v(" "),s("p",[t._v("如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。 大多数情况下，如果你在错误的 git merge 后运行 git reset --hard HEAD~，这会重置分支指向所以它们看起来像这样")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/undomerge-reset.png",alt:"撤销合并"}}),t._v("\nreset --hard 通常会经历三步：")]),t._v(" "),s("ol",[s("li",[t._v("移动 HEAD 指向的分支。 在本例中，我们想要移动 master 到合并提交（C6）之前所在的位置。")]),t._v(" "),s("li",[t._v("使索引（暂存）看起来像 HEAD。")]),t._v(" "),s("li",[t._v("使工作目录看起来像索引。")])]),t._v(" "),s("p",[t._v("这个方法的缺点是它会重写历史")]),t._v(" "),s("p",[t._v("Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。 Git 称这个操作为“还原”")]),t._v(" "),s("h2",{attrs:{id:"git-reset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-reset"}},[t._v("#")]),t._v(" git reset")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("git reset --mixed")]),t._v(" 回退commit,保留源码,默认方式.")]),t._v(" "),s("li",[s("code",[t._v("git reset --soft")]),t._v(" 回退至某个版本,只回退commit信息")]),t._v(" "),s("li",[s("code",[t._v("git reset --hard")]),t._v(" 彻底回退至某个版本")])]),t._v(" "),s("p",[t._v("回退所有内容到上一个版本 git reset HEAD^")]),t._v(" "),s("h2",{attrs:{id:"git的reset和revert有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git的reset和revert有什么区别"}},[t._v("#")]),t._v(" git的reset和revert有什么区别⭐️")]),t._v(" "),s("p",[t._v("git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。")]),t._v(" "),s("p",[t._v("git revert撤销某次操作，此次操作之前的commit都会被保留. git reset 是撤销某次提交，但是此次之后的修改都会被退回到暂存区.")]),t._v(" "),s("p",[t._v("在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。")]),t._v(" "),s("p",[t._v("git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。")]),t._v(" "),s("p",[t._v("如果是本地提交并没有push到远程，那就选择reset，通过选择模式保留还是删除。push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.")]),t._v(" "),s("p",[t._v("如果代码已经提交到远程，那使用reset并不会撤销远程的commit，只会撤销本地的commit，这样会导致修改完后提交到远程git其实并不认可你的reset，只是觉得你没有pull就push了，会提示叫你合并，所以选择revert。")]),t._v(" "),s("h2",{attrs:{id:"git-文件重命名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-文件重命名"}},[t._v("#")]),t._v(" git 文件重命名")]),t._v(" "),s("p",[s("code",[t._v("$ git mv file_from file_to")])]),t._v(" "),s("p",[t._v("运行 git mv 就相当于运行了下面三条命令：")]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[t._v("$ mv README.md README\n$ git rm README.md\n$ git add README\n")])])]),s("h2",{attrs:{id:"git-tag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-tag"}},[t._v("#")]),t._v(" git tag")]),t._v(" "),s("p",[t._v("Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）")]),t._v(" "),s("h3",{attrs:{id:"附注标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#附注标签"}},[t._v("#")]),t._v(" 附注标签")]),t._v(" "),s("p",[t._v("在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项")]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[t._v('$ git tag -a v1.4 -m "my version 1.4"\n')])])]),s("p",[t._v("-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。")]),t._v(" "),s("p",[t._v("通过使用 git show 命令可以看到标签信息和与之对应的提交信息")]),t._v(" "),s("h3",{attrs:{id:"轻量标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#轻量标签"}},[t._v("#")]),t._v(" 轻量标签")]),t._v(" "),s("p",[t._v("另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。")]),t._v(" "),s("p",[t._v("创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：")]),t._v(" "),s("h3",{attrs:{id:"后期补打标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后期补打标签"}},[t._v("#")]),t._v(" 后期补打标签")]),t._v(" "),s("p",[t._v("要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和），就是commit id")]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[t._v("$ git tag -a v1.2 9fceb02\n")])])]),s("h3",{attrs:{id:"共享标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共享标签"}},[t._v("#")]),t._v(" 共享标签")]),t._v(" "),s("p",[t._v("默认情况下，git push 命令并不会传送标签到远程仓库服务器上。")]),t._v(" "),s("p",[t._v("在创建完标签后你必须显式地推送标签到共享服务器上，这个过程就像共享远程分支一样，你可以运行 "),s("code",[t._v("git push origin <tagname>")]),t._v("。")]),t._v(" "),s("p",[t._v("如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。")]),t._v(" "),s("h3",{attrs:{id:"删除标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除标签"}},[t._v("#")]),t._v(" 删除标签")]),t._v(" "),s("p",[t._v("要删除掉你本地仓库上的标签，可以使用命令 "),s("code",[t._v("git tag -d <tagname>")]),t._v("。")]),t._v(" "),s("p",[t._v("注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 "),s("code",[t._v("git push <remote> :refs/tags/<tagname>")]),t._v(" 来更新远程仓库")]),t._v(" "),s("p",[t._v("第二种更直观的删除远程标签的方式是："),s("code",[t._v("$ git push origin --delete <tagname>")])]),t._v(" "),s("h2",{attrs:{id:"branch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#branch"}},[t._v("#")]),t._v(" branch⭐️")]),t._v(" "),s("p",[t._v("Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。")]),t._v(" "),s("p",[t._v("在进行提交操作时，Git 会保存一个提交对象（commit object）,该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。")]),t._v(" "),s("p",[t._v("Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效")]),t._v(" "),s("p",[t._v("Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针，在 Git 中，它是一个指针，指向当前所在的本地分支")]),t._v(" "),s("p",[t._v("可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。")]),t._v(" "),s("h3",{attrs:{id:"创建分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建分支"}},[t._v("#")]),t._v(" 创建分支")]),t._v(" "),s("p",[t._v("只是为创建了一个可以移动的新的指针。")]),t._v(" "),s("p",[t._v("使用 git branch 命令："),s("code",[t._v("$ git branch testing")]),t._v(", 创建了 testing 分支，只是创建了分支，并不会切换到该分支")]),t._v(" "),s("h3",{attrs:{id:"查看分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查看分支"}},[t._v("#")]),t._v(" 查看分支")]),t._v(" "),s("p",[t._v("git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表")]),t._v(" "),s("p",[t._v("如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令")]),t._v(" "),s("p",[t._v("--merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged")]),t._v(" "),s("h3",{attrs:{id:"切换分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#切换分支"}},[t._v("#")]),t._v(" 切换分支")]),t._v(" "),s("p",[t._v("要切换到一个已存在的分支，需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：")]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[t._v("$ git checkout testing\n")])])]),s("p",[t._v("这样 HEAD 就指向 testing 分支了。")]),t._v(" "),s("p",[t._v("通常我们会在创建一个新分支后立即切换过去，这可以用 "),s("code",[t._v("git checkout -b <newbranchname>")]),t._v(" 一条命令搞定。")]),t._v(" "),s("p",[t._v("切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。")]),t._v(" "),s("h3",{attrs:{id:"分支合并工作流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分支合并工作流"}},[t._v("#")]),t._v(" 分支合并工作流")]),t._v(" "),s("p",[t._v("一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 将经历如下步骤：")]),t._v(" "),s("ol",[s("li",[t._v("开发某个网站。")]),t._v(" "),s("li",[t._v("为实现某个新的用户需求，创建一个分支。")]),t._v(" "),s("li",[t._v("在这个分支上开展工作。")])]),t._v(" "),s("p",[t._v("正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：")]),t._v(" "),s("ol",[s("li",[t._v("切换到你的线上分支（production branch）。")]),t._v(" "),s("li",[t._v("为这个紧急任务新建一个分支，并在其中修复它。")]),t._v(" "),s("li",[t._v("在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。")]),t._v(" "),s("li",[t._v("切换回你最初工作的分支上，继续工作。")])]),t._v(" "),s("h2",{attrs:{id:"怎么解决版本冲突问题？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么解决版本冲突问题？"}},[t._v("#")]),t._v(" 怎么解决版本冲突问题？")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("情况1 无冲突")]),t._v(" "),s("p",[t._v("先拉取远端的代码，更新本地代码。然后提交自己的更新代码即可。")])]),t._v(" "),s("li",[s("p",[t._v("情况2 有冲突")]),t._v(" "),s("ol",[s("li",[t._v("拉取远端代码。存在冲突，会报错。")]),t._v(" "),s("li",[t._v("此时我们需要将本地代码暂存起来, stash save；")]),t._v(" "),s("li",[t._v("更新本地代码，将本地代码版本更新和远端的代码一致即可；")]),t._v(" "),s("li",[t._v("将暂存的代码atash pop, 将其合并到更新后的代码后，有冲突解决冲突(需要手动进行解决冲突)；")]),t._v(" "),s("li",[t._v("提交解决冲突后的代码。")])])])]),t._v(" "),s("h2",{attrs:{id:"git中从远程拉取代码后与本地冲突？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git中从远程拉取代码后与本地冲突？"}},[t._v("#")]),t._v(" Git中从远程拉取代码后与本地冲突？")]),t._v(" "),s("h2",{attrs:{id:"git-commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-commit"}},[t._v("#")]),t._v(" git commit")]),t._v(" "),s("p",[s("code",[t._v("git diff --check")]),t._v("，它将会找到可能的空白错误并将它们为你列出来。")]),t._v(" "),s("h2",{attrs:{id:"git-commit-message"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-commit-message"}},[t._v("#")]),t._v(" git commit message")]),t._v(" "),s("p",[t._v("commit message的写法规范有许多，目前使用最广的，比较合理和系统化的为Angular 规范")]),t._v(" "),s("p",[t._v("message 格式，Header（第一行） 是必需的，Body 和 Footer 可以省略。")]),t._v(" "),s("p",[t._v("Body 部分是对本次 commit 的详细描述，可以分成多行。(换行用\\n)")]),t._v(" "),s("p",[t._v("Footer 部分只用于两种情况。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("不兼容变动")]),t._v(" "),s("p",[t._v("如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。")])]),t._v(" "),s("li",[s("p",[t._v("关闭Issue")]),t._v(" "),s("p",[t._v("如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue。")])])]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("("),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("): "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("subject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("空行")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("空行")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("footer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("h3",{attrs:{id:"header"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#header"}},[t._v("#")]),t._v(" header")]),t._v(" "),s("p",[t._v("Header部分只有一行，包括三个字段：type （必需）、scope（可选）、subject（必需）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("type 用于说明commit的类别，允许使用以下7个标识。")]),t._v(" "),s("ul",[s("li",[t._v("feat：新功能（feature）")]),t._v(" "),s("li",[t._v("fix：修补bug")]),t._v(" "),s("li",[t._v("docs：文档（documentation）")]),t._v(" "),s("li",[t._v("style： 格式（不影响代码运行的变动）")]),t._v(" "),s("li",[t._v("refactor：重构（即不是新增功能，也不是修改bug的代码变动）")]),t._v(" "),s("li",[t._v("test：增加测试")]),t._v(" "),s("li",[t._v("chore：构建过程或辅助工具的变动")])])]),t._v(" "),s("li",[s("p",[t._v("scope")]),t._v(" "),s("p",[t._v("scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。")])]),t._v(" "),s("li",[s("p",[t._v("subject")]),t._v(" "),s("p",[t._v("subject是 commit 目的的简短描述，不超过50个字符。")])])]),t._v(" "),s("h2",{attrs:{id:"如何检查-git-commit-格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何检查-git-commit-格式"}},[t._v("#")]),t._v(" 如何检查 git commit 格式⭐️")]),t._v(" "),s("p",[t._v("commitlint用于检查我们的commit message是否符合提交规范，如果不符合，则直接拒绝提交。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("npm install "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("save"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("dev @commitlint"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("config"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("conventional @commitlint"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("cli\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 生成配置文件commitlint.config.js，当然也可以是 .commitlintrc.js")]),t._v("\necho "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"module.exports = {extends: ['@commitlint/config-conventional']};\"")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" commitlint"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("config"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n")])])]),s("p",[t._v("在commitlint.config.js制定提交message规范")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"module.exports = {extends: ['@commitlint/config-conventional']}\"")]),t._v("\n\nmodule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@commitlint/config-conventional'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  rules"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数组中第一位为level，可选0,1,2，0为disable，1为warning，2为error，第二位为应用与否，可选always|never，第三位该rule的值。")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// type-enum 为 rule 的 name")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// 写成function也可以，比如 "header-max-length": () => [0, "always", 72],')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'type-enum'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'always'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"feat"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fix"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"docs"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"style"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"refactor"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"chore"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"revert"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'type-case'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'type-empty'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'scope-empty'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'scope-case'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'subject-full-stop'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'never'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'subject-case'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'never'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("检验commit message的最佳方式是结合git hook，所以需要配合Husky。")]),t._v(" "),s("p",[t._v("安装husky，"),s("code",[t._v("npm install husky")])]),t._v(" "),s("p",[t._v("安装成功后需要在项目的package.json中配置：")]),t._v(" "),s("div",{staticClass:"language-JS extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"husky"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hooks"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"pre-commit"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"npm run test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// v1.0.1版本以后为HUSKY_GIT_PARAMS，v0.14.3为GIT_PARAMS")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"commit-msg"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"commitlint -e $GIT_PARAMS"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("PS:Commitizen是一个撰写合格 Commit message 的工具。")]),t._v(" "),s("h2",{attrs:{id:"合并修改两个commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并修改两个commit"}},[t._v("#")]),t._v(" 合并修改两个commit⭐️")]),t._v(" "),s("p",[s("code",[t._v("git rebase -i HEAD~2")]),t._v(" 对最近的 2 个 commit 进行合并操作(不止是合并操作)")]),t._v(" "),s("blockquote",[s("p",[t._v("git rebase -i [commit id],只需要commit id的前几位即可，并不需要完整的commit id")])]),t._v(" "),s("p",[t._v("实际上指定了以前的3次提交，即想要修改提交的父提交")]),t._v(" "),s("p",[t._v("接着进入vi编辑界面，把要保留的 commit 使用pick，其他的使用squash命令")]),t._v(" "),s("p",[t._v("最旧的提交排列在最上面，因为是第一个要进行修改的（与log命令的顺序相反）")]),t._v(" "),s("p",[t._v("其他命令（不完全）：")]),t._v(" "),s("ul",[s("li",[t._v("p, pick：保留该commit")]),t._v(" "),s("li",[t._v("r, reword：保留该commit，但修改该commit的注释")]),t._v(" "),s("li",[t._v("e, edit：保留该commit, 但要停下来修改该提交(不仅仅修改注释)")]),t._v(" "),s("li",[t._v("s, squash：将该commit和前一个commit合并")]),t._v(" "),s("li",[t._v("f, fixup：将该commit和前一个commit合并，但不要保留该提交的注释信息")]),t._v(" "),s("li",[t._v("x, exec：执行shell命令")]),t._v(" "),s("li",[t._v("d, drop：丢弃该commit")])]),t._v(" "),s("p",[t._v("保存退出编辑器后，如选择了edit，需要使用 "),s("code",[t._v("git commit --amend")]),t._v("，修改提交信息，退出编辑器，满意后使用 "),s("code",[t._v("git rebase --continue")])]),t._v(" "),s("p",[s("strong",[t._v("也可以使用交互式变基来重新排序或完全移除提交")]),t._v("。")]),t._v(" "),s("p",[t._v("拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交，将要拆分的提交的指令修改为 “edit”")]),t._v(" "),s("div",{staticClass:"language-md extra-class"},[s("pre",{pre:!0,attrs:{class:"language-md"}},[s("code",[t._v("pick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n")])])]),s("p",[t._v("当脚本带你进入到命令行时，重置那个提交（git reset HEAD^），拿到被重置的修改，从中创建几次提交。")]),t._v(" "),s("p",[t._v("当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 "),s("code",[t._v("git reset HEAD^")]),t._v(" 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 "),s("code",[t._v("git rebase --continue")])]),t._v(" "),s("h2",{attrs:{id:"git-操作，有两个commit，只想push其中一个怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-操作，有两个commit，只想push其中一个怎么办"}},[t._v("#")]),t._v(" git 操作，有两个commit，只想push其中一个怎么办")]),t._v(" "),s("p",[s("code",[t._v("git commit --amend -m [message]")]),t._v(", 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息")]),t._v(" "),s("blockquote",[s("p",[t._v("每次commit 都会生成一个不同的 commit id , 第二次 commit --amend 后生成的 id 变更了,可能会导致push出问题")])]),t._v(" "),s("p",[s("code",[t._v("git reset --mixed [commit id]")]),t._v("  使用这个命令是commit版本回退到与远程库同一commit版本")]),t._v(" "),s("h2",{attrs:{id:"git中，提交了-a-然后又提交了-b-如何撤回-b"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git中，提交了-a-然后又提交了-b-如何撤回-b"}},[t._v("#")]),t._v(" git中，提交了 a, 然后又提交了 b, 如何撤回 b ?")]),t._v(" "),s("p",[s("code",[t._v("git checkout -- <file>...")]),t._v(",  to discard changes in working directory")]),t._v(" "),s("blockquote",[s("p",[t._v("此时是Changes not staged for commit:")])]),t._v(" "),s("p",[t._v("此时不会保留文件的修改，即对那个文件在本地的任何修改都会消失")]),t._v(" "),s("blockquote",[s("p",[t._v("在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复\n未提交的东西丢失后很可能再也找不到了。")])]),t._v(" "),s("p",[t._v("使用"),s("code",[t._v("git reset HEAD <file>")]),t._v("来取消暂存，此时是Changes to be committed:")]),t._v(" "),s("h2",{attrs:{id:"代码合进去发现有问题，怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码合进去发现有问题，怎么办"}},[t._v("#")]),t._v(" 代码合进去发现有问题，怎么办")]),t._v(" "),s("h2",{attrs:{id:"两个人在同一个git分支上提交代码，一个人先提交版本，另一个人再提交会提示冲突，怎么解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两个人在同一个git分支上提交代码，一个人先提交版本，另一个人再提交会提示冲突，怎么解决"}},[t._v("#")]),t._v(" 两个人在同一个git分支上提交代码，一个人先提交版本，另一个人再提交会提示冲突，怎么解决")]),t._v(" "),s("h2",{attrs:{id:"git怎么merge，回滚和撤销回滚"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git怎么merge，回滚和撤销回滚"}},[t._v("#")]),t._v(" git怎么merge，回滚和撤销回滚")]),t._v(" "),s("h2",{attrs:{id:"文件放错目录，如何换到别的目录下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件放错目录，如何换到别的目录下"}},[t._v("#")]),t._v(" 文件放错目录，如何换到别的目录下")]),t._v(" "),s("h2",{attrs:{id:"如何不提交工作区的修改"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何不提交工作区的修改"}},[t._v("#")]),t._v(" 如何不提交工作区的修改")]),t._v(" "),s("p",[t._v("git stash")]),t._v(" "),s("h2",{attrs:{id:"多仓库管理代码的优势有哪些；"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多仓库管理代码的优势有哪些；"}},[t._v("#")]),t._v(" 多仓库管理代码的优势有哪些；")]),t._v(" "),s("p",[t._v("将项目代码进行一定的拆分放在多个库当中，好处就是将代码进行一定的解耦，对于体型较为庞大的项目来说管理上会更加清晰和富有弹性。将代码按照一定逻辑分库之后，仓库与模块有了自描述的特征，让一起协作的开发者可以一目了然。发布源码版本、持续集成构建时，负责各仓库的研发组织可以按照自己的节奏来发布，同时将一些“坏代码”的影响控制在某个仓库中，而不会影响项目全部代码。分库也有要注意的地方，在同一个项目里的代码多多少少都有业务上或者是技术上的联系，比如编译依赖：以一个Java 项目为例，客户端接口的调用代码究竟是直接依赖服务端接口代码的定义，还是间接依赖？如果是间接依赖，那么分库管理是非常方便的，但同时客户端就无法快速感知到服务端接口定义的变化。所以在进行多仓库划分时，要注意划分的一些常用原则。")]),t._v(" "),s("p",[t._v("一个清晰的分库可以让开发者更好地协作，避免不必要的沟通成本。")]),t._v(" "),s("p",[t._v("对于大型项目而言，如果使用单仓库，就意味着某个模块开发者的本地可能有大量冗余代码和提交记录的信息，这个时候拆分成更小的库显得更加合适。")])])}),[],!1,null,null,null);a.default=v.exports}}]);