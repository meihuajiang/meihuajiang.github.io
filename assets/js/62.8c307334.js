(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{323:function(t,a,s){"use strict";s.r(a);var e=s(9),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"set"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" Set")]),t._v(" "),s("p",[t._v("ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。")]),t._v(" "),s("p",[t._v("Set本身是一个构造函数，用来生成 Set 数据结构。")]),t._v(" "),s("p",[t._v("Set函数可以接受一个数组（或者具有 iterator 接口的其他数据结构）作为参数，用来初始化。")]),t._v(" "),s("p",[s("strong",[t._v("向 Set 加入值的时候，不会发生类型转换")]),t._v('，所以5和"5"是两个不同的值。')]),t._v(" "),s("p",[t._v("Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===）")]),t._v(" "),s("p",[s("strong",[t._v("主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。")])]),t._v(" "),s("p",[s("strong",[t._v("Array.from方法可以将 Set 结构转为数组。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("NaN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set { 'a', 1, 2, NaN, {}, {} }")]),t._v("\n")])])]),s("h3",{attrs:{id:"实例属性和方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例属性和方法"}},[t._v("#")]),t._v(" 实例属性和方法⭐️")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("实例属性")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Set.prototype.constructor")]),t._v(" "),s("td",[t._v("构造函数，默认就是Set函数。")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.size")]),t._v(" "),s("td",[t._v("返回Set实例的成员总数。")])])])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("实例属性")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Set.prototype.add(value)")]),t._v(" "),s("td",[t._v("添加某个值，返回 Set 结构本身。")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.delete(value)")]),t._v(" "),s("td",[t._v("删除某个值，返回一个布尔值，表示删除是否成功。")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.has(value)")]),t._v(" "),s("td",[t._v("返回一个布尔值，表示该值是否为Set的成员。")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.clear()")]),t._v(" "),s("td",[t._v("清除所有成员，没有返回值。")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.keys()")]),t._v(" "),s("td",[t._v("返回键名的遍历器")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.values()")]),t._v(" "),s("td",[t._v("返回键值的遍历器")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.entries()")]),t._v(" "),s("td",[t._v("返回键值对的遍历器")])]),t._v(" "),s("tr",[s("td",[t._v("Set.prototype.forEach()")]),t._v(" "),s("td",[t._v("使用回调函数遍历每个成员")])])])]),t._v(" "),s("p",[t._v("由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。")]),t._v(" "),s("p",[t._v("Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。")]),t._v(" "),s("p",[t._v("forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身。")]),t._v(" "),s("p",[t._v("这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。")]),t._v(" "),s("p",[t._v("另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。")]),t._v(" "),s("h3",{attrs:{id:"遍历顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历顺序"}},[t._v("#")]),t._v(" 遍历顺序")]),t._v(" "),s("p",[t._v("Set的遍历顺序就是插入顺序。这个特性有时非常有用")]),t._v(" "),s("blockquote",[s("p",[t._v("比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。")])]),t._v(" "),s("h3",{attrs:{id:"遍历应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历应用"}},[t._v("#")]),t._v(" 遍历应用⭐️")]),t._v(" "),s("p",[t._v("扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'green'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ['red', 'green', 'blue']")]),t._v("\n")])])]),s("p",[t._v("扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。")]),t._v(" "),s("p",[t._v("因此也可以间接使用数组的map和filter方法")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回Set结构：{2, 4, 6}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回Set结构：{2, 4}")]),t._v("\n")])])]),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 并集")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" union "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set {1, 2, 3, 4}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 交集")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" intersect "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("has")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// set {2, 3}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// （a 相对于 b 的）差集")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" difference "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("has")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set {1}")]),t._v("\n")])])]),s("p",[t._v("如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。")]),t._v(" "),s("p",[t._v("一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；")]),t._v(" "),s("p",[t._v("另一种是利用Array.from方法，然后赋值给原来的 Set 结构。")]),t._v(" "),s("h2",{attrs:{id:"weakset"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#weakset"}},[t._v("#")]),t._v(" WeakSet")]),t._v(" "),s("p",[t._v("WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("WeakSet 的成员只能是对象，而不能是其他类型的值。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("WeakSet 中的对象都是弱引用")])]),t._v(" "),s("p",[t._v("即垃圾回收机制不考虑 WeakSet 对该对象的引用")]),t._v(" "),s("p",[t._v("也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。")])])]),t._v(" "),s("p",[t._v("WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。")]),t._v(" "),s("blockquote",[s("p",[t._v("WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。")])]),t._v(" "),s("p",[t._v("由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。")]),t._v(" "),s("p",[t._v("另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。")]),t._v(" "),s("p",[t._v("WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。")]),t._v(" "),s("p",[t._v("作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）")]),t._v(" "),s("p",[t._v("该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。"),s("strong",[t._v("这意味着，数组的成员只能是对象。（数组是特殊的对象）")])]),t._v(" "),s("h3",{attrs:{id:"方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("方法")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("WeakSet.prototype.add(value)")]),t._v(" "),s("td",[t._v("向 WeakSet 实例添加一个新成员。")])]),t._v(" "),s("tr",[s("td",[t._v("WeakSet.prototype.delete(value)")]),t._v(" "),s("td",[t._v("清除 WeakSet 实例的指定成员。")])]),t._v(" "),s("tr",[s("td",[t._v("WeakSet.prototype.has(value)")]),t._v(" "),s("td",[t._v("返回一个布尔值，表示某个值是否在 WeakSet 实例之中。")])])])]),t._v(" "),s("p",[s("strong",[t._v("WeakSet 没有size属性，没有办法遍历它的成员")])]),t._v(" "),s("h2",{attrs:{id:"map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[t._v("#")]),t._v(" Map")]),t._v(" "),s("p",[t._v("JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串(或是Symbol)当作键。这给它的使用带来了很大的限制。")]),t._v(" "),s("p",[t._v("ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合")]),t._v(" "),s("p",[t._v("但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。")]),t._v(" "),s("p",[t._v("也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。")]),t._v(" "),s("p",[t._v("作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。")]),t._v(" "),s("blockquote",[s("p",[t._v("实际上使用数组的forEach方法，然后一个个用map的set方法")])]),t._v(" "),s("p",[t._v("任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set 和 Map 都可以用来生成新的 Map。")]),t._v(" "),s("p",[t._v("注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。同理，同样的值的两个实例，在 Map 结构中被视为两个键。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键")]),t._v("\nmap"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("555")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nmap"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n")])])]),s("p",[t._v("**Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。**这就解决了同名属性碰撞（clash）的问题")]),t._v(" "),s("p",[t._v("如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键")]),t._v(" "),s("p",[t._v("比如+0和-0就是一个键，布尔值true和字符串true则是两个不同的键。")]),t._v(" "),s("blockquote",[s("p",[t._v("+0 === -0 true")])]),t._v(" "),s("p",[s("strong",[t._v("undefined和null也是两个不同的键。")])]),t._v(" "),s("p",[s("strong",[t._v("虽然NaN不严格相等于自身，但 Map 将其视为同一个键。")])]),t._v(" "),s("h3",{attrs:{id:"size-属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#size-属性"}},[t._v("#")]),t._v(" size 属性")]),t._v(" "),s("p",[t._v("size属性返回 Map 结构的成员总数。")]),t._v(" "),s("h3",{attrs:{id:"map-prototype-set-key-value"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-set-key-value"}},[t._v("#")]),t._v(" Map.prototype.set(key, value)")]),t._v(" "),s("p",[t._v("set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。")]),t._v(" "),s("p",[t._v("set方法返回的是当前的Map对象，因此可以采用链式写法。")]),t._v(" "),s("blockquote",[s("p",[t._v("Set对应的方法是add()")])]),t._v(" "),s("h3",{attrs:{id:"map-prototype-get-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-get-key"}},[t._v("#")]),t._v(" Map.prototype.get(key)")]),t._v(" "),s("p",[t._v("get方法读取key对应的键值，如果找不到key，返回undefined。")]),t._v(" "),s("blockquote",[s("p",[t._v("Set没有对应的方法")])]),t._v(" "),s("h3",{attrs:{id:"map-prototype-has-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-has-key"}},[t._v("#")]),t._v(" Map.prototype.has(key)")]),t._v(" "),s("p",[t._v("has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。")]),t._v(" "),s("blockquote",[s("p",[t._v("Set也类似")])]),t._v(" "),s("h3",{attrs:{id:"map-prototype-delete-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-delete-key"}},[t._v("#")]),t._v(" Map.prototype.delete(key)")]),t._v(" "),s("p",[t._v("delete方法删除某个键，返回true。如果删除失败，返回false。")]),t._v(" "),s("blockquote",[s("p",[t._v("Set也类似")])]),t._v(" "),s("h3",{attrs:{id:"map-prototype-clear"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-clear"}},[t._v("#")]),t._v(" Map.prototype.clear()")]),t._v(" "),s("p",[t._v("clear方法清除所有成员，没有返回值。")]),t._v(" "),s("blockquote",[s("p",[t._v("Set也类似")])]),t._v(" "),s("h3",{attrs:{id:"遍历顺序-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历顺序-2"}},[t._v("#")]),t._v(" 遍历顺序")]),t._v(" "),s("p",[t._v("Map 的遍历顺序就是插入顺序。")]),t._v(" "),s("h3",{attrs:{id:"遍历方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历方法"}},[t._v("#")]),t._v(" 遍历方法")]),t._v(" "),s("p",[t._v("Map 结构原生提供三个遍历器生成函数和一个遍历方法。")]),t._v(" "),s("ul",[s("li",[t._v("Map.prototype.keys()：返回键名的遍历器。")]),t._v(" "),s("li",[t._v("Map.prototype.values()：返回键值的遍历器。")]),t._v(" "),s("li",[t._v("Map.prototype.entries()：返回所有成员的遍历器。")]),t._v(" "),s("li",[t._v("Map.prototype.forEach()：遍历 Map 的所有成员。")])]),t._v(" "),s("p",[t._v("Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。")]),t._v(" "),s("h3",{attrs:{id:"转为数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#转为数组"}},[t._v("#")]),t._v(" 转为数组⭐️")]),t._v(" "),s("p",[s("strong",[t._v("Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。")])]),t._v(" "),s("h3",{attrs:{id:"数组转为-map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组转为-map"}},[t._v("#")]),t._v(" 数组转为 map")]),t._v(" "),s("p",[t._v("将数组传入 Map 构造函数，就可以转为 Map。")]),t._v(" "),s("h3",{attrs:{id:"map-转为对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-转为对象"}},[t._v("#")]),t._v(" map 转为对象")]),t._v(" "),s("p",[t._v("如果所有 Map 的键都是字符串，它可以无损地转为对象。")]),t._v(" "),s("p",[t._v("如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。")]),t._v(" "),s("h3",{attrs:{id:"对象转为map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象转为map"}},[t._v("#")]),t._v(" 对象转为map⭐️")]),t._v(" "),s("p",[s("strong",[t._v("对象转为 Map 可以通过Object.entries()。")])]),t._v(" "),s("h3",{attrs:{id:"map-转为-json"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-转为-json"}},[t._v("#")]),t._v(" Map 转为 JSON")]),t._v(" "),s("p",[t._v("Map 转为 JSON 要区分两种情况。")]),t._v(" "),s("p",[t._v("一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。")]),t._v(" "),s("p",[t._v("另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。")]),t._v(" "),s("h2",{attrs:{id:"weakmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[t._v("#")]),t._v(" WeakMap")]),t._v(" "),s("p",[t._v("WeakMap结构与Map结构类似，也是用于生成键值对的集合。")]),t._v(" "),s("p",[t._v("WeakMap与Map的区别有两点。")]),t._v(" "),s("ul",[s("li",[t._v("WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。")]),t._v(" "),s("li",[t._v("WeakMap的键名所指向的对象，不计入垃圾回收机制")])]),t._v(" "),s("p",[t._v("它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。")]),t._v(" "),s("p",[t._v("因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。")]),t._v(" "),s("p",[t._v("也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。")]),t._v(" "),s("p",[t._v("基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。")]),t._v(" "),s("blockquote",[s("p",[t._v("一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。")])]),t._v(" "),s("p",[t._v("总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。")]),t._v(" "),s("p",[s("strong",[t._v("注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。")])]),t._v(" "),s("h3",{attrs:{id:"方法-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法-2"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),s("p",[t._v("WeakMap 与 Map 在 API 上的区别主要是两个")]),t._v(" "),s("p",[t._v("一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。")]),t._v(" "),s("p",[t._v("因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。")]),t._v(" "),s("p",[t._v("这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。")]),t._v(" "),s("p",[t._v("二是无法清空，即不支持clear方法。")]),t._v(" "),s("p",[t._v("因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。")])])}),[],!1,null,null,null);a.default=n.exports}}]);