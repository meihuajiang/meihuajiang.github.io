(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{300:function(t,a,v){"use strict";v.r(a);var _=v(9),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"待填坑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#待填坑"}},[t._v("#")]),t._v(" 待填坑")]),t._v(" "),v("h2",{attrs:{id:"说说-http-与-tcp-的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#说说-http-与-tcp-的关系"}},[t._v("#")]),t._v(" 说说 HTTP 与 TCP 的关系")]),t._v(" "),v("p",[t._v("TCP对应于传输层，HTTP对应于应用层")]),t._v(" "),v("p",[t._v("HTTP协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次HTTP请求。HTTP会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，HTTP会立即将TCP连接断开，这个过程是很短的。所以HTTP连接是一种短连接，是一种无状态的连接。")]),t._v(" "),v("p",[t._v("TCP是底层协议，定义的是数据传输和连接方式的规范。")]),t._v(" "),v("p",[t._v("HTTP是应用层协议，定义的是传输数据的内容的规范。")]),t._v(" "),v("p",[t._v("HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP就一定支持TCP。")]),t._v(" "),v("h2",{attrs:{id:"tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),v("p",[t._v("TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 是面向连接的、可靠的流协议。")]),t._v(" "),v("h3",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("面向连接")]),t._v(" "),v("p",[t._v("面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。")])]),t._v(" "),v("li",[v("p",[t._v("仅支持单播传输")]),t._v(" "),v("p",[t._v("每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。")])]),t._v(" "),v("li",[v("p",[t._v("面向字节流")]),t._v(" "),v("p",[t._v("TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。")])]),t._v(" "),v("li",[v("p",[t._v("可靠传输")]),t._v(" "),v("p",[t._v("对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。")])]),t._v(" "),v("li",[v("p",[t._v("提供拥塞控制")]),t._v(" "),v("p",[t._v("当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞")])]),t._v(" "),v("li",[v("p",[t._v("TCP提供全双工通信")]),t._v(" "),v("p",[t._v("TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）")])])]),t._v(" "),v("h3",{attrs:{id:"tcp报文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp报文"}},[t._v("#")]),t._v(" TCP报文")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/Snip20200807_65.png",alt:"TCP报文"}})]),t._v(" "),v("ul",[v("li",[t._v("序号，占4字节，是此报文段的初始地址。")]),t._v(" "),v("li",[t._v("确认序号，占4个字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。")]),t._v(" "),v("li",[t._v("数据偏移。TCP首部长度。")]),t._v(" "),v("li",[t._v("URG，当URG=1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，需要优先发送")]),t._v(" "),v("li",[t._v("ACK，只有ACK=1时确认字段才有效。当ACK=0时，确认号无效。")]),t._v(" "),v("li",[t._v("PSH，希望客户端尽快把数据交付给应用程序")]),t._v(" "),v("li",[t._v("RST，当RST=1时，表明TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接")]),t._v(" "),v("li",[t._v("SYN，在连接建立时用来同步序号。")]),t._v(" "),v("li",[t._v("FIN，用来释放连接，当FIN=1时，表明此报文段的发送端数据已经发送完毕，并要求释放连接。")])]),t._v(" "),v("h3",{attrs:{id:"tcp可靠性保障"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp可靠性保障"}},[t._v("#")]),t._v(" TCP可靠性保障")]),t._v(" "),v("ul",[v("li",[t._v("校验和")]),t._v(" "),v("li",[t._v("确认应答与序列号")]),t._v(" "),v("li",[t._v("超时重传")]),t._v(" "),v("li",[t._v("流量控制")]),t._v(" "),v("li",[t._v("拥塞控制")])]),t._v(" "),v("h3",{attrs:{id:"tcp流量控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp流量控制"}},[t._v("#")]),t._v(" TCP流量控制")]),t._v(" "),v("p",[t._v("接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应")]),t._v(" "),v("p",[t._v("因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制")]),t._v(" "),v("p",[t._v("在TCP报文段首部中有一个16位窗口长度，当接收端接收到发送方的数据后，在应答报文ACK中就将自身缓冲区的剩余大小，放入该窗口中。这个大小随数据传输情况而变，窗口越大，网络吞吐量越高，而一旦接收方发现自身的缓冲区快满了，就将窗口设置为更小的值通知发送方。如果缓冲区满，就将窗口置为0，发送方收到后就不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端")]),t._v(" "),v("h3",{attrs:{id:"tcp超时重传"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp超时重传"}},[t._v("#")]),t._v(" TCP超时重传")]),t._v(" "),v("p",[t._v("当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传")]),t._v(" "),v("ul",[v("li",[t._v("一种情况是发送包丢失了")]),t._v(" "),v("li",[t._v("另一种情况是ACK丢失")])]),t._v(" "),v("h3",{attrs:{id:"tcp拥塞控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp拥塞控制"}},[t._v("#")]),t._v(" TCP拥塞控制")]),t._v(" "),v("p",[t._v("流量控制解决了两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/5021195-7e430647cc9ea981.webp.jpg",alt:"慢启动"}}),t._v(" "),v("img",{attrs:{src:"/img/5021195-991a69df2dbf5ff7.webp.jpg",alt:"快恢复"}})]),t._v(" "),v("h3",{attrs:{id:"tcp断点重传怎么实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp断点重传怎么实现的"}},[t._v("#")]),t._v(" TCP断点重传怎么实现的")]),t._v(" "),v("p",[t._v("相关状态码，206 Partial Content")]),t._v(" "),v("h3",{attrs:{id:"哪些协议基于tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哪些协议基于tcp"}},[t._v("#")]),t._v(" 哪些协议基于TCP")]),t._v(" "),v("ul",[v("li",[t._v("HTTP")]),t._v(" "),v("li",[t._v("HTTPS")]),t._v(" "),v("li",[t._v("websocket")])]),t._v(" "),v("h3",{attrs:{id:"http-强行使用-udp-能实现吗？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-强行使用-udp-能实现吗？"}},[t._v("#")]),t._v(" HTTP 强行使用 UDP 能实现吗？")]),t._v(" "),v("h3",{attrs:{id:"是否每次进行http请求都会建立tcp连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#是否每次进行http请求都会建立tcp连接"}},[t._v("#")]),t._v(" 是否每次进行HTTP请求都会建立TCP连接")]),t._v(" "),v("h3",{attrs:{id:"现代浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开？什么情况下会断开？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现代浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开？什么情况下会断开？"}},[t._v("#")]),t._v(" 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？")]),t._v(" "),v("p",[t._v("默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接")]),t._v(" "),v("h3",{attrs:{id:"tcp-可以建立多个连接吗？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-可以建立多个连接吗？"}},[t._v("#")]),t._v(" TCP 可以建立多个连接吗？")]),t._v(" "),v("p",[t._v("可以")]),t._v(" "),v("h3",{attrs:{id:"tcp在http的早期版本是怎么实现多个连接的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp在http的早期版本是怎么实现多个连接的"}},[t._v("#")]),t._v(" TCP在HTTP的早期版本是怎么实现多个连接的")]),t._v(" "),v("h3",{attrs:{id:"http多个tcp连接怎么实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http多个tcp连接怎么实现的"}},[t._v("#")]),t._v(" HTTP多个TCP连接怎么实现的")]),t._v(" "),v("p",[t._v("keep-alive")]),t._v(" "),v("h3",{attrs:{id:"一个-tcp-连接中-http-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一个-tcp-连接中-http-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"}},[t._v("#")]),t._v(" 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？")]),t._v(" "),v("p",[t._v("HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。")]),t._v(" "),v("p",[t._v("虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。")]),t._v(" "),v("p",[t._v("在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。")]),t._v(" "),v("h3",{attrs:{id:"浏览器对同一-host-建立-tcp-连接到数量有没有限制？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器对同一-host-建立-tcp-连接到数量有没有限制？"}},[t._v("#")]),t._v(" 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？")]),t._v(" "),v("p",[t._v("有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。")]),t._v(" "),v("h3",{attrs:{id:"应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),v("h2",{attrs:{id:"udp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[t._v("#")]),t._v(" UDP")]),t._v(" "),v("p",[t._v("UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。")]),t._v(" "),v("h3",{attrs:{id:"特点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("面向无连接")]),t._v(" "),v("p",[t._v("首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。")]),t._v(" "),v("p",[t._v("具体来说就是：")]),t._v(" "),v("ul",[v("li",[t._v("在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了")]),t._v(" "),v("li",[t._v("在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作")])])]),t._v(" "),v("li",[v("p",[t._v("有单播，多播，广播的功能")]),t._v(" "),v("p",[t._v("UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。")])]),t._v(" "),v("li",[v("p",[t._v("UDP是面向报文的")]),t._v(" "),v("p",[t._v("发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文")])]),t._v(" "),v("li",[v("p",[t._v("不可靠性")]),t._v(" "),v("p",[t._v("首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。")])]),t._v(" "),v("li",[v("p",[t._v("头部开销小")]),t._v(" "),v("p",[t._v("传输数据报文时是很高效的。")]),t._v(" "),v("p",[t._v("UDP 头部包含了以下几个数据：")]),t._v(" "),v("ul",[v("li",[t._v("两个十六位的端口号，分别为源端口（可选字段）和目标端口")]),t._v(" "),v("li",[t._v("整个数据报文的长度")]),t._v(" "),v("li",[t._v("整个数据报文的检验和（checksum），该字段用于发现头部信息和数据中的错误")])]),t._v(" "),v("p",[t._v("因此 "),v("strong",[t._v("UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的")])])])]),t._v(" "),v("h3",{attrs:{id:"怎么用udp实现可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么用udp实现可靠传输"}},[t._v("#")]),t._v(" 怎么用UDP实现可靠传输")]),t._v(" "),v("p",[t._v("通过应用层模拟传输层TCP的可靠性")]),t._v(" "),v("ul",[v("li",[t._v("添加seq/ack机制，确保数据发送到对端")]),t._v(" "),v("li",[t._v("添加发送和接收缓冲区，主要是用户超时重传。")]),t._v(" "),v("li",[t._v("添加超时重传机制。")])]),t._v(" "),v("h3",{attrs:{id:"数据量很大的时候udp怎么可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据量很大的时候udp怎么可靠传输"}},[t._v("#")]),t._v(" 数据量很大的时候UDP怎么可靠传输")]),t._v(" "),v("h3",{attrs:{id:"应用场景-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),v("h3",{attrs:{id:"使用udp的协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用udp的协议"}},[t._v("#")]),t._v(" 使用UDP的协议")]),t._v(" "),v("ul",[v("li",[t._v("DNS，端口53")]),t._v(" "),v("li",[t._v("QUIC")]),t._v(" "),v("li",[t._v("TFTP，简单文件传输协议，端口69")])]),t._v(" "),v("h2",{attrs:{id:"什么是字节流，什么是数据报"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是字节流，什么是数据报"}},[t._v("#")]),t._v(" 什么是字节流，什么是数据报")]),t._v(" "),v("p",[t._v("TCP是字节流，UDP是数据报")]),t._v(" "),v("h2",{attrs:{id:"请求方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求方法"}},[t._v("#")]),t._v(" 请求方法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("请求方法")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("GET")]),t._v(" "),v("td",[t._v("GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.")])]),t._v(" "),v("tr",[v("td",[t._v("HEAD")]),t._v(" "),v("td",[t._v("HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.")])]),t._v(" "),v("tr",[v("td",[t._v("POST")]),t._v(" "),v("td",[t._v("POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用.")])]),t._v(" "),v("tr",[v("td",[t._v("PUT")]),t._v(" "),v("td",[t._v("PUT方法用请求有效载荷替换目标资源的所有当前表示。")])]),t._v(" "),v("tr",[v("td",[t._v("DELETE")]),t._v(" "),v("td",[t._v("DELETE方法删除指定的资源。")])]),t._v(" "),v("tr",[v("td",[t._v("CONNECT")]),t._v(" "),v("td",[t._v("CONNECT方法建立一个到由目标资源标识的服务器的隧道。")])]),t._v(" "),v("tr",[v("td",[t._v("OPTIONS")]),t._v(" "),v("td",[t._v("OPTIONS方法用于描述目标资源的通信选项。")])]),t._v(" "),v("tr",[v("td",[t._v("TRACE")]),t._v(" "),v("td",[t._v("TRACE方法沿着到目标资源的路径执行一个消息环回测试。")])]),t._v(" "),v("tr",[v("td",[t._v("PATCH")]),t._v(" "),v("td",[t._v("PATCH方法用于对资源应用部分修改。")])])])]),t._v(" "),v("h2",{attrs:{id:"post和get"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#post和get"}},[t._v("#")]),t._v(" post和get")]),t._v(" "),v("p",[t._v("GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中。但这种情况仅限于浏览器发请求的场景。")]),t._v(" "),v("blockquote",[v("p",[t._v("HTTP本身没有限制")])]),t._v(" "),v("p",[t._v("GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body")]),t._v(" "),v("p",[t._v("GET数据有长度限制“其实是指”URL的长度限制“。")]),t._v(" "),v("p",[t._v("HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。")]),t._v(" "),v("p",[t._v("GET能被缓存，POST不能缓存")]),t._v(" "),v("p",[t._v("GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。")]),t._v(" "),v("h3",{attrs:{id:"post和get的幂等性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#post和get的幂等性"}},[t._v("#")]),t._v(" post和get的幂等性")]),t._v(" "),v("p",[t._v("一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下、GET、HEAD、PUT、options 和 DELETE等方法都是幂等的，而 POST 方法不是。")]),t._v(" "),v("p",[t._v("PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。")]),t._v(" "),v("h3",{attrs:{id:"使用get访问网站时-地址可以无限拼接吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用get访问网站时-地址可以无限拼接吗"}},[t._v("#")]),t._v(" 使用get访问网站时 地址可以无限拼接吗?")]),t._v(" "),v("p",[t._v("GET数据有长度限制“其实是指”URL的长度限制“。")]),t._v(" "),v("p",[t._v("HTTP协议本身对URL长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。")]),t._v(" "),v("p",[t._v("为啥要限制呢？解析的时候要分配内存。对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而URL这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个请求时必须分配一整块足够大的内存。如果URL太长，而并发又很高，就容易挤爆服务器的内存；同时，超长URL的好处并不多")]),t._v(" "),v("p",[t._v("此外，超长URL会影响搜索引擎的爬虫")]),t._v(" "),v("h3",{attrs:{id:"使用get有中文时使用什么方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用get有中文时使用什么方法"}},[t._v("#")]),t._v(" 使用get有中文时使用什么方法")]),t._v(" "),v("ul",[v("li",[t._v("encodeURL")]),t._v(" "),v("li",[t._v("encodeURLCompoent")])]),t._v(" "),v("h3",{attrs:{id:"get的请求一定会被浏览器缓存吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get的请求一定会被浏览器缓存吗"}},[t._v("#")]),t._v(" get的请求一定会被浏览器缓存吗")]),t._v(" "),v("h3",{attrs:{id:"删除操作为什么可以用post"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除操作为什么可以用post"}},[t._v("#")]),t._v(" 删除操作为什么可以用post")]),t._v(" "),v("p",[t._v("因为主要是语义上的差别，因此在传输层上来看的话，get、delete、post和put是没有任何区别的。")]),t._v(" "),v("h3",{attrs:{id:"get请求可以用post请求替代，那有什么存在的必要呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get请求可以用post请求替代，那有什么存在的必要呢"}},[t._v("#")]),t._v(" get请求可以用post请求替代，那有什么存在的必要呢")]),t._v(" "),v("h3",{attrs:{id:"head"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#head"}},[t._v("#")]),t._v(" head")]),t._v(" "),v("p",[t._v("HTTP HEAD 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.")]),t._v(" "),v("p",[t._v("HEAD 方法的响应不应包含响应正文. 即使包含了正文也必须忽略掉. 虽然描述正文信息的 entity headers, 例如 Content-Length 可能会包含在响应中, 但它们并不是用来描述 HEAD 响应本身的, 而是用来描述同样情况下的 GET 请求应该返回的响应.")]),t._v(" "),v("p",[t._v("如果 HEAD 请求的结果显示在上一次 GET 请求后缓存的资源已经过期了, 即使没有发出GET请求，缓存也会失效")]),t._v(" "),v("h3",{attrs:{id:"options请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#options请求"}},[t._v("#")]),t._v(" options请求")]),t._v(" "),v("h3",{attrs:{id:"浏览器会对用户的哪些请求方法做记录？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器会对用户的哪些请求方法做记录？"}},[t._v("#")]),t._v(" 浏览器会对用户的哪些请求方法做记录？")]),t._v(" "),v("p",[t._v("因为POST可能有副作用，所以浏览器实现为不能把POST请求保存为书签")]),t._v(" "),v("h3",{attrs:{id:"请求不是我发的，且不知道会返回什么样的数据，如何拿到想要的结果，并赋予某个变量？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请求不是我发的，且不知道会返回什么样的数据，如何拿到想要的结果，并赋予某个变量？"}},[t._v("#")]),t._v(" 请求不是我发的，且不知道会返回什么样的数据，如何拿到想要的结果，并赋予某个变量？")]),t._v(" "),v("h2",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手⭐️")]),t._v(" "),v("p",[t._v("三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。")]),t._v(" "),v("h3",{attrs:{id:"三次握手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程"}},[t._v("#")]),t._v(" 三次握手过程")]),t._v(" "),v("p",[t._v("刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("第一次握手：")]),t._v(" "),v("p",[t._v("客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。")]),t._v(" "),v("p",[t._v("首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但消耗掉一个序号。")])]),t._v(" "),v("li",[v("p",[t._v("第二次握手：")]),t._v(" "),v("p",[t._v("服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。")]),t._v(" "),v("p",[t._v("在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。")])]),t._v(" "),v("li",[v("p",[t._v("第三次握手：")]),t._v(" "),v("p",[t._v("客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。")]),t._v(" "),v("p",[t._v("确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。")])])]),t._v(" "),v("h3",{attrs:{id:"为什么不两次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不两次握手"}},[t._v("#")]),t._v(" 为什么不两次握手⭐️")]),t._v(" "),v("p",[t._v("第一次握手：客户端发送网络包，服务端收到了。")]),t._v(" "),v("p",[t._v("这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。")]),t._v(" "),v("p",[t._v("第二次握手：服务端发包，客户端收到了。")]),t._v(" "),v("p",[t._v("这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。")]),t._v(" "),v("p",[t._v("第三次握手：客户端发包，服务端收到了。")]),t._v(" "),v("p",[t._v("这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。")]),t._v(" "),v("p",[t._v("因此，需要三次握手才能确认双方的接收与发送能力是否正常。")]),t._v(" "),v("p",[t._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")]),t._v(" "),v("h3",{attrs:{id:"为什么不四次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不四次握手"}},[t._v("#")]),t._v(" 为什么不四次握手")]),t._v(" "),v("p",[t._v("因为没必要")]),t._v(" "),v("h3",{attrs:{id:"最后一次可以携带数据吗？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最后一次可以携带数据吗？"}},[t._v("#")]),t._v(" 最后一次可以携带数据吗？")]),t._v(" "),v("p",[t._v("可以。")]),t._v(" "),v("p",[t._v("此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了")]),t._v(" "),v("h3",{attrs:{id:"半连接队列和全连接队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列和全连接队列"}},[t._v("#")]),t._v(" 半连接队列和全连接队列")]),t._v(" "),v("p",[t._v("服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。")]),t._v(" "),v("p",[t._v("当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。")]),t._v(" "),v("h3",{attrs:{id:"syn攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#syn攻击"}},[t._v("#")]),t._v(" SYN攻击")]),t._v(" "),v("p",[t._v("服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。")]),t._v(" "),v("p",[t._v("SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。")]),t._v(" "),v("p",[t._v("检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。")]),t._v(" "),v("p",[t._v("常见的防御 SYN 攻击的方法有如下几种：")]),t._v(" "),v("ul",[v("li",[t._v("缩短超时（SYN Timeout）时间")]),t._v(" "),v("li",[t._v("增加最大半连接数")]),t._v(" "),v("li",[t._v("过滤网关防护")]),t._v(" "),v("li",[t._v("SYN cookies技术")])]),t._v(" "),v("h2",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手⭐️")]),t._v(" "),v("p",[t._v("建立一个连接需要三次握手，而终止一个连接要经过四次挥手。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。")]),t._v(" "),v("p",[t._v("TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。")]),t._v(" "),v("h3",{attrs:{id:"四次挥手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手过程"}},[t._v("#")]),t._v(" 四次挥手过程")]),t._v(" "),v("p",[t._v("刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("第一次挥手：")]),t._v(" "),v("p",[t._v("客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。")]),t._v(" "),v("p",[t._v("即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")])]),t._v(" "),v("li",[v("p",[t._v("第二次挥手：")]),t._v(" "),v("p",[t._v("服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。")]),t._v(" "),v("p",[t._v("即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。")])]),t._v(" "),v("li",[v("p",[t._v("第三次挥手：")]),t._v(" "),v("p",[t._v("如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。")]),t._v(" "),v("p",[t._v("即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。")])]),t._v(" "),v("li",[v("p",[t._v("第四次挥手：")]),t._v(" "),v("p",[t._v("客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。")]),t._v(" "),v("p",[t._v("即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。")]),t._v(" "),v("p",[t._v("收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。")])])]),t._v(" "),v("h3",{attrs:{id:"挥手时为什么要等待2msl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#挥手时为什么要等待2msl"}},[t._v("#")]),t._v(" 挥手时为什么要等待2MSL")]),t._v(" "),v("p",[t._v("理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。")]),t._v(" "),v("p",[t._v("MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。")]),t._v(" "),v("p",[t._v("为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。")]),t._v(" "),v("p",[t._v("防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。")]),t._v(" "),v("h2",{attrs:{id:"缓存机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存机制"}},[t._v("#")]),t._v(" 缓存机制⭐️")]),t._v(" "),v("p",[t._v("浏览器的缓存机制也就是我们说的HTTP缓存机制")]),t._v(" "),v("p",[t._v("浏览器发起HTTP请求,服务器响应请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/162db6359673e7d0.webp.jpg",alt:"简单流程"}})]),t._v(" "),v("p",[t._v("浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识")]),t._v(" "),v("p",[t._v("浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("PS")]),t._v(" "),v("p",[t._v("HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)")]),t._v(" "),v("p",[t._v("HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体")]),t._v(" "),v("p",[t._v("通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；\n实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。")])]),t._v(" "),v("h3",{attrs:{id:"强缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),v("p",[t._v("强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）\n"),v("img",{attrs:{src:"/img/162db63596c9de23.webp.jpg",alt:"情况一"}})])]),t._v(" "),v("li",[v("p",[t._v("存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存\n"),v("img",{attrs:{src:"/img/162db63597182316.webp.jpg",alt:"情况二"}})])]),t._v(" "),v("li",[v("p",[t._v("存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果\n"),v("img",{attrs:{src:"/img/162db6359acd19d3.webp.jpg",alt:"情况三"}})])])]),t._v(" "),v("h4",{attrs:{id:"规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#规则"}},[t._v("#")]),t._v(" 规则")]),t._v(" "),v("p",[t._v("当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，")]),t._v(" "),v("p",[t._v("控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。")]),t._v(" "),v("h4",{attrs:{id:"cache-control"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control⭐️")]),t._v(" "),v("p",[t._v("在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：")]),t._v(" "),v("ul",[v("li",[t._v("public：所有内容都将被缓存（客户端和代理服务器都可缓存）")]),t._v(" "),v("li",[t._v("private：所有内容只有客户端可以缓存，Cache-Control的默认取值")]),t._v(" "),v("li",[t._v("no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定")]),t._v(" "),v("li",[t._v("no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存")]),t._v(" "),v("li",[t._v("max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效")])]),t._v(" "),v("p",[t._v("HTTP响应报文中Cache-Control为max-age=xxx，是相对值")]),t._v(" "),v("h4",{attrs:{id:"expires"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),v("p",[t._v("Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。")]),t._v(" "),v("p",[t._v("到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义")]),t._v(" "),v("p",[t._v("HTTP响应报文中expires的时间值，是一个绝对值\n"),v("img",{attrs:{src:"/img/162db635aa7b772b.webp.jpg",alt:"expires字段"}})]),t._v(" "),v("p",[t._v('如果在Cache-Control响应头设置了 "max-age" 或者 "s-maxage" 指令，那么 Expires 头会被忽略。')]),t._v(" "),v("p",[t._v("s-maxage的优先级比max-age高")]),t._v(" "),v("h3",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),v("p",[t._v("协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程")]),t._v(" "),v("p",[t._v("主要有以下两种情况：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("协商缓存生效，返回304\n"),v("img",{attrs:{src:"/img/162db635cbfff69d.webp.jpg",alt:""}})])]),t._v(" "),v("li",[v("p",[t._v("协商缓存失效，返回200和请求结果\n"),v("img",{attrs:{src:"/img/162db635cf070ff5.webp.jpg",alt:""}})])])]),t._v(" "),v("h4",{attrs:{id:"规则-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#规则-2"}},[t._v("#")]),t._v(" 规则")]),t._v(" "),v("p",[t._v("协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，")]),t._v(" "),v("p",[t._v("控制协商缓存的字段分别有："),v("code",[t._v("Last-Modified / If-Modified-Since")]),t._v(" 和 "),v("code",[t._v("Etag / If-None-Match")])]),t._v(" "),v("p",[t._v("其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。")]),t._v(" "),v("h4",{attrs:{id:"last-modified-if-modified-since"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[t._v("#")]),t._v(" Last-Modified / If-Modified-Since")]),t._v(" "),v("p",[t._v("Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间")]),t._v(" "),v("p",[t._v("If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件")]),t._v(" "),v("p",[t._v("存在的问题，服务器并没有正确感知文件的变化：")]),t._v(" "),v("ul",[v("li",[t._v("1秒内的修改可能不被检查到，导致缓存无法更新；")]),t._v(" "),v("li",[t._v("资源可能只是多了几个空格或无变化，但是Last-Modified的时间已经变化；")])]),t._v(" "),v("h4",{attrs:{id:"etag-if-none-match"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" Etag / If-None-Match")]),t._v(" "),v("p",[t._v("Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)\n"),v("img",{attrs:{src:"/img/162db635e4dd628b.webp.jpg",alt:"Etag"}})]),t._v(" "),v("p",[t._v("If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200")]),t._v(" "),v("p",[t._v("Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。")]),t._v(" "),v("p",[t._v("Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端")]),t._v(" "),v("h3",{attrs:{id:"强制缓存和协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存和协商缓存"}},[t._v("#")]),t._v(" 强制缓存和协商缓存")]),t._v(" "),v("p",[t._v("强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/162db635ed5f6d26",alt:"缓存流程"}})]),t._v(" "),v("h3",{attrs:{id:"缓存位置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[t._v("#")]),t._v(" 缓存位置")]),t._v(" "),v("p",[t._v("from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("内存缓存(from memory cache)：内存缓存具有两个特点：")]),t._v(" "),v("ul",[v("li",[t._v("快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。")]),t._v(" "),v("li",[t._v("时效性：一旦该进程关闭，则该进程的内存则会清空。")])])]),t._v(" "),v("li",[v("p",[t._v("硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。")])])]),t._v(" "),v("p",[t._v("在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。")]),t._v(" "),v("blockquote",[v("p",[t._v("但是实际情况比较复杂，至今还没有看到确认完整的结论。")])]),t._v(" "),v("h3",{attrs:{id:"cache-control-和-pragma-的优先级？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-和-pragma-的优先级？"}},[t._v("#")]),t._v(" Cache-control 和 Pragma 的优先级？")]),t._v(" "),v("p",[t._v("Pragma 是一个在 HTTP/1.0 中规定的通用首部")]),t._v(" "),v("p",[t._v("尽管在请求中，假如 Cache-Control 不存在的话，它的行为与 Cache-Control: no-cache 一致（客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定）")]),t._v(" "),v("h3",{attrs:{id:"命中强缓存的状态码？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#命中强缓存的状态码？"}},[t._v("#")]),t._v(" 命中强缓存的状态码？")]),t._v(" "),v("p",[t._v("200")]),t._v(" "),v("h3",{attrs:{id:"expires的缺点是什么，如何解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#expires的缺点是什么，如何解决"}},[t._v("#")]),t._v(" Expires的缺点是什么，如何解决")]),t._v(" "),v("p",[t._v("Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效。")]),t._v(" "),v("h3",{attrs:{id:"一般什么文件用强缓存，什么东西用协商缓存？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一般什么文件用强缓存，什么东西用协商缓存？"}},[t._v("#")]),t._v(" 一般什么文件用强缓存，什么东西用协商缓存？")]),t._v(" "),v("p",[t._v("html页面完全可以设置协商缓存，可以实现同步更新；")]),t._v(" "),v("p",[t._v("除了 HTML，其他资源文件一般都是协商缓存；")]),t._v(" "),v("p",[t._v("对于经常更新的静态资源文件，可以不作缓存")]),t._v(" "),v("h3",{attrs:{id:"强缓存命中服务器会不会接受到请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存命中服务器会不会接受到请求"}},[t._v("#")]),t._v(" 强缓存命中服务器会不会接受到请求")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/162db6359acd19d3.webp.jpg",alt:"强制缓存命中"}})]),t._v(" "),v("h3",{attrs:{id:"强缓存已经生效，但是服务端资源更新了，客户端怎么触发更新获取新资源"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存已经生效，但是服务端资源更新了，客户端怎么触发更新获取新资源"}},[t._v("#")]),t._v(" 强缓存已经生效，但是服务端资源更新了，客户端怎么触发更新获取新资源⭐️")]),t._v(" "),v("p",[t._v("一般情况下，xxx.html这种页面是不进行强缓存的，HTML 缓存之后，用户用的也是老版本。")]),t._v(" "),v("p",[t._v("所以，每一次 HTML 都是从服务器获取的；内容有更新，也会及时的在客户端更新渲染")]),t._v(" "),v("ul",[v("li",[t._v("开发者手动加时间戳，手动修改时间戳：index.css?20201201220712")]),t._v(" "),v("li",[t._v("资源文件的名字在内容发生更改后，名字重新生成：HASH 值「webpack 配置后可自动生成的」：index.css/fsfdsfs/.css")]),t._v(" "),v("li",[t._v("基于协商缓存实现「一般项目中，两者都是同时设置的」")])]),t._v(" "),v("h3",{attrs:{id:"如果一个静态文件发生了改变，但是强缓存时间还没有过期，怎么让文件内容也发送改变"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如果一个静态文件发生了改变，但是强缓存时间还没有过期，怎么让文件内容也发送改变"}},[t._v("#")]),t._v(" 如果一个静态文件发生了改变，但是强缓存时间还没有过期，怎么让文件内容也发送改变⭐️")]),t._v(" "),v("p",[t._v("生成的静态文件名称使用哈希值，这样的话只要结果改变之后文件名就会不一样，这样请求的就是新的文件；")]),t._v(" "),v("h3",{attrs:{id:"如果本地缓存是有效的，那一定不会向服务器发送请求吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如果本地缓存是有效的，那一定不会向服务器发送请求吗"}},[t._v("#")]),t._v(" 如果本地缓存是有效的，那一定不会向服务器发送请求吗")]),t._v(" "),v("h3",{attrs:{id:"不使用缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不使用缓存"}},[t._v("#")]),t._v(" 不使用缓存")]),t._v(" "),v("p",[t._v("Cache-control的值设置为：no-store")]),t._v(" "),v("p",[t._v("取值：")]),t._v(" "),v("ul",[v("li",[t._v("public：所有内容都将被缓存（客户端和代理服务器都可缓存）")]),t._v(" "),v("li",[t._v("private：所有内容只有客户端可以缓存，Cache-Control的默认取值")]),t._v(" "),v("li",[t._v("no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定")]),t._v(" "),v("li",[t._v("no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存")]),t._v(" "),v("li",[t._v("max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效")])]),t._v(" "),v("h3",{attrs:{id:"如何不受到http缓存的限制，每次都更新资源"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何不受到http缓存的限制，每次都更新资源"}},[t._v("#")]),t._v(" 如何不受到HTTP缓存的限制，每次都更新资源")]),t._v(" "),v("h3",{attrs:{id:"用户行为对浏览器缓存的影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户行为对浏览器缓存的影响"}},[t._v("#")]),t._v(" 用户行为对浏览器缓存的影响")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("用户操作")]),t._v(" "),v("th",[t._v("Expires / Cache-Control")]),t._v(" "),v("th",[t._v("Last-Modified / If-Modified-Since、Etag / If-None-Match")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("地址栏回车")]),t._v(" "),v("td",[t._v("有效")]),t._v(" "),v("td",[t._v("有效")])]),t._v(" "),v("tr",[v("td",[t._v("页面链接跳转")]),t._v(" "),v("td",[t._v("有效")]),t._v(" "),v("td",[t._v("有效")])]),t._v(" "),v("tr",[v("td",[t._v("新开窗口")]),t._v(" "),v("td",[t._v("有效")]),t._v(" "),v("td",[t._v("有效")])]),t._v(" "),v("tr",[v("td",[t._v("前进回退")]),t._v(" "),v("td",[t._v("有效")]),t._v(" "),v("td",[t._v("有效")])]),t._v(" "),v("tr",[v("td",[t._v("F5刷新")]),t._v(" "),v("td",[t._v("无效")]),t._v(" "),v("td",[t._v("有效")])]),t._v(" "),v("tr",[v("td",[t._v("Crtl F5强制刷新")]),t._v(" "),v("td",[t._v("无效")]),t._v(" "),v("td",[t._v("无效")])])])]),t._v(" "),v("p",[t._v("F5 会跳过强缓存规则，直接走协商缓存；Ctrl+F5 ，跳过所有缓存规则，和第一次请求一样，重新获取资源")]),t._v(" "),v("h3",{attrs:{id:"不同窗口能共享存储吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不同窗口能共享存储吗"}},[t._v("#")]),t._v(" 不同窗口能共享存储吗")]),t._v(" "),v("h2",{attrs:{id:"dns"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns"}},[t._v("#")]),t._v(" DNS")]),t._v(" "),v("p",[t._v("DNS (Domain Name System) 域名系统，是一个层次化、分散化的Internet连接资源命名系统。DNS维护着一个包含域名与对应资源例如IP地址的列表.")]),t._v(" "),v("p",[t._v("DNS最突出的功能是将易于记忆的域名(例如mozilla.org)翻译成为数字化的IP地址(例如151.106.5.172).这一从域名到IP地址的映射过程被成为DNS查询(DNS lookup)")]),t._v(" "),v("p",[t._v("DNS数据库存储在全球每个DNS服务器上，所有这些服务器都源于几个被称为“权威名称服务器”或“顶级DNS服务器”。只要您的注册商创建或更新给定域名的任何信息，信息就必须在每个DNS数据库中刷新。")]),t._v(" "),v("p",[t._v("知道给定域名的每个DNS服务器都会存储一段时间的信息，然后再次刷新（DNS服务器再次查询权威服务器）。 因此，知道此域名的DNS服务器需要一些时间才能获取最新信息。")]),t._v(" "),v("h3",{attrs:{id:"流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("检查浏览器缓存")])]),t._v(" "),v("li",[v("p",[t._v("检查操作系统缓存，常见的如hosts文件")])]),t._v(" "),v("li",[v("p",[t._v("检查路由器缓存")])]),t._v(" "),v("li",[v("p",[t._v("如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询")])]),t._v(" "),v("li",[v("p",[t._v("如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，以www.example.com为例，分为以下几步：")]),t._v(" "),v("ol",[v("li",[t._v("根服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，全球只有13台，该例子中会返回.com的地址")]),t._v(" "),v("li",[t._v("接着向TLD发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.example的地址")]),t._v(" "),v("li",[t._v("接着向SLD域名服务器通过域名查询目标IP，本例子会返回www.example.com的地址")]),t._v(" "),v("li",[t._v("Local DNS Server会缓存结果，并返回给用户，缓存在系统中。")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/17296d7e104ed5c0.webp.jpg",alt:"流程"}})]),t._v(" "),v("h3",{attrs:{id:"dns查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns查询"}},[t._v("#")]),t._v(" DNS查询")]),t._v(" "),v("ul",[v("li",[t._v("递归查询（recursive query）。")]),t._v(" "),v("li",[t._v("迭代查询（Iterative  query）。")])]),t._v(" "),v("p",[t._v("递归是用户只向本地DNS服务器发出请求，然后等待肯定或否定答案。而迭代是本地服务器向根DNS服务器发出请求，而根DNS服务器只是给出下一级DNS服务器的地址，然后本地DNS服务器再向下一级DNS发送查询请求直至得到最终答案。")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/20140718112133000.png",alt:"查询过程"}})]),t._v(" "),v("h3",{attrs:{id:"dns基于udp还是tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns基于udp还是tcp"}},[t._v("#")]),t._v(" DNS基于UDP还是TCP")]),t._v(" "),v("p",[t._v("DNS占用53号端口，同时使用TCP和UDP协议。")]),t._v(" "),v("p",[t._v("DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。")]),t._v(" "),v("p",[t._v("辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。同时TCP能保证可靠性。")]),t._v(" "),v("p",[t._v("客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快")]),t._v(" "),v("h3",{attrs:{id:"dns预解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns预解析"}},[t._v("#")]),t._v(" DNS预解析")]),t._v(" "),v("p",[t._v("用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("在服务器中响应设置X-DNS-Prefetch-Control的值为on启动预解析")])]),t._v(" "),v("li",[v("p",[t._v("HTML中，")]),t._v(" "),v("div",{staticClass:"language-html extra-class"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("http-equiv")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("x-dns-prefetch-control"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("on"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])])]),t._v(" "),v("li",[v("p",[t._v("对特定域名预解析")]),t._v(" "),v("div",{staticClass:"language-html extra-class"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("link")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("rel")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v("”dns-prefetch”")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("href")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v("”//fonts.googleapis.com”")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])])])]),t._v(" "),v("h3",{attrs:{id:"dns污染什么意思"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns污染什么意思"}},[t._v("#")]),t._v(" DNS污染什么意思")]),t._v(" "),v("p",[t._v("DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。")]),t._v(" "),v("p",[t._v("DNS污染与DNS劫持的区别在于，DNS劫持修改了DNS的解析结果，DNS污染是不经过DNS服务器，返回错误信息")]),t._v(" "),v("h3",{attrs:{id:"dns劫持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns劫持"}},[t._v("#")]),t._v(" DNS劫持")]),t._v(" "),v("p",[t._v("在劫持的网络范围内拦截域名解析的请求，分析请求的域名，返回假的IP地址或者使请求失去响应。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。")]),t._v(" "),v("p",[t._v("基于HTTP协议向HTTPDNS服务器发送域名解析请求，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，可以避免运营商的域名劫持和进行精准调度。")]),t._v(" "),v("p",[t._v("遇到DNS劫持时，可以找运营商处理，或是工信部直接投诉")]),t._v(" "),v("h2",{attrs:{id:"纠错码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#纠错码"}},[t._v("#")]),t._v(" 纠错码")]),t._v(" "),v("p",[t._v("使用海明码")]),t._v(" "),v("p",[t._v("当海明距离为d时，检错需要d-1位")]),t._v(" "),v("p",[t._v("当海明距离为2d+1时，检错需要d位")]),t._v(" "),v("h2",{attrs:{id:"域名解析原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#域名解析原理"}},[t._v("#")]),t._v(" 域名解析原理")]),t._v(" "),v("h2",{attrs:{id:"arp的作用、功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arp的作用、功能"}},[t._v("#")]),t._v(" ARP的作用、功能")]),t._v(" "),v("h2",{attrs:{id:"ip数据报"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ip数据报"}},[t._v("#")]),t._v(" IP数据报")]),t._v(" "),v("p",[t._v("IP协议控制传输的协议单元称为IP数据报（IP Datagram，IP数据报、IP包或IP分组）。IP协议屏蔽了下层各种物理子网的差异，能够向上层提供统一格式的IP数据报。")]),t._v(" "),v("p",[t._v("IP数据报采用数据报分组传输的方式，提供的服务是无连接方式。IP数据报的格式能够说明IP协议具有什么功能。")]),t._v(" "),v("p",[t._v("IPv4数据报由报头和数据两部分组成，其中，数据是高层需要传输的数据，报头是为了正确传输高层数据而增加的控制信息。报头的前一部分长度固定，共20字节，是所有IP数据报必须具有。在首部固定部分的后面是可选字段，长度可变。")]),t._v(" "),v("p",[t._v("特点如下：")]),t._v(" "),v("ul",[v("li",[t._v("每个分组自身携带有足够的信息，它的传送是被单独处理的")]),t._v(" "),v("li",[t._v("在整个传送过程中，不需建立虚电路")]),t._v(" "),v("li",[t._v("网络节点要为每个分组做出路由选择")])]),t._v(" "),v("h2",{attrs:{id:"encodeuri-和-encodeuricomponent-的区别i"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#encodeuri-和-encodeuricomponent-的区别i"}},[t._v("#")]),t._v(" encodeURI 和 encodeURIComponent 的区别I")]),t._v(" "),v("h2",{attrs:{id:"tcp波图和ip波图有哪些不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp波图和ip波图有哪些不同"}},[t._v("#")]),t._v(" TCP波图和ip波图有哪些不同")]),t._v(" "),v("h3",{attrs:{id:"如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段。"}},[t._v("#")]),t._v(" 如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段。")]),t._v(" "),v("h2",{attrs:{id:"nignx的原理，主要是来做什么的，为什么可以用来做跨域；"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nignx的原理，主要是来做什么的，为什么可以用来做跨域；"}},[t._v("#")]),t._v(" nignx的原理，主要是来做什么的，为什么可以用来做跨域；")]),t._v(" "),v("h2",{attrs:{id:"抓包工具有使用过吗？然后抓包只是抓http包吗-具体使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#抓包工具有使用过吗？然后抓包只是抓http包吗-具体使用场景"}},[t._v("#")]),t._v(" 抓包工具有使用过吗？然后抓包只是抓HTTP包吗, 具体使用场景")])])}),[],!1,null,null,null);a.default=s.exports}}]);