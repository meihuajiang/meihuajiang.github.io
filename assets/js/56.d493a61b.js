(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{315:function(e,t,a){"use strict";a.r(t);var n=a(9),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("说明")]),e._v(" "),a("p",[e._v("查阅文档使用")])]),e._v(" "),a("h2",{attrs:{id:"document节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document节点"}},[e._v("#")]),e._v(" Document节点⭐️")]),e._v(" "),a("p",[e._v("document节点对象代表整个文档，每张网页都有自己的document对象。")]),e._v(" "),a("p",[e._v("window.document属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。")]),e._v(" "),a("p",[e._v("document对象有不同的办法可以获取。")]),e._v(" "),a("ul",[a("li",[e._v("正常的网页，直接使用document或window.document。")]),e._v(" "),a("li",[e._v("iframe框架里面的网页，使用iframe节点的contentDocument属性。")]),e._v(" "),a("li",[e._v("Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。")]),e._v(" "),a("li",[e._v("内部节点的ownerDocument属性。")]),e._v(" "),a("li",[e._v("Node.prototype.getRootNode()")])]),e._v(" "),a("p",[e._v("document对象继承了EventTarget接口和Node接口，并且混入（mixin）了ParentNode接口。")]),e._v(" "),a("h3",{attrs:{id:"属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),a("h4",{attrs:{id:"document-doctype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-doctype"}},[e._v("#")]),e._v(" document.doctype")]),e._v(" "),a("p",[e._v("对于 HTML 文档来说，document对象一般有两个子节点。")]),e._v(" "),a("p",[e._v("第一个子节点是document.doctype，指向DOCTYPE节点，即文档类型（Document Type Declaration，简写DTD）节点。")]),e._v(" "),a("p",[e._v("HTML 的文档类型节点，一般写成!DOCTYPE html。如果网页没有声明 DTD，该属性返回null。")]),e._v(" "),a("blockquote",[a("p",[e._v("document.firstChild通常就返回这个节点。")])]),e._v(" "),a("h4",{attrs:{id:"document-documentelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-documentelement"}},[e._v("#")]),e._v(" document.documentElement⭐️")]),e._v(" "),a("p",[a("strong",[e._v("document.documentElement属性返回当前文档的根元素节点（root）。")])]),e._v(" "),a("p",[e._v("它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。")]),e._v(" "),a("p",[a("strong",[e._v("HTML网页的该属性，一般是html节点。")])]),e._v(" "),a("h4",{attrs:{id:"document-body，document-head"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-body，document-head"}},[e._v("#")]),e._v(" document.body，document.head")]),e._v(" "),a("p",[e._v("document.body属性指向body节点，document.head属性指向head节点。")]),e._v(" "),a("p",[e._v("这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。")]),e._v(" "),a("h4",{attrs:{id:"document-scrollingelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-scrollingelement"}},[e._v("#")]),e._v(" document.scrollingElement")]),e._v(" "),a("p",[e._v("document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。")]),e._v(" "),a("p",[e._v("标准模式下，这个属性返回的文档的根元素document.documentElement（即html）。")]),e._v(" "),a("p",[e._v("兼容（quirk）模式下，返回的是body元素，如果该元素不存在，返回null。")]),e._v(" "),a("h4",{attrs:{id:"document-activeelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-activeelement"}},[e._v("#")]),e._v(" document.activeElement")]),e._v(" "),a("p",[e._v("document.activeElement属性返回获得当前焦点（focus）的 DOM 元素。")]),e._v(" "),a("p",[e._v("通常，这个属性返回的是input、textarea、select等表单元素，")]),e._v(" "),a("p",[e._v("如果当前没有焦点元素，返回body元素或null。")]),e._v(" "),a("h4",{attrs:{id:"document-fullscreenelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-fullscreenelement"}},[e._v("#")]),e._v(" document.fullscreenElement")]),e._v(" "),a("p",[e._v("document.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。")]),e._v(" "),a("p",[e._v("通过document.fullscreenElement可以知道video元素有没有处在全屏状态，从而判断用户行为。")]),e._v(" "),a("h3",{attrs:{id:"节点集合属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点集合属性"}},[e._v("#")]),e._v(" 节点集合属性")]),e._v(" "),a("p",[a("strong",[e._v("HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。")])]),e._v(" "),a("p",[e._v("如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。")]),e._v(" "),a("p",[e._v("以下属性返回一个HTMLCollection实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。")]),e._v(" "),a("h4",{attrs:{id:"document-links"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-links"}},[e._v("#")]),e._v(" document.links")]),e._v(" "),a("p",[e._v("document.links属性返回当前文档所有设定了href属性的a及area节点。")]),e._v(" "),a("h4",{attrs:{id:"document-forms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-forms"}},[e._v("#")]),e._v(" document.forms")]),e._v(" "),a("p",[e._v("document.forms属性返回所有form表单节点。")]),e._v(" "),a("p",[e._v("除了使用位置序号，id属性和name属性也可以用来引用表单")]),e._v(" "),a("h4",{attrs:{id:"document-images"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-images"}},[e._v("#")]),e._v(" document.images")]),e._v(" "),a("p",[e._v("document.images属性返回页面所有img图片节点。")]),e._v(" "),a("h4",{attrs:{id:"document-embeds，document-plugins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-embeds，document-plugins"}},[e._v("#")]),e._v(" document.embeds，document.plugins")]),e._v(" "),a("p",[e._v("document.embeds属性和document.plugins属性，都返回所有embed节点。")]),e._v(" "),a("h4",{attrs:{id:"document-scripts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-scripts"}},[e._v("#")]),e._v(" document.scripts")]),e._v(" "),a("p",[e._v("document.scripts属性返回所有script节点。")]),e._v(" "),a("h3",{attrs:{id:"文档静态信息属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档静态信息属性"}},[e._v("#")]),e._v(" 文档静态信息属性")]),e._v(" "),a("h4",{attrs:{id:"document-documenturi，document-url"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-documenturi，document-url"}},[e._v("#")]),e._v(" document.documentURI，document.URL")]),e._v(" "),a("p",[e._v("document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。")]),e._v(" "),a("p",[e._v("如果文档的锚点（"),a("code",[e._v("#anchor")]),e._v("）变化，这两个属性都会跟着变化。")]),e._v(" "),a("p",[e._v("不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；")]),e._v(" "),a("p",[e._v("URL继承自HTMLDocument接口，只能用于 HTML 文档。")]),e._v(" "),a("blockquote",[a("p",[e._v("Node.prototype.baseURI属性返回一个字符串，表示当前网页的绝对路径。")])]),e._v(" "),a("h4",{attrs:{id:"document-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-domain"}},[e._v("#")]),e._v(" document.domain")]),e._v(" "),a("p",[e._v("document.domain属性返回当前文档的域名，不包含协议和端口")]),e._v(" "),a("p",[e._v("document.domain基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把document.domain设为对应的上级域名。")]),e._v(" "),a("p",[e._v("比如，当前域名是a.sub.example.com，则document.domain属性可以设置为sub.example.com，也可以设为example.com。")]),e._v(" "),a("p",[e._v("修改后，document.domain相同的两个网页，可以读取对方的资源，比如设置的 Cookie。")]),e._v(" "),a("p",[e._v("另外，设置document.domain会导致端口被改成null。")]),e._v(" "),a("p",[e._v("因此，如果通过设置document.domain来进行通信，双方网页都必须设置这个值，才能保证端口相同。")]),e._v(" "),a("h4",{attrs:{id:"document-location"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-location"}},[e._v("#")]),e._v(" document.location")]),e._v(" "),a("p",[e._v("Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。")]),e._v(" "),a("p",[e._v("通过window.location和document.location属性，可以拿到这个对象。")]),e._v(" "),a("h4",{attrs:{id:"document-lastmodified"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-lastmodified"}},[e._v("#")]),e._v(" document.lastModified")]),e._v(" "),a("p",[e._v("document.lastModified属性返回一个"),a("strong",[e._v("字符串")]),e._v("，表示当前文档最后修改的时间。")]),e._v(" "),a("p",[e._v("不同浏览器的返回值，日期格式是不一样的。")]),e._v(" "),a("h4",{attrs:{id:"document-title"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-title"}},[e._v("#")]),e._v(" document.title")]),e._v(" "),a("p",[e._v("document.title属性返回当前文档的标题。")]),e._v(" "),a("p",[e._v("默认情况下，返回title节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。")]),e._v(" "),a("h4",{attrs:{id:"document-characterset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-characterset"}},[e._v("#")]),e._v(" document.characterSet")]),e._v(" "),a("p",[e._v("document.characterSet属性返回当前文档的编码")]),e._v(" "),a("h4",{attrs:{id:"document-referrer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-referrer"}},[e._v("#")]),e._v(" document.referrer")]),e._v(" "),a("p",[e._v("document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。")]),e._v(" "),a("p",[e._v("如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，document.referrer返回一个空字符串。")]),e._v(" "),a("p",[e._v("document.referrer的值，总是与 HTTP 头信息的Referer字段保持一致。")]),e._v(" "),a("p",[e._v("但是，document.referrer的拼写有两个r，而头信息的Referer字段只有一个r（将错就错）。")]),e._v(" "),a("h3",{attrs:{id:"文档状态属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档状态属性"}},[e._v("#")]),e._v(" 文档状态属性")]),e._v(" "),a("h4",{attrs:{id:"document-hidden"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-hidden"}},[e._v("#")]),e._v(" document.hidden")]),e._v(" "),a("p",[e._v("document.hidden属性返回一个布尔值，表示当前页面是否可见。")]),e._v(" "),a("p",[e._v("如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。")]),e._v(" "),a("p",[e._v("这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。")]),e._v(" "),a("h4",{attrs:{id:"document-visibilitystate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-visibilitystate"}},[e._v("#")]),e._v(" document.visibilityState⭐️")]),e._v(" "),a("p",[e._v("document.visibilityState返回文档的可见状态。")]),e._v(" "),a("p",[e._v("它的值有四种可能。")]),e._v(" "),a("ul",[a("li",[e._v("visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。")]),e._v(" "),a("li",[e._v("hidden：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。")]),e._v(" "),a("li",[e._v("prerender：页面处于正在渲染状态，对于用户来说，该页面不可见。")]),e._v(" "),a("li",[e._v("unloaded：页面从内存里面卸载了。")])]),e._v(" "),a("h4",{attrs:{id:"document-readystate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-readystate"}},[e._v("#")]),e._v(" document.readyState")]),e._v(" "),a("p",[e._v("document.readyState属性返回当前文档的状态，共有三种可能的值。")]),e._v(" "),a("ul",[a("li",[e._v("loading：加载 HTML 代码阶段（尚未完成解析）")]),e._v(" "),a("li",[e._v("interactive：加载外部资源阶段")]),e._v(" "),a("li",[e._v("complete：加载完成")])]),e._v(" "),a("p",[e._v("这个属性变化的过程如下。")]),e._v(" "),a("ol",[a("li",[e._v("浏览器开始解析 HTML 文档，document.readyState属性等于loading。")]),e._v(" "),a("li",[e._v("浏览器遇到 HTML 文档中的script元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时document.readyState属性还是等于loading。")]),e._v(" "),a("li",[e._v("HTML 文档解析完成，document.readyState属性变成interactive。")]),e._v(" "),a("li",[e._v("浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document.readyState属性变成complete。")])]),e._v(" "),a("h4",{attrs:{id:"document-cookie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-cookie"}},[e._v("#")]),e._v(" document.cookie")]),e._v(" "),a("p",[e._v("document.cookie属性用来操作浏览器 Cookie")]),e._v(" "),a("h3",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),a("h4",{attrs:{id:"document-open-，document-close"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-open-，document-close"}},[e._v("#")]),e._v(" document.open()，document.close()")]),e._v(" "),a("p",[e._v("document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。")]),e._v(" "),a("p",[e._v("document.close方法用来关闭document.open()打开的文档。")]),e._v(" "),a("h4",{attrs:{id:"document-queryselector-，document-queryselectorall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-queryselector-，document-queryselectorall"}},[e._v("#")]),e._v(" document.querySelector()，document.querySelectorAll()⭐️")]),e._v(" "),a("p",[e._v("document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。")]),e._v(" "),a("p",[a("strong",[e._v("如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。")])]),e._v(" "),a("p",[e._v("document.querySelectorAll方法与querySelector用法类似，区别是返回一个NodeList对象，包含所有匹配给定选择器的节点。")]),e._v(" "),a("p",[e._v("这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。")]),e._v(" "),a("p",[e._v("这两个方法都支持复杂的 CSS 选择器。")]),e._v(" "),a("p",[a("strong",[e._v("它们不支持 CSS 伪元素的选择器（比如:first-line和:first-letter）和伪类的选择器（比如:link和:visited），即无法选中伪元素和伪类。")])]),e._v(" "),a("p",[e._v("如果querySelectorAll方法的参数是字符串*，则会返回文档中的所有元素节点。")]),e._v(" "),a("p",[a("strong",[e._v("另外，querySelectorAll的返回结果不是动态集合，不会实时反映元素节点的变化。")])]),e._v(" "),a("p",[e._v("这两个方法除了定义在document对象上，还定义在元素节点上，即在元素节点上也可以调用。")]),e._v(" "),a("h4",{attrs:{id:"document-getelementsbytagname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-getelementsbytagname"}},[e._v("#")]),e._v(" document.getElementsByTagName()⭐️")]),e._v(" "),a("p",[a("code",[e._v("document.getElementsByTagName()")]),e._v("方法搜索 HTML 标签名，返回符合条件的元素。")]),e._v(" "),a("p",[e._v("它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。")]),e._v(" "),a("p",[e._v("如果没有任何匹配的元素，就返回一个空集。")]),e._v(" "),a("p",[a("strong",[e._v("HTML 标签名是大小写不敏感的，因此getElementsByTagName()方法的参数也是大小写不敏感的。")])]),e._v(" "),a("p",[e._v("另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。")]),e._v(" "),a("p",[e._v("如果传入*，就可以返回文档中所有 HTML 元素。")]),e._v(" "),a("p",[e._v("元素节点本身也定义了getElementsByTagName方法，返回该元素的后代元素中符合条件的元素。")]),e._v(" "),a("p",[e._v("也就是说，这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。")]),e._v(" "),a("h4",{attrs:{id:"document-getelementsbyclassname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-getelementsbyclassname"}},[e._v("#")]),e._v(" document.getElementsByClassName()⭐️")]),e._v(" "),a("p",[a("code",[e._v("document.getElementsByClassName()")]),e._v("方法返回一个类似数组的对象（HTMLCollection实例）")]),e._v(" "),a("p",[e._v("包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。")]),e._v(" "),a("p",[e._v("由于class是保留字，所以 JavaScript 一律使用className表示 CSS 的class。")]),e._v(" "),a("p",[e._v("参数可以是多个class，它们之间使用空格分隔。顺序不重要")]),e._v(" "),a("blockquote",[a("p",[e._v("正常模式下，CSS 的class是大小写敏感的。")])]),e._v(" "),a("h4",{attrs:{id:"document-getelementsbyname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-getelementsbyname"}},[e._v("#")]),e._v(" document.getElementsByName()")]),e._v(" "),a("p",[e._v("document.getElementsByName()方法用于选择拥有name属性的 HTML 元素")]),e._v(" "),a("p",[e._v("返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。")]),e._v(" "),a("h4",{attrs:{id:"document-getelementbyid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-getelementbyid"}},[e._v("#")]),e._v(" document.getElementById()")]),e._v(" "),a("p",[e._v("document.getElementById()方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。")]),e._v(" "),a("p",[e._v("该方法的参数是大小写敏感的")]),e._v(" "),a("h4",{attrs:{id:"document-createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createelement"}},[e._v("#")]),e._v(" document.createElement()")]),e._v(" "),a("p",[e._v("document.createElement方法用来生成元素节点，并返回该节点。")]),e._v(" "),a("p",[e._v("createElement方法的参数为元素的标签名，即元素节点的tagName属性，对于 HTML 网页大小写不敏感")]),e._v(" "),a("p",[e._v("document.createElement的参数可以是自定义的标签名。")]),e._v(" "),a("h4",{attrs:{id:"document-createtextnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createtextnode"}},[e._v("#")]),e._v(" document.createTextNode()")]),e._v(" "),a("p",[e._v("document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。")]),e._v(" "),a("p",[e._v("这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。")]),e._v(" "),a("h4",{attrs:{id:"document-createattribute"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createattribute"}},[e._v("#")]),e._v(" document.createAttribute()")]),e._v(" "),a("p",[e._v("document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。")]),e._v(" "),a("p",[a("code",[e._v("var attribute = document.createAttribute(name);")])]),e._v(" "),a("p",[e._v("document.createAttribute方法的参数name，是属性的名称。")]),e._v(" "),a("h4",{attrs:{id:"document-createcomment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createcomment"}},[e._v("#")]),e._v(" document.createComment()")]),e._v(" "),a("p",[e._v("document.createComment方法生成一个新的注释节点，并返回该节点。")]),e._v(" "),a("p",[a("code",[e._v("var CommentNode = document.createComment(data);")])]),e._v(" "),a("p",[e._v("document.createComment方法的参数是一个字符串，会成为注释节点的内容。")]),e._v(" "),a("h4",{attrs:{id:"document-createdocumentfragment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createdocumentfragment"}},[e._v("#")]),e._v(" document.createDocumentFragment()⭐️")]),e._v(" "),a("p",[e._v("document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。")]),e._v(" "),a("p",[a("code",[e._v("var docFragment = document.createDocumentFragment();")])]),e._v(" "),a("p",[e._v("DocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。")]),e._v(" "),a("p",[e._v("这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。")]),e._v(" "),a("h4",{attrs:{id:"document-createevent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createevent"}},[e._v("#")]),e._v(" document.createEvent()")]),e._v(" "),a("p",[e._v("document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。")]),e._v(" "),a("p",[e._v("document.createEvent方法的参数是事件类型，比如UIEvents、MouseEvents、MutationEvents、HTMLEvents。")]),e._v(" "),a("h4",{attrs:{id:"document-addeventlistener-，document-removeeventlistener-，document-dispatchevent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-addeventlistener-，document-removeeventlistener-，document-dispatchevent"}},[e._v("#")]),e._v(" document.addEventListener()，document.removeEventListener()，document.dispatchEvent()")]),e._v(" "),a("p",[e._v("这三个方法用于处理document节点的事件。它们都继承自EventTarget接口")]),e._v(" "),a("h4",{attrs:{id:"document-hasfocus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-hasfocus"}},[e._v("#")]),e._v(" document.hasFocus()")]),e._v(" "),a("p",[e._v("document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。")]),e._v(" "),a("h4",{attrs:{id:"document-createnodeiterator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createnodeiterator"}},[e._v("#")]),e._v(" document.createNodeIterator()⭐️")]),e._v(" "),a("p",[e._v("document.createNodeIterator方法返回一个子节点遍历器。")]),e._v(" "),a("p",[e._v("返回一个“遍历器”对象（NodeFilter实例）。该实例的nextNode()方法和previousNode()方法，可以用来遍历所有子节点。")]),e._v(" "),a("p",[e._v("document.createNodeIterator方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型")]),e._v(" "),a("p",[e._v("这里指定为元素节点（NodeFilter.SHOW_ELEMENT）。几种主要的节点类型写法如下。")]),e._v(" "),a("ul",[a("li",[e._v("所有节点：NodeFilter.SHOW_ALL")]),e._v(" "),a("li",[e._v("元素节点：NodeFilter.SHOW_ELEMENT")]),e._v(" "),a("li",[e._v("文本节点：NodeFilter.SHOW_TEXT")]),e._v(" "),a("li",[e._v("评论节点：NodeFilter.SHOW_COMMENT")])]),e._v(" "),a("h4",{attrs:{id:"document-createtreewalker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-createtreewalker"}},[e._v("#")]),e._v(" document.createTreeWalker()⭐️")]),e._v(" "),a("p",[e._v("document.createTreeWalker方法返回一个 DOM 的子树遍历器。")]),e._v(" "),a("p",[e._v("它与document.createNodeIterator方法基本是类似的，")]),e._v(" "),a("p",[e._v("区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。")]),e._v(" "),a("p",[e._v("另外，它的第一个节点不是根节点。")]),e._v(" "),a("p",[e._v("document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型")]),e._v(" "),a("blockquote",[a("p",[e._v("与document.createNodeIterator方法的第二个参数相同。")])]),e._v(" "),a("h3",{attrs:{id:"新建节点的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新建节点的方法"}},[e._v("#")]),e._v(" 新建节点的方法")]),e._v(" "),a("ul",[a("li",[e._v("document.createElement()")]),e._v(" "),a("li",[e._v("document.createTextNode()")]),e._v(" "),a("li",[e._v("document.createAttribute()")]),e._v(" "),a("li",[e._v("document.createComment()")]),e._v(" "),a("li",[e._v("document.createDocumentFragment()(文档片段对象)")])]),e._v(" "),a("h2",{attrs:{id:"element-节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-节点"}},[e._v("#")]),e._v(" Element 节点")]),e._v(" "),a("p",[e._v("每一个 HTML 元素，在 DOM 树上都会转化成一个Element节点对象（以下简称元素节点）。")]),e._v(" "),a("p",[e._v("元素节点的nodeType属性都是1。")]),e._v(" "),a("p",[e._v("不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点")]),e._v(" "),a("h3",{attrs:{id:"元素特性的相关属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元素特性的相关属性"}},[e._v("#")]),e._v(" 元素特性的相关属性")]),e._v(" "),a("h4",{attrs:{id:"element-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-id"}},[e._v("#")]),e._v(" Element.id")]),e._v(" "),a("p",[e._v("Element.id属性返回指定元素的id属性，该属性可读写。")]),e._v(" "),a("p",[e._v("注意，id属性的值是大小写敏感")]),e._v(" "),a("h4",{attrs:{id:"element-tagname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-tagname"}},[e._v("#")]),e._v(" Element.tagName")]),e._v(" "),a("p",[e._v("Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。")]),e._v(" "),a("h4",{attrs:{id:"element-accesskey"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-accesskey"}},[e._v("#")]),e._v(" Element.accessKey")]),e._v(" "),a("p",[e._v("Element.accessKey属性用于读写分配给当前元素的快捷键。")]),e._v(" "),a("h4",{attrs:{id:"element-draggable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-draggable"}},[e._v("#")]),e._v(" Element.draggable")]),e._v(" "),a("p",[e._v("Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。")]),e._v(" "),a("h4",{attrs:{id:"element-tabindex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-tabindex"}},[e._v("#")]),e._v(" Element.tabIndex")]),e._v(" "),a("p",[e._v("Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。")]),e._v(" "),a("p",[e._v("tabIndex属性值如果是负值（通常是-1），则 Tab 键不会遍历到该元素。")]),e._v(" "),a("p",[e._v("如果是正整数，则按照顺序，从小到大遍历。")]),e._v(" "),a("p",[e._v("如果两个元素的tabIndex属性的正整数值相同，则按照出现的顺序遍历。")]),e._v(" "),a("p",[e._v("遍历完所有tabIndex为正整数的元素以后，再遍历所有tabIndex等于0、或者属性值是非法值、或者没有tabIndex属性的元素，")]),e._v(" "),a("blockquote",[a("p",[e._v("顺序为它们在网页中出现的顺序。")])]),e._v(" "),a("h4",{attrs:{id:"element-title"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-title"}},[e._v("#")]),e._v(" Element.title")]),e._v(" "),a("p",[e._v("Element.title属性用来读写当前元素的 HTML 属性title。")]),e._v(" "),a("p",[e._v("该属性通常用来指定，鼠标悬浮时弹出的文字提示框。")]),e._v(" "),a("h3",{attrs:{id:"元素状态的相关属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元素状态的相关属性"}},[e._v("#")]),e._v(" 元素状态的相关属性⭐️")]),e._v(" "),a("h4",{attrs:{id:"element-hidden"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-hidden"}},[e._v("#")]),e._v(" Element.hidden")]),e._v(" "),a("p",[e._v("Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。")]),e._v(" "),a("p",[e._v("注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，Element.hidden并不能反映出来。")]),e._v(" "),a("p",[e._v("也就是说，这个属性并不能用来判断当前元素的实际可见性。")]),e._v(" "),a("p",[e._v("CSS 的设置高于Element.hidden。这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。")]),e._v(" "),a("h4",{attrs:{id:"element-attributes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-attributes"}},[e._v("#")]),e._v(" Element.attributes")]),e._v(" "),a("p",[e._v("Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点")]),e._v(" "),a("h4",{attrs:{id:"element-classname，element-classlist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-classname，element-classlist"}},[e._v("#")]),e._v(" Element.className，Element.classList")]),e._v(" "),a("p",[e._v("className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。")]),e._v(" "),a("p",[e._v("classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。")]),e._v(" "),a("p",[e._v("classList对象有下列方法。")]),e._v(" "),a("ul",[a("li",[e._v("add()：增加一个 class。")]),e._v(" "),a("li",[e._v("remove()：移除一个 class。")]),e._v(" "),a("li",[e._v("contains()：检查当前元素是否包含某个 class。")]),e._v(" "),a("li",[e._v("toggle()：将某个 class 移入或移出当前元素。")]),e._v(" "),a("li",[e._v("item()：返回指定索引位置的 class。")]),e._v(" "),a("li",[e._v("toString()：将 class 的列表转为字符串。")])]),e._v(" "),a("h4",{attrs:{id:"element-dataset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-dataset"}},[e._v("#")]),e._v(" Element.dataset")]),e._v(" "),a("p",[e._v("网页元素可以自定义data-属性，用来添加数据。")]),e._v(" "),a("p",[e._v("Element.dataset属性返回一个对象，可以从这个对象读写data-属性。")]),e._v(" "),a("blockquote",[a("p",[e._v("开头的data-会省略。如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。")])]),e._v(" "),a("p",[e._v('如，data-abc-def对应dataset.abcDef，data-abc-1对应dataset["abc-1"]。')]),e._v(" "),a("p",[e._v("使用Element.getAttribute()和Element.setAttribute()，通过完整的属性名读写这些属性。")]),e._v(" "),a("h4",{attrs:{id:"element-innerhtml"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-innerhtml"}},[e._v("#")]),e._v(" Element.innerHTML⭐️")]),e._v(" "),a("p",[e._v("Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。")]),e._v(" "),a("p",[e._v("该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括HTML和body元素。")]),e._v(" "),a("p",[a("strong",[e._v("如果将innerHTML属性设为空，等于删除所有它包含的所有节点。")])]),e._v(" "),a("p",[e._v("如果文本节点包含&、小于号（<）和大于号（>），innerHTML属性会将它们转为实体形式&、<、>。")]),e._v(" "),a("p",[e._v("如果想得到原文，建议使用element.textContent属性。")]),e._v(" "),a("p",[e._v("如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，")]),e._v(" "),a("p",[a("strong",[e._v("如果文本之中含有script标签，虽然可以生成script节点，但是插入的代码不会执行。")])]),e._v(" "),a("p",[e._v("但是，innerHTML还是有安全风险的。比如alert方法是会执行的")]),e._v(" "),a("h4",{attrs:{id:"element-outerhtml"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-outerhtml"}},[e._v("#")]),e._v(" Element.outerHTML")]),e._v(" "),a("p",[e._v("Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。")]),e._v(" "),a("h4",{attrs:{id:"element-clientheight，element-clientwidth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-clientheight，element-clientwidth"}},[e._v("#")]),e._v(" Element.clientHeight，Element.clientWidth")]),e._v(" "),a("p",[e._v("Element.clientHeight属性返回一个整数值，表示元素节点的 CSS 高度（单位像素）")]),e._v(" "),a("p",[e._v("只对块级元素生效，对于行内元素返回0。如果块级元素没有设置 CSS 高度，则返回实际高度。")]),e._v(" "),a("p",[a("strong",[e._v("除了元素本身的高度，它还包括padding部分，但是不包括border、margin。")])]),e._v(" "),a("p",[e._v("如果有水平滚动条，还要减去水平滚动条的高度。")]),e._v(" "),a("p",[e._v("Element.clientWidth属性返回元素节点的 CSS 宽度，同样只对块级元素有效")]),e._v(" "),a("p",[e._v("也是只包括元素本身的宽度和padding，如果有垂直滚动条，还要减去垂直滚动条的宽度。")]),e._v(" "),a("p",[a("strong",[e._v("document.documentElement的clientHeight属性，返回当前视口的高度（即浏览器窗口的高度）")])]),e._v(" "),a("p",[a("strong",[e._v("等同于window.innerHeight属性减去水平滚动条的高度（如果有的话）。")])]),e._v(" "),a("p",[a("strong",[e._v("document.body的高度则是网页的实际高度。")])]),e._v(" "),a("p",[e._v("一般来说，document.body.clientHeight大于document.documentElement.clientHeight。")]),e._v(" "),a("h4",{attrs:{id:"element-clientleft，element-clienttop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-clientleft，element-clienttop"}},[e._v("#")]),e._v(" Element.clientLeft，Element.clientTop")]),e._v(" "),a("p",[a("strong",[e._v("Element.clientLeft属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的padding和margin。")])]),e._v(" "),a("p",[e._v("如果没有设置左边框，或者是行内元素（display: inline），该属性返回0。")]),e._v(" "),a("p",[e._v("该属性总是返回整数值，如果是小数，会四舍五入。")]),e._v(" "),a("p",[e._v("Element.clientTop属性等于网页元素顶部边框的宽度（单位像素），其他特点都与clientLeft相同。")]),e._v(" "),a("h4",{attrs:{id:"element-scrollheight，element-scrollwidth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-scrollheight，element-scrollwidth"}},[e._v("#")]),e._v(" Element.scrollHeight，Element.scrollWidth")]),e._v(" "),a("p",[a("strong",[e._v("Element.scrollHeight属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。")])]),e._v(" "),a("p",[a("strong",[e._v("它包括padding，但是不包括border、margin以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（::before或::after）的高度。")])]),e._v(" "),a("p",[e._v("Element.scrollWidth属性表示当前元素的总宽度（单位像素），其他地方都与scrollHeight属性类似。这两个属性只读。")]),e._v(" "),a("p",[e._v("整张网页的总高度可以从"),a("strong",[e._v("document.documentElement或document.body")]),e._v("上读取。")]),e._v(" "),a("h4",{attrs:{id:"element-scrollleft，element-scrolltop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-scrollleft，element-scrolltop"}},[e._v("#")]),e._v(" Element.scrollLeft，Element.scrollTop")]),e._v(" "),a("p",[e._v("Element.scrollLeft属性表示当前元素的水平滚动条向"),a("strong",[e._v("右侧")]),e._v("滚动的像素数量，")]),e._v(" "),a("p",[e._v("Element.scrollTop属性表示当前元素的垂直滚动条"),a("strong",[e._v("向下")]),e._v("滚动的像素数量。")]),e._v(" "),a("p",[e._v("对于那些没有滚动条的网页元素，这两个属性总是等于0。")]),e._v(" "),a("p",[e._v("如果要查看整张网页的水平的和垂直的滚动距离，要从"),a("strong",[e._v("document.documentElement元素")]),e._v("上读取。")]),e._v(" "),a("h4",{attrs:{id:"element-offsetparent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-offsetparent"}},[e._v("#")]),e._v(" Element.offsetParent")]),e._v(" "),a("p",[a("strong",[e._v("Element.offsetParent属性返回最靠近当前元素的、并且 CSS 的position属性不等于static的上层元素。")])]),e._v(" "),a("p",[e._v("该属性主要用于确定子元素位置偏移的计算基准，Element.offsetTop和Element.offsetLeft就是offsetParent元素计算的。")]),e._v(" "),a("p",[a("strong",[e._v("如果该元素是不可见的（display属性为none），或者位置是固定的（position属性为fixed），则offsetParent属性返回null。")])]),e._v(" "),a("h4",{attrs:{id:"element-offsetheight，element-offsetwidth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-offsetheight，element-offsetwidth"}},[e._v("#")]),e._v(" Element.offsetHeight，Element.offsetWidth")]),e._v(" "),a("p",[e._v("Element.offsetHeight属性返回一个整数，表示元素的 CSS 垂直高度（单位像素）")]),e._v(" "),a("p",[a("strong",[e._v("包括元素本身的高度、padding 和 border，以及水平滚动条的高度（如果存在滚动条）。")])]),e._v(" "),a("p",[e._v("Element.offsetWidth属性表示元素的 CSS 水平宽度（单位像素），其他都与Element.offsetHeight一致。")]),e._v(" "),a("p",[a("strong",[e._v("这两个属性都是只读属性，只比Element.clientHeight和Element.clientWidth多了边框的高度或宽度。")])]),e._v(" "),a("p",[a("strong",[e._v("如果元素的 CSS 设为不可见（比如display: none;），则返回0。")])]),e._v(" "),a("h4",{attrs:{id:"element-offsetleft，element-offsettop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-offsetleft，element-offsettop"}},[e._v("#")]),e._v(" Element.offsetLeft，Element.offsetTop⭐️")]),e._v(" "),a("p",[e._v("Element.offsetLeft返回当前元素左上角相对于Element.offsetParent节点的水平位移")]),e._v(" "),a("p",[e._v("Element.offsetTop返回垂直位移，单位为像素。")]),e._v(" "),a("p",[e._v("通常，这两个值是指相对于父节点的位移。")]),e._v(" "),a("p",[e._v("下面的代码可以算出元素左上角相对于整张网页的坐标。")]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getElementPosition")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("e")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("while")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("e "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!==")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t\tx "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+=")]),e._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("offsetLeft"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\ty "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+=")]),e._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("offsetTop"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\te "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("offsetParent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("x"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h4",{attrs:{id:"element-children，element-childelementcount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-children，element-childelementcount"}},[e._v("#")]),e._v(" Element.children，Element.childElementCount⭐️")]),e._v(" "),a("p",[e._v("Element.children属性返回一个类似数组的对象（HTMLCollection实例）")]),e._v(" "),a("p",[e._v("包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。")]),e._v(" "),a("p",[a("strong",[e._v("这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。")])]),e._v(" "),a("p",[e._v("Element.childElementCount属性返回当前元素节点包含的子元素节点的个数，与Element.children.length的值相同。")]),e._v(" "),a("h4",{attrs:{id:"element-firstelementchild，element-lastelementchild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-firstelementchild，element-lastelementchild"}},[e._v("#")]),e._v(" Element.firstElementChild，Element.lastElementChild")]),e._v(" "),a("p",[e._v("Element.firstElementChild属性返回当前元素的第一个元素子节点，")]),e._v(" "),a("p",[e._v("Element.lastElementChild返回最后一个元素子节点。")]),e._v(" "),a("p",[e._v("如果没有元素子节点，这两个属性返回null。")]),e._v(" "),a("h4",{attrs:{id:"element-nextelementsibling，element-previouselementsibling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-nextelementsibling，element-previouselementsibling"}},[e._v("#")]),e._v(" Element.nextElementSibling，Element.previousElementSibling")]),e._v(" "),a("p",[e._v("Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。")]),e._v(" "),a("p",[e._v("Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。")]),e._v(" "),a("h3",{attrs:{id:"实例方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例方法"}},[e._v("#")]),e._v(" 实例方法")]),e._v(" "),a("h4",{attrs:{id:"属性相关方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性相关方法"}},[e._v("#")]),e._v(" 属性相关方法")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("方法")]),e._v(" "),a("th",[e._v("描述")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("getAttribute()")]),e._v(" "),a("td",[e._v("读取某个属性的值")])]),e._v(" "),a("tr",[a("td",[e._v("getAttributeNames()")]),e._v(" "),a("td",[e._v("返回当前元素的所有属性名")])]),e._v(" "),a("tr",[a("td",[e._v("setAttribute()")]),e._v(" "),a("td",[e._v("写入属性值")])]),e._v(" "),a("tr",[a("td",[e._v("hasAttribute()")]),e._v(" "),a("td",[e._v("某个属性是否存在")])]),e._v(" "),a("tr",[a("td",[e._v("hasAttributes()")]),e._v(" "),a("td",[e._v("当前元素是否有属性")])]),e._v(" "),a("tr",[a("td",[e._v("removeAttribute()")]),e._v(" "),a("td",[e._v("删除属性")])])])]),e._v(" "),a("p",[e._v("这六个方法对所有属性（包括用户自定义的属性）都适用。")]),e._v(" "),a("p",[e._v("getAttribute()只返回字符串，不会返回其他类型的值。")]),e._v(" "),a("p",[e._v("这些方法只接受属性的标准名称，不用改写保留字，比如for和class都可以直接使用。")]),e._v(" "),a("p",[e._v("另外，这些方法对于属性名是大小写不敏感的。")]),e._v(" "),a("h4",{attrs:{id:"element-queryselector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-queryselector"}},[e._v("#")]),e._v(" Element.querySelector()")]),e._v(" "),a("p",[e._v("Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。")]),e._v(" "),a("p",[e._v("如果没有找到匹配的子元素，就返回null。")]),e._v(" "),a("p",[e._v("注意，这个方法无法选中伪元素。")]),e._v(" "),a("p",[e._v("它可以接受多个选择器，它们之间使用逗号分隔。")]),e._v(" "),a("h4",{attrs:{id:"element-queryselectorall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-queryselectorall"}},[e._v("#")]),e._v(" Element.querySelectorAll()")]),e._v(" "),a("p",[e._v("Element.querySelectorAll方法接受 CSS 选择器作为参数，"),a("strong",[e._v("返回一个NodeList实例")]),e._v("，包含所有匹配的子元素。")]),e._v(" "),a("p",[e._v("该方法的执行机制与querySelector方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。")]),e._v(" "),a("p",[e._v("它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。")]),e._v(" "),a("p",[e._v("如果选择器里面有伪元素的选择器，则总是返回一个空的NodeList实例。")]),e._v(" "),a("h4",{attrs:{id:"element-getelementsbyclassname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-getelementsbyclassname"}},[e._v("#")]),e._v(" Element.getElementsByClassName()")]),e._v(" "),a("p",[e._v("Element.getElementsByClassName方法"),a("strong",[e._v("返回一个HTMLCollection实例")])]),e._v(" "),a("p",[e._v("成员是当前元素节点的所有具有指定 class 的子元素节点。")]),e._v(" "),a("p",[e._v("该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。")]),e._v(" "),a("p",[e._v("该方法的参数大小写敏感。")]),e._v(" "),a("h4",{attrs:{id:"element-getelementsbytagname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-getelementsbytagname"}},[e._v("#")]),e._v(" Element.getElementsByTagName()")]),e._v(" "),a("p",[e._v("Element.getElementsByTagName()方法返回一个HTMLCollection实例，")]),e._v(" "),a("p",[e._v("成员是当前节点的所有匹配指定标签名的子元素节点。")]),e._v(" "),a("p",[e._v("该方法与document.getElementsByClassName()方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。")]),e._v(" "),a("h4",{attrs:{id:"element-matches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-matches"}},[e._v("#")]),e._v(" Element.matches()")]),e._v(" "),a("p",[e._v("Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器")]),e._v(" "),a("h4",{attrs:{id:"事件相关方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件相关方法"}},[e._v("#")]),e._v(" 事件相关方法")]),e._v(" "),a("p",[e._v("以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口")]),e._v(" "),a("ul",[a("li",[e._v("Element.addEventListener()：添加事件的回调函数")]),e._v(" "),a("li",[e._v("Element.removeEventListener()：移除事件监听函数")]),e._v(" "),a("li",[e._v("Element.dispatchEvent()：触发事件")])]),e._v(" "),a("h4",{attrs:{id:"element-scrollintoview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-scrollintoview"}},[e._v("#")]),e._v(" Element.scrollIntoView()")]),e._v(" "),a("p",[e._v("Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。")]),e._v(" "),a("p",[e._v("参数：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("alignToTop可选，一个Boolean值：")]),e._v(" "),a("p",[e._v('如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的 scrollIntoViewOptions: {block: "start", inline: "nearest"}。这是这个参数的默认值。')]),e._v(" "),a("p",[e._v('如果为false，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的scrollIntoViewOptions: {block: "end", inline: "nearest"}。')])]),e._v(" "),a("li",[a("p",[e._v("scrollIntoViewOptions 可选，一个包含下列属性的对象：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("behavior 可选")]),e._v(" "),a("p",[e._v('定义动画过渡效果， "auto"或 "smooth" 之一。默认为 "auto"。')])]),e._v(" "),a("li",[a("p",[e._v("block 可选")]),e._v(" "),a("p",[e._v('定义垂直方向的对齐， "start", "center", "end", 或 "nearest"之一。默认为 "start"。')])]),e._v(" "),a("li",[a("p",[e._v("inline 可选")]),e._v(" "),a("p",[e._v('定义水平方向的对齐， "start", "center", "end", 或 "nearest"之一。默认为 "nearest"。')])])])])]),e._v(" "),a("h4",{attrs:{id:"element-getboundingclientrect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-getboundingclientrect"}},[e._v("#")]),e._v(" Element.getBoundingClientRect()⭐️")]),e._v(" "),a("p",[e._v("Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息")]),e._v(" "),a("p",[a("strong",[e._v("用于懒加载判断元素是否进入可视区域")])]),e._v(" "),a("p",[e._v("getBoundingClientRect方法返回的rect对象，具有以下属性（全部为只读）。")]),e._v(" "),a("ul",[a("li",[e._v("x：元素左上角相对于视口的横坐标")]),e._v(" "),a("li",[e._v("y：元素左上角相对于视口的纵坐标")]),e._v(" "),a("li",[e._v("height：元素高度")]),e._v(" "),a("li",[e._v("width：元素宽度")]),e._v(" "),a("li",[e._v("left：元素左上角相对于视口的横坐标，与x属性相等")]),e._v(" "),a("li",[e._v("right：元素右边界相对于视口的横坐标（等于x + width）")]),e._v(" "),a("li",[e._v("top：元素顶部相对于视口的纵坐标，与y属性相等")]),e._v(" "),a("li",[e._v("bottom：元素底部相对于视口的纵坐标（等于y + height）")])]),e._v(" "),a("p",[e._v("由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。")]),e._v(" "),a("p",[e._v("如果想得到绝对位置，可以将left属性加上window.scrollX，top属性加上window.scrollY。")]),e._v(" "),a("p",[e._v("getBoundingClientRect方法的所有属性，都把边框（border属性）算作元素的一部分。")]),e._v(" "),a("p",[e._v("都是从边框外缘的各个点来计算。")]),e._v(" "),a("p",[e._v("因此，"),a("strong",[e._v("width和height包括了元素本身 + padding + border。")])]),e._v(" "),a("p",[a("strong",[e._v("上面的这些属性，都是继承自原型的属性，Object.keys会返回一个空数组")])]),e._v(" "),a("h4",{attrs:{id:"element-getclientrects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-getclientrects"}},[e._v("#")]),e._v(" Element.getClientRects()")]),e._v(" "),a("p",[e._v("Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。")]),e._v(" "),a("p",[e._v("每个矩形都有height、width、left、right、top和bottom六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。")]),e._v(" "),a("p",[e._v("对于盒状元素，该方法返回的对象中只有该元素一个成员。")]),e._v(" "),a("p",[e._v("对于行内元素，该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。")]),e._v(" "),a("p",[e._v("这是它和Element.getBoundingClientRect()方法的主要区别，后者对于行内元素总是返回一个矩形。")]),e._v(" "),a("h4",{attrs:{id:"element-insertadjacentelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-insertadjacentelement"}},[e._v("#")]),e._v(" Element.insertAdjacentElement()")]),e._v(" "),a("p",[e._v("Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。")]),e._v(" "),a("p",[e._v("该方法返回被插入的节点，如果插入失败，返回null。")]),e._v(" "),a("p",[a("code",[e._v("element.insertAdjacentElement(position, element);")])]),e._v(" "),a("p",[e._v("Element.insertAdjacentElement方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，")]),e._v(" "),a("p",[e._v("第二个参数是将要插入的节点。")]),e._v(" "),a("h4",{attrs:{id:"element-insertadjacenthtml-，element-insertadjacenttext"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-insertadjacenthtml-，element-insertadjacenttext"}},[e._v("#")]),e._v(" Element.insertAdjacentHTML()，Element.insertAdjacentText()")]),e._v(" "),a("p",[e._v("Element.insertAdjacentHTML方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。")]),e._v(" "),a("p",[a("code",[e._v("element.insertAdjacentHTML(position, text);")])]),e._v(" "),a("p",[e._v("该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。")]),e._v(" "),a("p",[e._v("该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。")]),e._v(" "),a("p",[e._v("Element.insertAdjacentText方法在相对于当前节点的指定位置，插入一个文本节点，用法与Element.insertAdjacentHTML方法完全一致。")]),e._v(" "),a("h4",{attrs:{id:"element-remove"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-remove"}},[e._v("#")]),e._v(" Element.remove()")]),e._v(" "),a("p",[e._v("Element.remove方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。")]),e._v(" "),a("h4",{attrs:{id:"element-focus-，element-blur"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-focus-，element-blur"}},[e._v("#")]),e._v(" Element.focus()，Element.blur()")]),e._v(" "),a("p",[e._v("Element.focus方法用于将当前页面的焦点，转移到指定元素上。")]),e._v(" "),a("h3",{attrs:{id:"属性操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性操作"}},[e._v("#")]),e._v(" 属性操作")]),e._v(" "),a("h4",{attrs:{id:"element-attributes-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-attributes-属性"}},[e._v("#")]),e._v(" Element.attributes 属性")]),e._v(" "),a("p",[e._v("元素对象有一个attributes属性，返回一个类似数组的动态对象。")]),e._v(" "),a("p",[e._v("成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。")]),e._v(" "),a("p",[e._v("其他类型的节点对象，虽然也有attributes属性，但返回的都是null，因此可以把这个属性视为元素对象独有的。")]),e._v(" "),a("p",[e._v("单个属性可以通过序号引用，也可以通过属性名引用。")]),e._v(" "),a("h4",{attrs:{id:"element-getattribute"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-getattribute"}},[e._v("#")]),e._v(" Element.getAttribute()")]),e._v(" "),a("p",[e._v("Element.getAttribute方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。")]),e._v(" "),a("h4",{attrs:{id:"element-getattributenames"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-getattributenames"}},[e._v("#")]),e._v(" Element.getAttributeNames()")]),e._v(" "),a("p",[e._v("Element.getAttributeNames()返回一个数组，成员是当前元素的所有属性的名字。")]),e._v(" "),a("p",[e._v("如果当前元素没有任何属性，则返回一个空数组。")]),e._v(" "),a("p",[a("strong",[e._v("使用Element.attributes属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。")])]),e._v(" "),a("h4",{attrs:{id:"element-setattribute"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-setattribute"}},[e._v("#")]),e._v(" Element.setAttribute()")]),e._v(" "),a("p",[e._v("Element.setAttribute方法用于为当前元素节点新增属性。")]),e._v(" "),a("p",[e._v("如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。")]),e._v(" "),a("p",[e._v("属性值总是字符串，其他类型的值会自动转成字符串")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("特殊")]),e._v(" "),a("p",[e._v("对于button元素来说，布尔属性disable属性不需要属性值，")]),e._v(" "),a("p",[e._v("只要设置了就总是会生效，因此setAttribute方法里面可以将disabled属性设成任意值。")])]),e._v(" "),a("h4",{attrs:{id:"element-hasattribute"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-hasattribute"}},[e._v("#")]),e._v(" Element.hasAttribute()")]),e._v(" "),a("p",[e._v("Element.hasAttribute方法返回一个布尔值，表示当前元素节点是否包含指定属性。")]),e._v(" "),a("h4",{attrs:{id:"element-hasattributes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-hasattributes"}},[e._v("#")]),e._v(" Element.hasAttributes()")]),e._v(" "),a("p",[e._v("Element.hasAttributes方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回false，否则返回true。")]),e._v(" "),a("h4",{attrs:{id:"element-removeattribute"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element-removeattribute"}},[e._v("#")]),e._v(" Element.removeAttribute()")]),e._v(" "),a("p",[e._v("Element.removeAttribute方法移除指定属性。该方法没有返回值。")]),e._v(" "),a("h4",{attrs:{id:"dataset-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dataset-属性"}},[e._v("#")]),e._v(" dataset 属性⭐️")]),e._v(" "),a("p",[e._v("有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。")]),e._v(" "),a("p",[e._v("素节点对象的dataset属性，它指向一个对象，可以用来操作 HTML 元素标签的data-*属性")]),e._v(" "),a("p",[e._v("删除一个data-*属性，可以直接使用delete命令。")]),e._v(" "),a("p",[e._v("注意，data-后面的属性名有限制，只能包含字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。")]),e._v(" "),a("p",[e._v("而且，属性名不应该使用A到Z的大写字母，比如不能有data-helloWorld这样的属性名，而要写成data-hello-world。")]),e._v(" "),a("p",[e._v("转成dataset的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。")]),e._v(" "),a("p",[e._v("反过来，dataset的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。")]),e._v(" "),a("blockquote",[a("p",[e._v("比如，dataset.helloWorld会转成data-hello-world。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);