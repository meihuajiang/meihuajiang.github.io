(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{299:function(t,v,_){"use strict";_.r(v);var a=_(9),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),_("p",[t._v("超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。")]),t._v(" "),_("p",[t._v("它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。")]),t._v(" "),_("p",[t._v("HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。尽管通常基于 TCP/IP 层，但它可以在任何可靠的传输层上使用，也就是说，该协议不会像 UDP 那样静默的丢失消息.")]),t._v(" "),_("p",[t._v("HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接")]),t._v(" "),_("p",[t._v("为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。")]),t._v(" "),_("h3",{attrs:{id:"特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),_("ul",[_("li",[t._v("无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作")]),t._v(" "),_("li",[t._v("无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。")]),t._v(" "),_("li",[t._v("基于请求和响应：基本的特性，由客户端发起请求，服务端响应")]),t._v(" "),_("li",[t._v("简单快速、灵活")]),t._v(" "),_("li",[t._v("通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性")])]),t._v(" "),_("h3",{attrs:{id:"content-type"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#content-type"}},[t._v("#")]),t._v(" Content-Type")]),t._v(" "),_("p",[t._v("Content-Type 实体头部用于指示资源的MIME类型 media type 。")]),t._v(" "),_("p",[t._v("在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值")]),t._v(" "),_("div",{staticClass:"language-md extra-class"},[_("pre",{pre:!0,attrs:{class:"language-md"}},[_("code",[t._v("Content-Type: text/html; charset=utf-8\nContent-Type: multipart/form-data; boundary=something\n")])])]),_("p",[t._v("在通过HTML form提交生成的POST请求中，请求头的Content-Type由form元素上的enctype属性指定")]),t._v(" "),_("h4",{attrs:{id:"html-表单的-enctype-类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#html-表单的-enctype-类型"}},[t._v("#")]),t._v(" HTML 表单的 enctype 类型")]),t._v(" "),_("ul",[_("li",[t._v("application/x-www-form-urlencoded，在发送前编码所有字符（默认），数据被编码成以 '&' 分隔的键-值对, 同时以 '=' 分隔键和值.")]),t._v(" "),_("li",[t._v("multipart/form-data，不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。")]),t._v(" "),_("li",[t._v('text/plain，空格转换为 "+" 加号，但不对特殊字符编码。')])]),t._v(" "),_("h3",{attrs:{id:"http的keep-alive"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http的keep-alive"}},[t._v("#")]),t._v(" HTTP的keep-alive")]),t._v(" "),_("p",[t._v("每个HTTP连接完成后，其对应的TCP连接并不是每次都会关闭。从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这个头部字段：Connection:keep-alive，Keep-Alive不会永久保持连接，它有一个保持时间")]),t._v(" "),_("h3",{attrs:{id:"http如何实现持续连接，有没有其他方式实现长连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http如何实现持续连接，有没有其他方式实现长连接"}},[t._v("#")]),t._v(" HTTP如何实现持续连接，有没有其他方式实现长连接")]),t._v(" "),_("div",{staticClass:"language-md extra-class"},[_("pre",{pre:!0,attrs:{class:"language-md"}},[_("code",[t._v("Connection:keep-alive\n")])])]),_("p",[t._v("实现长连接的方式")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("WebSocket")])]),t._v(" "),_("li",[_("p",[t._v("iframe")]),t._v(" "),_("p",[t._v("在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。")])])]),t._v(" "),_("h3",{attrs:{id:"http的正向代理和反向代理，结合场景说说"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http的正向代理和反向代理，结合场景说说"}},[t._v("#")]),t._v(" HTTP的正向代理和反向代理，结合场景说说")]),t._v(" "),_("p",[t._v("正向代理：")]),t._v(" "),_("ul",[_("li",[t._v("普通模式")]),t._v(" "),_("li",[t._v("隧道模式")])]),t._v(" "),_("h2",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("p",[t._v("HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。")]),t._v(" "),_("p",[t._v("它跟HTTP协议一样都是应用层协议，都是工作在TCP协议之上。")]),t._v(" "),_("h3",{attrs:{id:"特点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),_("ul",[_("li",[t._v("内容加密：采用混合加密技术，中间者无法直接查看明文内容")]),t._v(" "),_("li",[t._v("验证身份：通过证书认证客户端访问的是自己的服务器")]),t._v(" "),_("li",[t._v("保护数据完整性：防止传输的内容被中间人冒充或者篡改")])]),t._v(" "),_("h3",{attrs:{id:"https和http的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https和http的区别"}},[t._v("#")]),t._v(" HTTPS和HTTP的区别")]),t._v(" "),_("ul",[_("li",[t._v("HTTP协议工作在80端口，HTTPS协议工作在443端口")]),t._v(" "),_("li",[t._v("HTTPS需要申请证书（用于验证服务器身份）")]),t._v(" "),_("li",[t._v("HTTP在TCP三次握手建立连接之后即可开始传输数据；HTTPS协议则需要在建立TCP连接之后客户端与服务器在进行SSL加密，确定对话密钥，完成加密后才开始传输数据。")]),t._v(" "),_("li",[t._v("HTTPS协议传输是密文，HTTP协议传输是明文")])]),t._v(" "),_("h3",{attrs:{id:"对称加密和非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密"}},[t._v("#")]),t._v(" 对称加密和非对称加密")]),t._v(" "),_("p",[t._v("同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也被叫做共享密钥加密。这种方法在网络传输中有个问题，就是如何把密钥安全的交付给对方，因为http协议是明文传输（HTTPS协议在建立ssl加密时都是明文传输）,所以密钥很容易被监听截取，从而失去密钥本身的意义了。")]),t._v(" "),_("p",[t._v("假设使用者为服务端，服务端有两个密钥，一个是私钥(只能自己悄悄咪咪看的,可以比喻成钥匙)，一个是公钥（随便哪个看的都行，可以比喻成锁）。\n服务端将公钥发给客户端，客户端使用公钥对要发送的信息进行加密，然后发送给服务器(用锁把数据锁在箱子里)，由于该信息是通过服务端的公钥进行加密的，只有服务端使用自己的私钥才能解析出来(用钥匙打开锁，获取信息)。因为私钥是一直保持在服务端，并且只有私钥才能解析出公钥加密的内容，所以通过该种方法实现了数据的安全传输。")]),t._v(" "),_("p",[t._v("但是由于每次都要使用私钥去解析公钥，才能获取到数据，如果公钥很长的话，其中的运算量会很大，占用CPU性能，从而使得网络延迟加大。")]),t._v(" "),_("p",[t._v("HTTPS协议同时使用了这两种方式，即先通过公开密钥加密的方式产生一个对话密钥，在使用对话密钥进行对称加密的方式传输数据。")]),t._v(" "),_("h3",{attrs:{id:"ssl-tls加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls加密"}},[t._v("#")]),t._v(" SSL/TLS加密")]),t._v(" "),_("p",[t._v("TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。")]),t._v(" "),_("p",[t._v("流程：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("客户端向服务器发送请求，请求中包含")]),t._v(" "),_("ul",[_("li",[t._v("支持的SSL协议版本")]),t._v(" "),_("li",[t._v("客户端生成的随机数（第一个随机数）")]),t._v(" "),_("li",[t._v("支持的加密方法")]),t._v(" "),_("li",[t._v("支持的压缩方法")])])]),t._v(" "),_("li",[_("p",[t._v("服务器接收到客户端请求，并且向客户端发送响应，响应包括")]),t._v(" "),_("ul",[_("li",[t._v("确认协议版本")]),t._v(" "),_("li",[t._v("服务器生产的随机数（第二个随机数）")]),t._v(" "),_("li",[t._v("确定加密的方法")]),t._v(" "),_("li",[t._v("服务器的证书（服务器的公钥在里面）")])])]),t._v(" "),_("li",[_("p",[t._v("客户端接收到请求，对证书进行校验（校验证书的颁布机构，证书中的域名和实际域名是否一致，证书是否过期，如果不符合，浏览器会显示警告）,如果通过了校验,客户端将会发送回应，包括")]),t._v(" "),_("ul",[_("li",[t._v("客户端生成一个随机数，并且该随机数通过服务器的公钥进行加密（第三个随机数）")]),t._v(" "),_("li",[t._v("编码改变通知（表示之后的通信都会通过双方商定的加密算法进行通信）")]),t._v(" "),_("li",[t._v("客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。")])])]),t._v(" "),_("li",[_("p",[t._v("服务器接收到最后的回应之后，使用服务器的私钥来解析出客户端发送过来的第三个随机数，并且使用与客户端约定好的加密算法将一共三个随机数生成对话密钥。服务器返回响应")]),t._v(" "),_("ul",[_("li",[t._v("编码改变通知（表示之后的通信都会通过双方商定的加密算法进行通信）")]),t._v(" "),_("li",[t._v("服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。")])])])]),t._v(" "),_("p",[t._v("加密对话的过程都是明文传输的（因为HTTPS还没搭建起来）。")]),t._v(" "),_("p",[t._v("整个加密过程的核心就是客户端与服务器产生的三个随机数，这三个随机数是用于产生后续数据传输的加密密钥的。从上面的过程可以看出，这三个随机数都是可以别窃取的，但是由于第三个随机数使用了服务器的公钥进行了公开密钥加密传输，理论上只有使用服务器的私钥才能解析出第三个随机数。所以最后使用这三个随机数生成的对话私钥是安全的，之后的数据传输都会使用这个对话私钥进行加密（对称加密），从而保证了传输的安全性又保证了数据传输的效率。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/20191124193110497.png",alt:"流程"}})]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("加密算法")]),t._v(" "),_("p",[t._v("非对称加密算法：RSA，DSA/DSS，用于在握手过程中加密生成的密码。")]),t._v(" "),_("p",[t._v("对称加密算法：AES，RC4，3DES，用于对真正传输的数据进行加密。")]),t._v(" "),_("p",[t._v("HASH算法：MD5，SHA1，SHA256，验证数据的完整性。")])]),t._v(" "),_("h3",{attrs:{id:"加密证书"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加密证书"}},[t._v("#")]),t._v(" 加密证书")]),t._v(" "),_("p",[t._v("证书包括：")]),t._v(" "),_("ul",[_("li",[t._v("证书颁发机构")]),t._v(" "),_("li",[t._v("服务端网址")]),t._v(" "),_("li",[t._v("服务端公钥（机构私钥加密）")]),t._v(" "),_("li",[t._v("证书签名（机构私钥加密）")])]),t._v(" "),_("p",[t._v("当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。\n然后通过证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。")]),t._v(" "),_("h3",{attrs:{id:"在不使用-https-的情况下，http-被劫持了怎么办"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在不使用-https-的情况下，http-被劫持了怎么办"}},[t._v("#")]),t._v(" 在不使用 HTTPS 的情况下，HTTP 被劫持了怎么办")]),t._v(" "),_("p",[t._v("运营商劫持？公信部处理？")]),t._v(" "),_("p",[t._v("运营商劫持又主要分两种：")]),t._v(" "),_("ul",[_("li",[t._v("DNS劫持：这种劫持会把你重新定位到其它网站，我们所熟悉的钓鱼网站就是这个原理。但是因为它的违法性，现在被严厉的监管起来，已经很少见。")]),t._v(" "),_("li",[t._v("HTTP劫持：虽然DNS劫持已经被监管了起来，但是还有HTTP劫持啊！当运营商发现你的是HTTP请求时，就会在里面插入一些奇奇怪怪的广告。并且这种现象十分常见，")])]),t._v(" "),_("p",[t._v("HTTP请求是在网络中是明文传输，而且必须经过运营商，于是运营商层面可以很轻松地修改响应的HTTP内容。比如在返回的HTML里直接加一段JS，JS可以直接在客户端执行实现任何想要的效果。")]),t._v(" "),_("h3",{attrs:{id:"https为什么会多一次请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https为什么会多一次请求"}},[t._v("#")]),t._v(" HTTPS为什么会多一次请求")]),t._v(" "),_("h2",{attrs:{id:"http报文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http报文"}},[t._v("#")]),t._v(" HTTP报文")]),t._v(" "),_("p",[t._v("HTTP报文（在HTTP/2之前）是语义可读的。在HTTP/2中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。")]),t._v(" "),_("p",[t._v("有两种HTTP报文的类型，请求与响应，每种都有其特定的格式。")]),t._v(" "),_("p",[t._v("请求报文由以下元素组成：\n"),_("img",{attrs:{src:"/img/HTTP_Request.png",alt:"请求报文"}})]),t._v(" "),_("ul",[_("li",[t._v("一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。")]),t._v(" "),_("li",[t._v("要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。")]),t._v(" "),_("li",[t._v("HTTP协议版本号。")]),t._v(" "),_("li",[t._v("为服务端表达其他信息的可选头部headers。")]),t._v(" "),_("li",[t._v("对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。")])]),t._v(" "),_("p",[t._v("响应报文包含了下面的元素：\n"),_("img",{attrs:{src:"/img/HTTP_Response.png",alt:"响应报文"}})]),t._v(" "),_("ul",[_("li",[t._v("HTTP协议版本号。")]),t._v(" "),_("li",[t._v("一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。")]),t._v(" "),_("li",[t._v("一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。")]),t._v(" "),_("li",[t._v("HTTP headers，与请求头部类似。")]),t._v(" "),_("li",[t._v("可选项，比起请求报文，响应报文中更常见地包含获取的资源body。")])]),t._v(" "),_("p",[t._v("HTTP 请求和响应具有相似的结构，由以下部分组成︰")]),t._v(" "),_("ul",[_("li",[t._v("一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。")]),t._v(" "),_("li",[t._v("一个可选的HTTP头集合指明请求或描述消息正文。")]),t._v(" "),_("li",[t._v("一个空行指示所有关于请求的元数据已经发送完毕。")]),t._v(" "),_("li",[t._v("一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。")])]),t._v(" "),_("h3",{attrs:{id:"头部组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#头部组成"}},[t._v("#")]),t._v(" 头部组成")]),t._v(" "),_("p",[t._v("起始行和 HTTP 消息中的 HTTP 头统称为请求头，而其有效负载被称为消息正文。")]),t._v(" "),_("p",[t._v("请求起始行：HTTP方法，请求目标（通常是URL），HTTP版本\n响应起始行：协议版本，状态码，状态文本，一个典型的状态行看起来像这样：HTTP/1.1 404 Not Found。")]),t._v(" "),_("h3",{attrs:{id:"说说知道的http头"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说知道的http头"}},[t._v("#")]),t._v(" 说说知道的HTTP头⭐️")]),t._v(" "),_("p",[t._v("根据不同上下文，可将消息头分为：")]),t._v(" "),_("ul",[_("li",[t._v("General headers: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。")]),t._v(" "),_("li",[t._v("Request headers: 包含更多有关要获取的资源或客户端本身信息的消息头。")]),t._v(" "),_("li",[t._v("Response headers: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。")]),t._v(" "),_("li",[t._v("Entity headers: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。")])]),t._v(" "),_("p",[t._v("常见")]),t._v(" "),_("ul",[_("li",[t._v("Accept: 用户代理期望的 MIME 类型列表")]),t._v(" "),_("li",[t._v("Accept-Charset: 列出用户代理支持的字符集")]),t._v(" "),_("li",[t._v("Accept-Encoding: 列出用户代理支持的压缩方法。")]),t._v(" "),_("li",[t._v("Accept-Language: 列出用户代理期望的页面语言。")]),t._v(" "),_("li",[t._v("Content-Type: 指示服务器文档的MIME 类型。帮助用户代理（浏览器）去处理接收到的数据。")]),t._v(" "),_("li",[t._v("Set-Cookie: 用来由服务器端向客户端发送 cookie。")])]),t._v(" "),_("p",[t._v("缓存相关")]),t._v(" "),_("ul",[_("li",[t._v("Cache-Control")]),t._v(" "),_("li",[t._v("ETag")]),t._v(" "),_("li",[t._v("Expires")]),t._v(" "),_("li",[t._v("If-Modified-Since")]),t._v(" "),_("li",[t._v("If-None-Match")]),t._v(" "),_("li",[t._v("Last-Modified")]),t._v(" "),_("li",[t._v("Pragma")])]),t._v(" "),_("p",[t._v("CORS跨域相关")]),t._v(" "),_("ul",[_("li",[t._v("Access-Control-Allow-Credentials，服务端返回的")]),t._v(" "),_("li",[t._v("Access-Control-Allow-Origin")]),t._v(" "),_("li",[t._v("Access-Control-Allow-Methods")]),t._v(" "),_("li",[t._v("Access-Control-Allow-Headers")]),t._v(" "),_("li",[t._v("Access-Control-Max-Age")]),t._v(" "),_("li",[t._v("Access-Control-Expose-Headers")]),t._v(" "),_("li",[t._v("Access-Control-Request-Method，请求发出的")]),t._v(" "),_("li",[t._v("Access-Control-Request-Headers")])]),t._v(" "),_("h3",{attrs:{id:"content-encoding"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#content-encoding"}},[t._v("#")]),t._v(" Content-Encoding")]),t._v(" "),_("p",[t._v("一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 Content-Type 中标示的媒体类型内容。")]),t._v(" "),_("p",[t._v("一般建议对数据尽可能地进行压缩，因此才有了这个消息首部的出现。不过对于特定类型的文件来说，比如jpeg图片文件，已经是进行过压缩的了。有时候再次进行额外的压缩无助于负载体积的减小，反而有可能会使其增大。")]),t._v(" "),_("p",[t._v("采用哪种压缩方式高度依赖于服务器端的设置，及其所采用的模块。")]),t._v(" "),_("p",[t._v("比较常见的有gzip压缩 "),_("code",[t._v("Content-Encoding: gzip")])]),t._v(" "),_("h3",{attrs:{id:"http头设置什么可以用来获取用户ip地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http头设置什么可以用来获取用户ip地址"}},[t._v("#")]),t._v(" HTTP头设置什么可以用来获取用户ip地址⭐️")]),t._v(" "),_("p",[t._v("X-Forwarded-For (XFF) 在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址，这个消息首部成为事实上的标准。在消息流从客户端流向服务器的过程中被拦截的情况下，服务器端的访问日志只能记录代理服务器或者负载均衡服务器的IP地址。如果想要获得最初发起请求的客户端的IP地址的话，那么 X-Forwarded-For 就派上了用场。")]),t._v(" "),_("div",{staticClass:"language-md extra-class"},[_("pre",{pre:!0,attrs:{class:"language-md"}},[_("code",[t._v("X-Forwarded-For: client, proxy1, proxy2\n")])])]),_("h3",{attrs:{id:"x-forwarded-host"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#x-forwarded-host"}},[t._v("#")]),t._v(" X-Forwarded-Host")]),t._v(" "),_("p",[t._v("The X-Forwarded-Host (XFH) 是一个事实上的标准首部，用来确定客户端发起的请求中使用  Host  指定的初始域名。")]),t._v(" "),_("p",[t._v("反向代理（如负载均衡服务器、CDN等）的域名或端口号可能会与处理请求的源头服务器有所不同，在这种情况下，X-Forwarded-Host 可以用来确定哪一个域名是最初被用来访问的。")]),t._v(" "),_("p",[t._v("实例：")]),t._v(" "),_("div",{staticClass:"language-md extra-class"},[_("pre",{pre:!0,attrs:{class:"language-md"}},[_("code",[t._v("X-Forwarded-Host: id42.example-cdn.com\n")])])]),_("h3",{attrs:{id:"header中比较重要的是哪个key-value对？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#header中比较重要的是哪个key-value对？"}},[t._v("#")]),t._v(" Header中比较重要的是哪个key/value对？")]),t._v(" "),_("h3",{attrs:{id:"http的response里面有什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http的response里面有什么"}},[t._v("#")]),t._v(" HTTP的response里面有什么")]),t._v(" "),_("ul",[_("li",[t._v("HTTP协议版本号。")]),t._v(" "),_("li",[t._v("一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。")]),t._v(" "),_("li",[t._v("一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。")]),t._v(" "),_("li",[t._v("HTTP headers，与请求头部类似。")]),t._v(" "),_("li",[t._v("可选项，比起请求报文，响应报文中更常见地包含获取的资源body。")])]),t._v(" "),_("h3",{attrs:{id:"前端如何实现修改http头部"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端如何实现修改http头部"}},[t._v("#")]),t._v(" 前端如何实现修改HTTP头部")]),t._v(" "),_("p",[t._v("XMLHttpRequest.setRequestHeader() 是设置HTTP请求头部的方法。")]),t._v(" "),_("p",[t._v("此方法必须在 open() 方法和 send() 之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。")]),t._v(" "),_("p",[t._v("如果没有设置 Accept 属性，则此发送出send()的值为此属性的默认值*/* 。")]),t._v(" "),_("p",[t._v("安全起见，有些请求头的值只能由user agent设置")]),t._v(" "),_("h2",{attrs:{id:"http1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[t._v("#")]),t._v(" HTTP1.0")]),t._v(" "),_("p",[t._v("HTTP版本发展：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("版本")]),t._v(" "),_("th",[t._v("产生时间")]),t._v(" "),_("th",[t._v("内容")]),t._v(" "),_("th",[t._v("发展现状")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("HTTP/0.9")]),t._v(" "),_("td",[t._v("1991年")]),t._v(" "),_("td",[t._v("不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求；没有作为正式的标准")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("HTTP/1.0")]),t._v(" "),_("td",[t._v("1996年")]),t._v(" "),_("td",[t._v("传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令；正式作为标准")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("HTTP/1.1")]),t._v(" "),_("td",[t._v("1997年")]),t._v(" "),_("td",[t._v("持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码，2015年前使用最广泛")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("HTTP/2")]),t._v(" "),_("td",[t._v("2015年")]),t._v(" "),_("td",[t._v("多路复用、服务器推送、头信息压缩、二进制协议等；逐渐覆盖市场")]),t._v(" "),_("td")])])]),t._v(" "),_("h3",{attrs:{id:"http1-1相关，pipline可以完全解决发送队列队首阻塞的问题吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-1相关，pipline可以完全解决发送队列队首阻塞的问题吗"}},[t._v("#")]),t._v(" HTTP1.1相关，pipline可以完全解决发送队列队首阻塞的问题吗")]),t._v(" "),_("p",[t._v("队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。")]),t._v(" "),_("h3",{attrs:{id:"_1-0版本如何在一次连接进行多个请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-0版本如何在一次连接进行多个请求"}},[t._v("#")]),t._v(" 1.0版本如何在一次连接进行多个请求")]),t._v(" "),_("h2",{attrs:{id:"http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" HTTP2.0")]),t._v(" "),_("p",[t._v("HTTP / 2的主要目标是通过启用完整的请求和响应多路复用来减少 延迟，通过有效压缩HTTP标头字段来最小化协议开销，并增加对请求优先级和服务器推送的支持。")]),t._v(" "),_("p",[t._v("HTTP/2 不会修改 HTTP 协议的语义。 HTTP 1.1中的所有核心概念（例如 HTTP 方法，状态码，URI 和 headers）都得以保留。")]),t._v(" "),_("p",[t._v("而是修改了 HTTP/2 数据在客户端和服务器之间的格式（帧）和传输方式，这两者都管理整个过程，并在新的框架层内隐藏了应用程序的复杂性。 所以，所有现有的应用程序都可以不经修改地交付。")]),t._v(" "),_("p",[t._v("HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header压缩")]),t._v(" "),_("h3",{attrs:{id:"二进制传输"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二进制传输"}},[t._v("#")]),t._v(" 二进制传输")]),t._v(" "),_("p",[t._v("HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。")]),t._v(" "),_("p",[t._v('它把TCP协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame),用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。')]),t._v(" "),_("p",[t._v("HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。")]),t._v(" "),_("h3",{attrs:{id:"头部压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" 头部压缩")]),t._v(" "),_("p",[t._v('HTTP/2并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。')]),t._v(" "),_("p",[t._v("在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；")]),t._v(" "),_("p",[t._v("首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;")]),t._v(" "),_("p",[t._v("每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/p",alt:"请求对比"}})]),t._v(" "),_("h3",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),_("p",[t._v("多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输")]),t._v(" "),_("p",[t._v("原理：\nHTTP/2设计是基于“二进制帧”进行设计的，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。")]),t._v(" "),_("h3",{attrs:{id:"服务端推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务端推送"}},[t._v("#")]),t._v(" 服务端推送")]),t._v(" "),_("p",[t._v('HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）')]),t._v(" "),_("p",[t._v("服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。")]),t._v(" "),_("h4",{attrs:{id:"websocket的双向通信和http2的服务端推送有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#websocket的双向通信和http2的服务端推送有什么区别"}},[t._v("#")]),t._v(" websocket的双向通信和HTTP2的服务端推送有什么区别")]),t._v(" "),_("p",[t._v("HTTP/2 引入了 Server Push ，它使服务器能够主动地将资源推送到客户端缓存。但是，它并不允许将数据推送到客户端应用程序本身。服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知。")]),t._v(" "),_("p",[t._v("一般情况下，只要需要客户端和服务器之间的真正低延迟，接近实时的连接，就使用 WebSocket")]),t._v(" "),_("p",[t._v("如果需要显示实时的市场消息，市场数据，聊天应用程序等，依靠 HTTP/2 + SSE 将为你提供高效的双向通信渠道，同时获得留在 HTTP 领域的各种好处")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/112552_9uYa_2896879.png",alt:"其他对比"}})]),t._v(" "),_("h3",{attrs:{id:"http2-0就真的不会阻塞吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-0就真的不会阻塞吗"}},[t._v("#")]),t._v(" HTTP2.0就真的不会阻塞吗")]),t._v(" "),_("p",[t._v("在TCP阻塞")]),t._v(" "),_("h3",{attrs:{id:"http2-哪些时候会比-http1-慢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2-哪些时候会比-http1-慢"}},[t._v("#")]),t._v(" HTTP2 哪些时候会比 HTTP1 慢⭐️")]),t._v(" "),_("p",[t._v("在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。")]),t._v(" "),_("h2",{attrs:{id:"http3-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http3-0"}},[t._v("#")]),t._v(" HTTP3.0")]),t._v(" "),_("p",[t._v("虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("TCP 以及 TCP+TLS建立连接的延时")]),t._v(" "),_("p",[t._v("HTTP/2都是使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，这样就需要有两个握手延迟过程：")])]),t._v(" "),_("li",[_("p",[t._v("TCP的队头阻塞并没有彻底解决")])])]),t._v(" "),_("p",[t._v("HTTP/3的要点是它使用名为QUIC的新UDP协议代替TCP。")]),t._v(" "),_("h3",{attrs:{id:"特点-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点-3"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("实现了类似TCP的流量控制、传输可靠性的功能")]),t._v(" "),_("p",[t._v("虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。")])]),t._v(" "),_("li",[_("p",[t._v("实现了快速握手功能。")]),t._v(" "),_("p",[t._v("由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。")])]),t._v(" "),_("li",[_("p",[t._v("集成了TLS加密功能。")]),t._v(" "),_("p",[t._v("目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。")])]),t._v(" "),_("li",[_("p",[t._v("多路复用，彻底解决TCP中队头阻塞的问题")]),t._v(" "),_("p",[t._v("和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。")]),t._v(" "),_("p",[t._v("队头阻塞问题可能存在于HTTP层和TCP层")])])]),t._v(" "),_("h3",{attrs:{id:"tcp复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp复用"}},[t._v("#")]),t._v(" TCP复用")]),t._v(" "),_("h3",{attrs:{id:"quic"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#quic"}},[t._v("#")]),t._v(" quic")]),t._v(" "),_("p",[t._v("Quick UDP Internet Connections")])])}),[],!1,null,null,null);v.default=e.exports}}]);