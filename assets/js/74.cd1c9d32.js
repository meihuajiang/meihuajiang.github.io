(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{346:function(t,a,v){"use strict";v.r(a);var o=v(9),e=Object(o.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("说明")]),t._v(" "),v("p",[t._v("文档查阅")])]),t._v(" "),v("h2",{attrs:{id:"window对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window对象"}},[t._v("#")]),t._v(" Window对象")]),t._v(" "),v("p",[t._v("浏览器里面，window对象指当前的浏览器窗口。")]),t._v(" "),v("p",[t._v("它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。")]),t._v(" "),v("p",[t._v("一个变量如果未声明，那么默认就是顶层对象的属性。")]),t._v(" "),v("blockquote",[v("p",[t._v("块级的除外")])]),t._v(" "),v("p",[t._v("window对象当作顶层对象，所有未声明就赋值的变量都自动变成window对象的属性。")]),t._v(" "),v("blockquote",[v("p",[t._v("这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。")])]),t._v(" "),v("h3",{attrs:{id:"属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[t._v("#")]),t._v(" 属性")]),t._v(" "),v("h4",{attrs:{id:"window-name"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-name"}},[t._v("#")]),t._v(" window.name")]),t._v(" "),v("p",[t._v("window.name属性是一个字符串，表示当前浏览器窗口的名字。")]),t._v(" "),v("p",[t._v("窗口不一定需要名字，这个属性主要配合超链接和表单的target属性使用。")]),t._v(" "),v("p",[t._v("该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。")]),t._v(" "),v("p",[t._v("只要浏览器窗口不关闭，这个属性是不会消失的。")]),t._v(" "),v("h4",{attrs:{id:"window-opener"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-opener"}},[t._v("#")]),t._v(" window.opener")]),t._v(" "),v("p",[t._v("表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回null。")]),t._v(" "),v("p",[t._v("如果两个窗口之间不需要通信，建议将子窗口的opener属性显式设为null")]),t._v(" "),v("p",[t._v('a元素添加rel="noopener"属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。')]),t._v(" "),v("h4",{attrs:{id:"window-self，window-window"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-self，window-window"}},[t._v("#")]),t._v(" window.self，window.window")]),t._v(" "),v("p",[t._v("window.self和window.window属性都指向窗口本身。这两个属性只读。")]),t._v(" "),v("h4",{attrs:{id:"window-top，window-parent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-top，window-parent"}},[t._v("#")]),t._v(" window.top，window.parent")]),t._v(" "),v("p",[t._v("window.top属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。")]),t._v(" "),v("p",[t._v("window.parent属性指向父窗口。如果当前窗口没有父窗口，window.parent指向自身。")]),t._v(" "),v("h3",{attrs:{id:"全局对象属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局对象属性"}},[t._v("#")]),t._v(" 全局对象属性")]),t._v(" "),v("p",[t._v("全局对象属性指向一些浏览器原生的全局对象。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("window.document：")]),t._v(" "),v("p",[t._v("指向document对象注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。")])]),t._v(" "),v("li",[v("p",[t._v("window.location：")]),t._v(" "),v("p",[t._v("指向Location对象，用于获取当前窗口的 URL 信息。它等同于document.location属性")])]),t._v(" "),v("li",[v("p",[t._v("window.navigator：")]),t._v(" "),v("p",[t._v("指向Navigator对象，用于获取环境信息")])]),t._v(" "),v("li",[v("p",[t._v("window.history：")]),t._v(" "),v("p",[t._v("指向History对象，表示浏览器的浏览历史")])]),t._v(" "),v("li",[v("p",[t._v("window.localStorage：")]),t._v(" "),v("p",[t._v("指向本地储存的 localStorage 数据")])]),t._v(" "),v("li",[v("p",[t._v("window.sessionStorage：")]),t._v(" "),v("p",[t._v("指向本地储存的 sessionStorage 数据")])]),t._v(" "),v("li",[v("p",[t._v("window.console：")]),t._v(" "),v("p",[t._v("指向console对象，用于操作控制台")])]),t._v(" "),v("li",[v("p",[t._v("window.screen：")]),t._v(" "),v("p",[t._v("指向Screen对象，表示屏幕信息")])])]),t._v(" "),v("h3",{attrs:{id:"window-getcomputedstyle-，window-matchmedia"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-getcomputedstyle-，window-matchmedia"}},[t._v("#")]),t._v(" window.getComputedStyle()，window.matchMedia()")]),t._v(" "),v("p",[t._v("window.getComputedStyle()方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象")]),t._v(" "),v("p",[t._v("window.matchMedia()方法用来检查 CSS 的mediaQuery语句")]),t._v(" "),v("h3",{attrs:{id:"window-requestanimationframe"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-requestanimationframe"}},[t._v("#")]),t._v(" window.requestAnimationFrame()⭐️")]),t._v(" "),v("p",[t._v("window.requestAnimationFrame()方法跟setTimeout类似，都是推迟某个函数的执行。")]),t._v(" "),v("p",[t._v("setTimeout必须指定推迟的时间，window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。")]),t._v(" "),v("p",[t._v("重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率")]),t._v(" "),v("blockquote",[v("p",[t._v("比如网页切换到后台 Tab 页时，requestAnimationFrame()会暂停执行。")])]),t._v(" "),v("p",[t._v("如果某个函数会改变网页的布局，一般就放在window.requestAnimationFrame()里面执行，这样可以节省系统资源，使得网页效果更加平滑。")]),t._v(" "),v("p",[t._v("因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。")]),t._v(" "),v("p",[t._v("该方法接受一个回调函数作为参数。")]),t._v(" "),v("p",[v("code",[t._v("window.requestAnimationFrame(callback)")])]),t._v(" "),v("p",[t._v("callback是一个回调函数。callback执行时，它的参数就是系统传入的一个高精度时间戳（performance.now()的返回值），单位是毫秒，表示距离网页加载的时间。")]),t._v(" "),v("p",[t._v("window.requestAnimationFrame()的返回值是一个整数，这个整数可以传入window.cancelAnimationFrame()，用来取消回调函数的执行。")]),t._v(" "),v("h3",{attrs:{id:"window-requestidlecallback"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#window-requestidlecallback"}},[t._v("#")]),t._v(" window.requestIdleCallback()")]),t._v(" "),v("p",[t._v("window.requestIdleCallback()跟setTimeout类似，也是将某个函数推迟执行")]),t._v(" "),v("p",[t._v("但是它保证将回调函数推迟到系统资源空闲时执行。")]),t._v(" "),v("p",[t._v("也就是说，如果某个任务不是很关键，就可以使用window.requestIdleCallback()将其推迟执行，以保证网页性能。")]),t._v(" "),v("p",[t._v("它跟window.requestAnimationFrame()的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；window.requestIdleCallback()可以保证回调函数在系统资源空闲时执行。")]),t._v(" "),v("p",[t._v("该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。")]),t._v(" "),v("p",[v("code",[t._v("window.requestIdleCallback(callback[, options])")])]),t._v(" "),v("p",[t._v("callback参数是一个回调函数。该回调函数执行时，系统会传入一个IdleDeadline对象作为参数。")]),t._v(" "),v("p",[t._v("IdleDeadline对象有一个didTimeout属性（布尔值，表示是否为超时调用）和一个timeRemaining()方法（返回该空闲时段剩余的毫秒数）。")]),t._v(" "),v("p",[t._v("options参数是一个配置对象，目前只有timeout一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。")]),t._v(" "),v("p",[t._v("window.requestIdleCallback()方法返回一个整数。该整数可以传入window.cancelIdleCallback()取消回调函数。")]),t._v(" "),v("p",[t._v("如果多次执行window.requestIdleCallback()，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行")]),t._v(" "),v("h3",{attrs:{id:"load-事件和-onload-属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#load-事件和-onload-属性"}},[t._v("#")]),t._v(" load 事件和 onload 属性")]),t._v(" "),v("p",[t._v("load事件发生在文档在浏览器窗口加载完毕时。window.onload属性可以指定这个事件的回调函数。")]),t._v(" "),v("h2",{attrs:{id:"history对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history对象"}},[t._v("#")]),t._v(" History对象")]),t._v(" "),v("p",[t._v("window.history属性指向 History 对象，它表示当前窗口的浏览历史。")]),t._v(" "),v("h3",{attrs:{id:"属性-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-2"}},[t._v("#")]),t._v(" 属性")]),t._v(" "),v("p",[t._v("History 对象主要有两个属性。")]),t._v(" "),v("ul",[v("li",[t._v("History.length：当前窗口访问过的网址数量（包括当前网页）")]),t._v(" "),v("li",[t._v("History.state：History 堆栈最上层的状态值")])]),t._v(" "),v("h3",{attrs:{id:"history-back"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history-back"}},[t._v("#")]),t._v(" History.back()")]),t._v(" "),v("p",[t._v("History.back()：移动到上一个网址，等同于点击浏览器的后退键。")]),t._v(" "),v("p",[t._v("对于第一个访问的网址，该方法无效果。")]),t._v(" "),v("p",[v("strong",[t._v("注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。")])]),t._v(" "),v("h3",{attrs:{id:"history-forward"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history-forward"}},[t._v("#")]),t._v(" History.forward()")]),t._v(" "),v("p",[t._v("History.forward()：移动到下一个网址，等同于点击浏览器的前进键。")]),t._v(" "),v("p",[t._v("对于最后一个访问的网址，该方法无效果。")]),t._v(" "),v("h3",{attrs:{id:"history-go"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history-go"}},[t._v("#")]),t._v(" History.go()")]),t._v(" "),v("p",[t._v("History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，")]),t._v(" "),v("p",[t._v("比如go(1)相当于forward()，go(-1)相当于back()。")]),t._v(" "),v("p",[t._v("如果参数超过实际存在的网址范围，该方法无效果；")]),t._v(" "),v("p",[t._v("如果不指定参数，默认参数为0，相当于刷新当前页面。")]),t._v(" "),v("h3",{attrs:{id:"history-pushstate-，"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history-pushstate-，"}},[t._v("#")]),t._v(" History.pushState()，")]),t._v(" "),v("p",[t._v("History.pushState()方法用于在历史中添加一条记录。")]),t._v(" "),v("p",[v("code",[t._v("window.history.pushState(state, title, url)")])]),t._v(" "),v("p",[t._v("该方法接受三个参数，依次为：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("state：")]),t._v(" "),v("p",[t._v("一个与添加的记录相关联的状态对象，主要用于popstate事件。")]),t._v(" "),v("p",[t._v("该事件触发时，该对象会传入回调函数。")]),t._v(" "),v("p",[t._v("也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。")]),t._v(" "),v("p",[t._v("如果不需要这个对象，此处可以填null。")]),t._v(" "),v("p",[t._v("用History.state属性读出状态对象。")])]),t._v(" "),v("li",[v("p",[t._v("title：")]),t._v(" "),v("p",[t._v("新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。")])]),t._v(" "),v("li",[v("p",[t._v("url：")]),t._v(" "),v("p",[t._v("新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。")]),t._v(" "),v("p",[t._v("如果设置了一个新的锚点值（即hash），并不会触发hashchange事件")]),t._v(" "),v("p",[t._v("反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。")])])]),t._v(" "),v("p",[t._v("添加新记录后，浏览器地址栏立刻显示新URL，但并不会跳转，甚至也不会检查URL是否存在，它只是成为浏览历史中的最新记录。")]),t._v(" "),v("p",[v("strong",[t._v("总之，pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。")])]),t._v(" "),v("p",[t._v("如果pushState()方法设置了一个跨域网址，则会报错。")]),t._v(" "),v("h3",{attrs:{id:"history-replacestate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history-replacestate"}},[t._v("#")]),t._v(" History.replaceState()")]),t._v(" "),v("p",[t._v("History.replaceState()方法用来修改 History 对象的当前记录，其他都与pushState()方法一模一样。")]),t._v(" "),v("h3",{attrs:{id:"popstate-事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#popstate-事件"}},[t._v("#")]),t._v(" popstate 事件")]),t._v(" "),v("p",[t._v("每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。")]),t._v(" "),v("p",[v("strong",[t._v("注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件")])]),t._v(" "),v("p",[t._v("只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。")]),t._v(" "),v("p",[t._v("另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。")]),t._v(" "),v("p",[t._v("使用的时候，可以为popstate事件指定回调函数。")]),t._v(" "),v("h2",{attrs:{id:"url对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#url对象"}},[t._v("#")]),t._v(" URL对象")]),t._v(" "),v("h3",{attrs:{id:"encodeuri"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#encodeuri"}},[t._v("#")]),t._v(" encodeURI()")]),t._v(" "),v("p",[t._v("encodeURI()方法用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。")]),t._v(" "),v("h3",{attrs:{id:"encodeuricomponent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#encodeuricomponent"}},[t._v("#")]),t._v(" encodeURIComponent()")]),t._v(" "),v("p",[t._v("encodeURIComponent()方法用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。")]),t._v(" "),v("p",[t._v("所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。")]),t._v(" "),v("h3",{attrs:{id:"decodeuri"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#decodeuri"}},[t._v("#")]),t._v(" decodeURI()")]),t._v(" "),v("p",[t._v("decodeURI()方法用于整个 URL 的解码。它是encodeURI()方法的逆运算。它接受一个参数，就是转码后的 URL。")]),t._v(" "),v("h3",{attrs:{id:"decodeuricomponent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#decodeuricomponent"}},[t._v("#")]),t._v(" decodeURIComponent()")]),t._v(" "),v("p",[t._v("decodeURIComponent()用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。它接受一个参数，就是转码后的 URL 片段")]),t._v(" "),v("h2",{attrs:{id:"location对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#location对象"}},[t._v("#")]),t._v(" Location对象")]),t._v(" "),v("p",[t._v("Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。")]),t._v(" "),v("p",[v("strong",[t._v("通过window.location和document.location属性，可以拿到这个对象。")])]),t._v(" "),v("h3",{attrs:{id:"属性-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-3"}},[t._v("#")]),t._v(" 属性")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("属性")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Location.href")]),t._v(" "),v("td",[t._v("整个 URL。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.protocol")]),t._v(" "),v("td",[t._v("当前 URL 的协议，包括冒号（:）。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.host")]),t._v(" "),v("td",[t._v("主机。如果端口不是协议默认的80和433，则还会包括冒号（:）和端口。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.hostname")]),t._v(" "),v("td",[t._v("主机名，不包括端口。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.port")]),t._v(" "),v("td",[t._v("端口号。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.pathname")]),t._v(" "),v("td",[t._v("URL 的路径部分，从根路径/开始。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.search")]),t._v(" "),v("td",[t._v("查询字符串部分，从问号?开始。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.hash")]),t._v(" "),v("td",[t._v("片段字符串部分，从#开始。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.username")]),t._v(" "),v("td",[t._v("域名前面的用户名。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.password")]),t._v(" "),v("td",[t._v("域名前面的密码。")])]),t._v(" "),v("tr",[v("td",[t._v("Location.origin")]),t._v(" "),v("td",[t._v("URL 的协议、主机名和端口。")])])])]),t._v(" "),v("p",[t._v("如果对Location.href写入新的 URL 地址，浏览器会立刻跳转到这个新地址。")]),t._v(" "),v("blockquote",[v("p",[t._v("这个特性常常用于让网页自动滚动到新的锚点")])]),t._v(" "),v("p",[t._v("直接改写location，相当于写入href属性。")]),t._v(" "),v("p",[t._v("Location.href属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口的Location.href属性")]),t._v(" "),v("h3",{attrs:{id:"location-assign"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#location-assign"}},[t._v("#")]),t._v(" Location.assign()")]),t._v(" "),v("p",[t._v("assign方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。")]),t._v(" "),v("h3",{attrs:{id:"location-replace"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#location-replace"}},[t._v("#")]),t._v(" Location.replace()")]),t._v(" "),v("p",[t._v("replace方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。")]),t._v(" "),v("p",[t._v("它与assign方法的差异在于，replace会在浏览器的浏览历史History里面删除当前网址，")]),t._v(" "),v("p",[t._v("也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。")]),t._v(" "),v("p",[v("strong",[t._v("它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。")])]),t._v(" "),v("h3",{attrs:{id:"location-reload"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#location-reload"}},[t._v("#")]),t._v(" Location.reload()")]),t._v(" "),v("p",[t._v("reload方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。")]),t._v(" "),v("p",[t._v("它接受一个布尔值作为参数。如果参数为true，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即scrollTop === 0）。")]),t._v(" "),v("p",[t._v("如果参数是false或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。")]),t._v(" "),v("h3",{attrs:{id:"location-tostring"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#location-tostring"}},[t._v("#")]),t._v(" Location.toString()")]),t._v(" "),v("p",[t._v("toString方法返回整个 URL 字符串，相当于读取Location.href属性。")]),t._v(" "),v("h2",{attrs:{id:"navigator对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator对象"}},[t._v("#")]),t._v(" Navigator对象")]),t._v(" "),v("p",[t._v("window.navigator属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。")]),t._v(" "),v("h3",{attrs:{id:"属性-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-4"}},[t._v("#")]),t._v(" 属性")]),t._v(" "),v("h4",{attrs:{id:"navigator-useragent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-useragent"}},[t._v("#")]),t._v(" Navigator.userAgent")]),t._v(" "),v("p",[t._v("navigator.userAgent属性返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。")]),t._v(" "),v("p",[t._v("通过userAgent属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串")]),t._v(" "),v("p",[t._v("通过userAgent可以大致准确地识别手机浏览器，方法就是测试是否包含mobi字符串。")]),t._v(" "),v("h4",{attrs:{id:"navigator-serviceworker-只读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-serviceworker-只读"}},[t._v("#")]),t._v(" Navigator.serviceWorker 只读")]),t._v(" "),v("p",[t._v("返回ServiceWorkerContainer 对象用于提供注册、删除、更新以及为了associated document的ServiceWorker对象之间的通信。")]),t._v(" "),v("h4",{attrs:{id:"navigator-platform"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-platform"}},[t._v("#")]),t._v(" Navigator.platform")]),t._v(" "),v("p",[t._v("Navigator.platform属性返回用户的操作系统信息，比如MacIntel、Win32、Linux x86_64等 。")]),t._v(" "),v("h4",{attrs:{id:"navigator-online"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-online"}},[t._v("#")]),t._v(" Navigator.onLine")]),t._v(" "),v("p",[t._v("navigator.onLine属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。")]),t._v(" "),v("p",[t._v("浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的onLine属性会返回true，所以不能假定只要是true，用户就一定能访问互联网。")]),t._v(" "),v("p",[t._v("不过，如果是false，可以断定用户一定离线。")]),t._v(" "),v("p",[t._v("用户变成在线会触发online事件，变成离线会触发offline事件，可以通过window.ononline和window.onoffline指定这两个事件的回调函数。")]),t._v(" "),v("h4",{attrs:{id:"navigator-language，navigator-languages"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-language，navigator-languages"}},[t._v("#")]),t._v(" Navigator.language，Navigator.languages")]),t._v(" "),v("p",[t._v("Navigator.language属性返回一个字符串，表示浏览器的首选语言。该属性只读。")]),t._v(" "),v("p",[t._v("Navigator.languages属性返回一个数组，表示用户可以接受的语言。")]),t._v(" "),v("p",[t._v("Navigator.language总是这个数组的第一个成员。")]),t._v(" "),v("p",[t._v("HTTP 请求头信息的Accept-Language字段，就来自这个数组。")]),t._v(" "),v("h4",{attrs:{id:"navigator-geolocation"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-geolocation"}},[t._v("#")]),t._v(" Navigator.geolocation")]),t._v(" "),v("p",[t._v("Navigator.geolocation属性返回一个 Geolocation 对象，包含用户地理位置的信息。")]),t._v(" "),v("p",[t._v("注意，该 API 只有在 HTTPS 协议下可用，否则调用下面方法时会报错。")]),t._v(" "),v("p",[t._v("Geolocation 对象提供下面三个方法。")]),t._v(" "),v("ul",[v("li",[t._v("Geolocation.getCurrentPosition()：得到用户的当前位置")]),t._v(" "),v("li",[t._v("Geolocation.watchPosition()：监听用户位置变化")]),t._v(" "),v("li",[t._v("Geolocation.clearWatch()：取消watchPosition()方法指定的监听函数")])]),t._v(" "),v("p",[t._v("注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。")]),t._v(" "),v("h4",{attrs:{id:"navigator-cookieenabled"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#navigator-cookieenabled"}},[t._v("#")]),t._v(" Navigator.cookieEnabled⭐️")]),t._v(" "),v("p",[t._v("navigator.cookieEnabled属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。")]),t._v(" "),v("p",[t._v("这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。")]),t._v(" "),v("p",[t._v("用户可以设置某个网站不得储存 Cookie，这时cookieEnabled返回的还是true。")]),t._v(" "),v("h2",{attrs:{id:"screen对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#screen对象"}},[t._v("#")]),t._v(" Screen对象")]),t._v(" "),v("p",[t._v("Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。window.screen属性指向这个对象。")]),t._v(" "),v("p",[t._v("该对象有下面的属性。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Screen.height：")]),t._v(" "),v("p",[t._v("浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。")]),t._v(" "),v("p",[t._v("显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。")])]),t._v(" "),v("li",[v("p",[t._v("Screen.width：")]),t._v(" "),v("p",[t._v("浏览器窗口所在的屏幕的宽度（单位像素）。")])]),t._v(" "),v("li",[v("p",[t._v("Screen.availHeight：")]),t._v(" "),v("p",[t._v("浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于height减去那些被系统组件的高度。")])]),t._v(" "),v("li",[v("p",[t._v("Screen.availWidth：")]),t._v(" "),v("p",[t._v("浏览器窗口可用的屏幕宽度（单位像素）。")])]),t._v(" "),v("li",[v("p",[t._v("Screen.pixelDepth：")]),t._v(" "),v("p",[t._v("整数，表示屏幕的色彩位数，比如24表示屏幕提供24位色彩。")])]),t._v(" "),v("li",[v("p",[t._v("Screen.colorDepth：")]),t._v(" "),v("p",[t._v("Screen.pixelDepth的别名。严格地说，colorDepth 表示应用程序的颜色深度，pixelDepth 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。")])]),t._v(" "),v("li",[v("p",[t._v("Screen.orientation：")]),t._v(" "),v("p",[t._v("返回一个对象，表示屏幕的方向。该对象的type属性是一个字符串，表示屏幕的具体方向")]),t._v(" "),v("p",[t._v("landscape-primary表示横放，landscape-secondary表示颠倒的横放")]),t._v(" "),v("p",[t._v("portrait-primary表示竖放，portrait-secondary表示颠倒的竖放。")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);