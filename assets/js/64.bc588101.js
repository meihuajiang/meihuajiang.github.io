(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{334:function(v,t,e){"use strict";e.r(t);var _=e(9),a=Object(_.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[v._v("说明")]),v._v(" "),e("p",[v._v("查阅文档使用")])]),v._v(" "),e("h2",{attrs:{id:"eventtarget"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget"}},[v._v("#")]),v._v(" EventTarget")]),v._v(" "),e("p",[v._v("DOM 的事件操作（监听和触发），都定义在EventTarget接口。")]),v._v(" "),e("p",[v._v("所有节点对象都部署了这个接口")]),v._v(" "),e("p",[v._v("其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。")]),v._v(" "),e("p",[v._v("该接口主要提供三个实例方法。")]),v._v(" "),e("ul",[e("li",[v._v("addEventListener：绑定事件的监听函数")]),v._v(" "),e("li",[v._v("removeEventListener：移除事件的监听函数")]),v._v(" "),e("li",[v._v("dispatchEvent：触发事件")])]),v._v(" "),e("h2",{attrs:{id:"eventtarget-addeventlistener"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-addeventlistener"}},[v._v("#")]),v._v(" EventTarget.addEventListener()")]),v._v(" "),e("p",[v._v("EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。")]),v._v(" "),e("p",[v._v("一旦这个事件发生，就会执行监听函数。该方法没有返回值。")]),v._v(" "),e("p",[e("code",[v._v("target.addEventListener(type, listener[, useCapture]);")])]),v._v(" "),e("p",[v._v("该方法接受三个参数。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("type：")]),v._v(" "),e("p",[v._v("事件名称，大小写敏感。")])]),v._v(" "),e("li",[e("p",[v._v("listener：")]),v._v(" "),e("p",[v._v("监听函数。事件发生时，会调用该监听函数。还可以是一个具有handleEvent方法的对象。")]),v._v(" "),e("p",[v._v("如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。")]),v._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("function")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[v._v("x")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n\tconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("var")]),v._v(" el "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" document"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("getElementById")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'div1'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\nel"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("addEventListener")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'click'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("function")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'Hello'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("false")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),e("p",[e("strong",[v._v("监听函数内部的this，指向当前事件所在的那个对象。")])])]),v._v(" "),e("li",[e("p",[v._v("useCapture：")]),v._v(" "),e("p",[v._v("布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。该参数可选。")]),v._v(" "),e("p",[v._v("第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。")]),v._v(" "),e("ul",[e("li",[v._v("capture：布尔值，表示该事件是否在捕获阶段触发监听函数。")]),v._v(" "),e("li",[v._v("once：布尔值，表示监听函数是否只触发一次，然后就自动移除。")]),v._v(" "),e("li",[v._v("passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。")])])])]),v._v(" "),e("p",[v._v("addEventListener方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。")]),v._v(" "),e("p",[e("strong",[v._v("这些函数按照添加顺序触发，即先添加先触发。")])]),v._v(" "),e("p",[v._v("如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除")]),v._v(" "),e("p",[e("strong",[v._v("绑定在被点击元素的事件是按照代码的顺序发生的，其他非绑定的元素则是通过冒泡或者捕获的触发。按照W3C的标准，先发生捕获事件，后发生冒泡事件")])]),v._v(" "),e("blockquote",[e("p",[v._v("比如，点击div2，div2的事件是按代码的顺序发生的，div1是先发生捕获事件，再发生冒泡事件")])]),v._v(" "),e("h2",{attrs:{id:"eventtarget-removeeventlistener"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-removeeventlistener"}},[v._v("#")]),v._v(" EventTarget.removeEventListener()")]),v._v(" "),e("p",[v._v("EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。")]),v._v(" "),e("p",[v._v("注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。")]),v._v(" "),e("blockquote",[e("p",[v._v("第三个参数也要一致")])]),v._v(" "),e("h2",{attrs:{id:"eventtarget-dispatchevent"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-dispatchevent"}},[v._v("#")]),v._v(" EventTarget.dispatchEvent()")]),v._v(" "),e("p",[v._v("EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。")]),v._v(" "),e("p",[v._v("该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。")]),v._v(" "),e("p",[v._v("参数是一个event对象实例")]),v._v(" "),e("h2",{attrs:{id:"监听函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#监听函数"}},[v._v("#")]),v._v(" 监听函数⭐️")]),v._v(" "),e("p",[v._v("浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。")]),v._v(" "),e("p",[v._v("事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。")]),v._v(" "),e("p",[v._v("这是事件驱动编程模式（event-driven）的主要编程方式。")]),v._v(" "),e("p",[v._v("JavaScript 有三种方法，可以为事件绑定监听函数。")]),v._v(" "),e("h3",{attrs:{id:"html-的-on-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html-的-on-属性"}},[v._v("#")]),v._v(" HTML 的 on- 属性")]),v._v(" "),e("p",[v._v("HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。")]),v._v(" "),e("p",[v._v("元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。")]),v._v(" "),e("p",[v._v("注意，这些属性的值是将会执行的代码，而不是一个函数。")]),v._v(" "),e("p",[v._v("使用这个方法指定的监听代码，只会在冒泡阶段触发。")]),v._v(" "),e("p",[v._v("直接设置on-属性，与通过元素节点的setAttribute方法设置on-属性，效果是一样的。")]),v._v(" "),e("p",[e("strong",[v._v("违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。")])]),v._v(" "),e("h3",{attrs:{id:"元素节点的事件属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素节点的事件属性"}},[v._v("#")]),v._v(" 元素节点的事件属性")]),v._v(" "),e("p",[v._v("元素节点对象的事件属性，同样可以指定监听函数。")]),v._v(" "),e("p",[v._v("使用这个方法指定的监听函数，也是只会在冒泡阶段触发。")]),v._v(" "),e("p",[v._v("注意，"),e("strong",[v._v("这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。")])]),v._v(" "),e("p",[e("strong",[v._v("缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。")])]),v._v(" "),e("h3",{attrs:{id:"eventtarget-addeventlistener-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventtarget-addeventlistener-2"}},[v._v("#")]),v._v(" EventTarget.addEventListener()")]),v._v(" "),e("p",[v._v("所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。")]),v._v(" "),e("p",[e("code",[v._v("window.addEventListener('load', doSomething, false);")])]),v._v(" "),e("p",[v._v("EventTarget.addEventListener是推荐的指定监听函数的方法。")]),v._v(" "),e("p",[v._v("它有如下优点：")]),v._v(" "),e("ul",[e("li",[v._v("同一个事件可以添加多个监听函数。")]),v._v(" "),e("li",[v._v("能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。")]),v._v(" "),e("li",[v._v("除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。")])]),v._v(" "),e("h2",{attrs:{id:"event对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event对象"}},[v._v("#")]),v._v(" event对象")]),v._v(" "),e("p",[v._v("事件发生以后，会产生一个事件对象，作为参数传给监听函数。")]),v._v(" "),e("p",[v._v("浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。")]),v._v(" "),e("p",[v._v("Event对象本身就是一个构造函数，可以用来生成新的实例。")]),v._v(" "),e("p",[e("code",[v._v("event = new Event(type, options);")])]),v._v(" "),e("p",[v._v("Event构造函数接受两个参数。")]),v._v(" "),e("p",[v._v("第一个参数type是字符串，表示事件的名称；")]),v._v(" "),e("p",[v._v("第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("bubbles：")]),v._v(" "),e("p",[v._v("布尔值，可选，默认为false，表示事件对象是否冒泡。")]),v._v(" "),e("p",[v._v("如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数。")]),v._v(" "),e("p",[v._v("addEventListener()的useCapture默认是冒泡阶段触发")])]),v._v(" "),e("li",[e("p",[v._v("cancelable：")]),v._v(" "),e("p",[v._v("布尔值，可选，默认为false，表示事件是否可以被取消，即能否用Event.preventDefault()取消这个事件。")]),v._v(" "),e("p",[v._v("一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。")])])]),v._v(" "),e("h3",{attrs:{id:"实例属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例属性"}},[v._v("#")]),v._v(" 实例属性")]),v._v(" "),e("h4",{attrs:{id:"event-cancelable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-cancelable"}},[v._v("#")]),v._v(" Event.cancelable")]),v._v(" "),e("p",[v._v("Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性")]),v._v(" "),e("p",[v._v("大多数浏览器的原生事件是可以取消的。比如，取消click事件，点击链接将无效。")]),v._v(" "),e("p",[v._v("但是除非显式声明，Event构造函数生成的事件，默认是不可以取消的。")]),v._v(" "),e("p",[e("strong",[v._v("当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。")])]),v._v(" "),e("p",[v._v("如果事件不能取消，调用Event.preventDefault()会没有任何效果。")]),v._v(" "),e("h4",{attrs:{id:"event-cancelbubble"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-cancelbubble"}},[v._v("#")]),v._v(" Event.cancelBubble")]),v._v(" "),e("p",[v._v("Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。")]),v._v(" "),e("h4",{attrs:{id:"event-defaultprevented"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-defaultprevented"}},[v._v("#")]),v._v(" event.defaultPrevented")]),v._v(" "),e("p",[v._v("Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。")]),v._v(" "),e("h4",{attrs:{id:"event-detail"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-detail"}},[v._v("#")]),v._v(" Event.detail")]),v._v(" "),e("p",[v._v("Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。")]),v._v(" "),e("p",[v._v("比如，对于click和dblclick事件，Event.detail是鼠标按下的次数（1表示单击，2表示双击，3表示三击）；")]),v._v(" "),e("p",[v._v("对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。")]),v._v(" "),e("h4",{attrs:{id:"event-timestamp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-timestamp"}},[v._v("#")]),v._v(" Event.timeStamp")]),v._v(" "),e("p",[v._v("Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。")]),v._v(" "),e("h2",{attrs:{id:"表单事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表单事件"}},[v._v("#")]),v._v(" 表单事件")]),v._v(" "),e("h3",{attrs:{id:"input事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input事件"}},[v._v("#")]),v._v(" input事件")]),v._v(" "),e("p",[v._v("input事件当"),e("strong",[v._v("input、select、textarea")]),v._v("的值发生变化时触发。")]),v._v(" "),e("p",[v._v("对于复选框（input type=checkbox）或单选框（input type=radio），用户改变选项时，也会触发这个事件。")]),v._v(" "),e("p",[v._v("另外，对于打开contenteditable属性的元素，只要值发生变化，也会触发input事件。")]),v._v(" "),e("p",[e("strong",[v._v("input事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次input事件。")])]),v._v(" "),e("p",[v._v("该事件跟change事件很像，不同之处在于input事件在元素的值发生变化后立即发生，而change在元素失去焦点时发生，而内容此时可能已经变化多次。")]),v._v(" "),e("p",[e("strong",[v._v("如果有连续变化，input事件会触发多次，而change事件只在失去焦点时触发一次。")])]),v._v(" "),e("h3",{attrs:{id:"change-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#change-事件"}},[v._v("#")]),v._v(" change 事件")]),v._v(" "),e("p",[v._v("change事件当input、select、textarea的值发生变化时触发。")]),v._v(" "),e("p",[v._v("它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，")]),v._v(" "),e("p",[v._v("另一方面"),e("strong",[v._v("input事件必然伴随change事件。")])]),v._v(" "),e("p",[v._v("具体来说，分成以下几种情况。")]),v._v(" "),e("ul",[e("li",[v._v("激活单选框（radio）或复选框（checkbox）时触发。")]),v._v(" "),e("li",[v._v("用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。")]),v._v(" "),e("li",[v._v("当文本框或textarea元素的值发生改变，并且丧失焦点时触发。")])]),v._v(" "),e("p",[v._v("对于select元素来说，input和change事件基本是等价的。")]),v._v(" "),e("h3",{attrs:{id:"select-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#select-事件"}},[v._v("#")]),v._v(" select 事件")]),v._v(" "),e("p",[v._v("select事件当在input、textarea里面选中文本时触发。")]),v._v(" "),e("p",[v._v("选中的文本可以通过event.target元素的selectionDirection、selectionEnd、selectionStart和value属性拿到。")]),v._v(" "),e("h3",{attrs:{id:"invalid-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#invalid-事件"}},[v._v("#")]),v._v(" invalid 事件")]),v._v(" "),e("p",[v._v("用户提交表单时，如果表单元素的值不满足校验条件，就会触发invalid事件。")]),v._v(" "),e("h3",{attrs:{id:"reset-事件，submit-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reset-事件，submit-事件"}},[v._v("#")]),v._v(" reset 事件，submit 事件")]),v._v(" "),e("p",[v._v("这两个事件发生在表单对象form上，而不是发生在表单的成员上。")]),v._v(" "),e("p",[v._v("reset事件当表单重置（所有表单成员变回默认值）时触发。")]),v._v(" "),e("p",[v._v("submit事件当表单数据向服务器提交时触发。")]),v._v(" "),e("p",[v._v("注意，submit事件的发生对象是form元素，而不是button元素，因为提交的是表单，而不是按钮。")]),v._v(" "),e("h3",{attrs:{id:"inputevent-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#inputevent-接口"}},[v._v("#")]),v._v(" InputEvent 接口")]),v._v(" "),e("p",[v._v("InputEvent接口主要用来描述input事件的实例。该接口继承了Event接口，还定义了一些自己的实例属性和实例方法。")]),v._v(" "),e("p",[v._v("浏览器原生提供InputEvent()构造函数，用来生成实例对象。")]),v._v(" "),e("p",[e("code",[v._v("new InputEvent(type, options)")])]),v._v(" "),e("p",[v._v("InputEvent构造函数可以接受两个参数。")]),v._v(" "),e("p",[v._v("第一个参数是字符串，表示事件名称，该参数是必需的。")]),v._v(" "),e("p",[v._v("第二个参数是一个配置对象，用来设置事件实例的属性，")]),v._v(" "),e("p",[v._v("该参数是可选的。配置对象的字段除了Event构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("inputType：")]),v._v(" "),e("p",[v._v("字符串，表示发生变更的类型。")]),v._v(" "),e("ul",[e("li",[v._v("手动插入文本：insertText")]),v._v(" "),e("li",[v._v("粘贴插入文本：insertFromPaste")]),v._v(" "),e("li",[v._v("向后删除：deleteContentBackward")]),v._v(" "),e("li",[v._v("向前删除：deleteContentForward")])])]),v._v(" "),e("li",[e("p",[v._v("data：")]),v._v(" "),e("p",[v._v("字符串，表示插入的字符串。如果没有插入的字符串（比如删除操作），则返回null或空字符串。")])]),v._v(" "),e("li",[e("p",[v._v("dataTransfer：")]),v._v(" "),e("p",[v._v("返回一个 DataTransfer 对象实例，该属性通常只在输入框接受富文本输入时有效。")])])]),v._v(" "),e("h2",{attrs:{id:"资源事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资源事件"}},[v._v("#")]),v._v(" 资源事件")]),v._v(" "),e("h3",{attrs:{id:"beforeunload-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#beforeunload-事件"}},[v._v("#")]),v._v(" beforeunload 事件")]),v._v(" "),e("p",[v._v("beforeunload事件在窗口、文档、各种资源将要卸载前触发。")]),v._v(" "),e("p",[v._v("它可以用来防止用户不小心卸载资源。")]),v._v(" "),e("p",[v._v("如果该事件对象的returnValue属性是一个非空字符串，那么浏览器就会弹出一个对话框并显示，询问用户是否要卸载该资源。")]),v._v(" "),e("p",[v._v("但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。")]),v._v(" "),e("p",[v._v("一旦使用了beforeunload事件，浏览器就不会缓存当前网页，使用“回退”按钮将重新向服务器请求网页。")]),v._v(" "),e("h3",{attrs:{id:"unload-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unload-事件"}},[v._v("#")]),v._v(" unload 事件")]),v._v(" "),e("p",[v._v("unload事件在窗口关闭或者document对象将要卸载时触发。")]),v._v(" "),e("p",[v._v("它的触发顺序排在beforeunload、pagehide事件后面。")]),v._v(" "),e("p",[v._v("unload事件发生时，文档处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI 互动全部无效。")]),v._v(" "),e("p",[v._v("这个事件是无法取消的，即使在监听函数里面抛出错误，也不能停止文档的卸载。")]),v._v(" "),e("p",[v._v("该事件可以用pagehide代替")]),v._v(" "),e("h3",{attrs:{id:"load-事件，error-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#load-事件，error-事件"}},[v._v("#")]),v._v(" load 事件，error 事件")]),v._v(" "),e("p",[v._v("load事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发load事件。")]),v._v(" "),e("p",[v._v("error事件是在页面或资源加载失败时触发。abort事件在用户取消加载时触发。")]),v._v(" "),e("p",[v._v("这三个事件实际上属于进度事件")]),v._v(" "),e("p",[v._v("页面的load事件也可以用pageshow事件代替。")]),v._v(" "),e("h2",{attrs:{id:"session历史事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#session历史事件"}},[v._v("#")]),v._v(" session历史事件⭐️")]),v._v(" "),e("h3",{attrs:{id:"pageshow-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pageshow-事件"}},[v._v("#")]),v._v(" pageshow 事件")]),v._v(" "),e("p",[v._v("默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。")]),v._v(" "),e("p",[v._v("pageshow事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。")]),v._v(" "),e("p",[v._v("如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。")]),v._v(" "),e("p",[v._v("第一次加载时，它的触发顺序排在load事件后面。")]),v._v(" "),e("p",[v._v("从缓存加载时，load事件不会触发，因为网页在缓存中的样子通常是load事件的监听函数运行后的样子，所以不必重复执行。")]),v._v(" "),e("p",[v._v("同理，"),e("strong",[v._v("如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。")])]),v._v(" "),e("p",[v._v("pageshow事件有一个persisted属性，返回一个布尔值。页面第一次加载时，这个属性是false；当页面从缓存加载时，这个属性是true。")]),v._v(" "),e("p",[e("strong",[v._v("只在浏览器的history对象发生变化时触发，跟网页是否可见没有关系。")])]),v._v(" "),e("h3",{attrs:{id:"pagehide-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pagehide-事件"}},[v._v("#")]),v._v(" pagehide 事件")]),v._v(" "),e("p",[v._v("pagehide事件与pageshow事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。")]),v._v(" "),e("p",[v._v("它与 unload 事件的区别在于，如果在 window 对象上定义unload事件的监听函数之后，页面不会保存在缓存中，而使用pagehide事件，页面会保存在缓存中。")]),v._v(" "),e("p",[v._v("pagehide事件实例也有一个persisted属性，将这个属性设为true，就表示页面要保存在缓存中；设为false，表示网页不保存在缓存中")]),v._v(" "),e("p",[v._v("这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。")]),v._v(" "),e("p",[e("strong",[v._v("只在浏览器的history对象发生变化时触发，跟网页是否可见没有关系。")])]),v._v(" "),e("h3",{attrs:{id:"popstate-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#popstate-事件"}},[v._v("#")]),v._v(" popstate 事件")]),v._v(" "),e("p",[v._v("popstate事件在浏览器的history对象的当前记录发生显式切换时触发。")]),v._v(" "),e("p",[v._v("注意，调用history.pushState()或history.replaceState()，并不会触发popstate事件。")]),v._v(" "),e("p",[v._v("该事件只在用户在history记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用history.back()、history.forward()、history.go()时触发。")]),v._v(" "),e("p",[v._v("该事件对象有一个state属性，保存history.pushState方法和history.replaceState方法为当前记录添加的state对象。")]),v._v(" "),e("h3",{attrs:{id:"hashchange-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashchange-事件"}},[v._v("#")]),v._v(" hashchange 事件")]),v._v(" "),e("p",[v._v("hashchange事件在 URL 的 hash 部分（即#号后面的部分，包括#号）发生变化时触发。")]),v._v(" "),e("p",[v._v("该事件一般在window对象上监听。")]),v._v(" "),e("p",[v._v("hashchange的事件实例具有两个特有属性：oldURL属性和newURL属性，分别表示变化前后的完整 URL。")]),v._v(" "),e("h2",{attrs:{id:"鼠标事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#鼠标事件"}},[v._v("#")]),v._v(" 鼠标事件")]),v._v(" "),e("p",[v._v("鼠标事件指与鼠标相关的事件，继承了MouseEvent接口。具体的事件主要有以下一些。")]),v._v(" "),e("p",[v._v("|事件|描述|\n|click|按下鼠标（通常是按下主按钮）时触发。|\n|dblclick|在同一个元素上双击鼠标时触发。|\n|mousedown|按下鼠标键时触发。|\n|mouseup|释放按下的鼠标键时触发。|\n|mousemove|当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。（需要考虑性能问题）|\n|mouseenter|鼠标进入一个节点时触发，进入子节点不会触发这个事件|\n|mouseover|鼠标进入一个节点时触发，进入子节点会再一次触发这个事件|\n|mouseout|鼠标离开一个节点时触发，离开父节点也会触发这个事件|\n|mouseleave|鼠标离开一个节点时触发，离开父节点不会触发这个事件|\n|contextmenu|按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。|\n|wheel|滚动鼠标的滚轮时触发，该事件继承的是WheelEvent接口。|")]),v._v(" "),e("h3",{attrs:{id:"click事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#click事件"}},[v._v("#")]),v._v(" click事件")]),v._v(" "),e("p",[v._v("click事件指的是，用户在同一个位置先完成mousedown动作，再完成mouseup动作。")]),v._v(" "),e("p",[e("strong",[v._v("触发顺序是，mousedown首先触发，mouseup接着触发，click最后触发。")])]),v._v(" "),e("p",[e("strong",[v._v("dblclick事件则会在mousedown、mouseup、click之后触发。")])]),v._v(" "),e("h3",{attrs:{id:"mouseover事件和mouseenter事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mouseover事件和mouseenter事件"}},[v._v("#")]),v._v(" mouseover事件和mouseenter事件")]),v._v(" "),e("p",[v._v("mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。")]),v._v(" "),e("p",[v._v("两者的区别是：")]),v._v(" "),e("ul",[e("li",[v._v("mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。")]),v._v(" "),e("li",[v._v("在父节点内部进入子节点，不会触发mouseenter事件，但是会触发mouseover事件。")])]),v._v(" "),e("h3",{attrs:{id:"mouseout事件和mouseleave事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mouseout事件和mouseleave事件"}},[v._v("#")]),v._v(" mouseout事件和mouseleave事件")]),v._v(" "),e("p",[v._v("mouseout事件和mouseleave事件，都是鼠标离开一个节点时触发。")]),v._v(" "),e("p",[v._v("两者的区别是，在父元素内部离开一个子元素时，mouseleave事件不会触发，而mouseout事件会触发。")]),v._v(" "),e("h3",{attrs:{id:"mouseevent接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mouseevent接口"}},[v._v("#")]),v._v(" MouseEvent接口")]),v._v(" "),e("p",[v._v("浏览器原生提供一个MouseEvent构造函数，用于新建一个MouseEvent实例。")]),v._v(" "),e("p",[e("code",[v._v("var event = new MouseEvent(type, options);")])]),v._v(" "),e("p",[v._v("MouseEvent构造函数接受两个参数。")]),v._v(" "),e("p",[v._v("第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。")]),v._v(" "),e("p",[v._v("除了Event接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("screenX：")]),v._v(" "),e("p",[v._v("数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。")])]),v._v(" "),e("li",[e("p",[v._v("screenY：")]),v._v(" "),e("p",[v._v("数值，鼠标相对于屏幕的垂直位置（单位像素），其他与screenX相同。")])]),v._v(" "),e("li",[e("p",[v._v("clientX：")]),v._v(" "),e("p",[v._v("数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。")])]),v._v(" "),e("li",[e("p",[v._v("clientY：")]),v._v(" "),e("p",[v._v("数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与clientX相同。")])]),v._v(" "),e("li",[e("p",[v._v("ctrlKey：")]),v._v(" "),e("p",[v._v("布尔值，是否同时按下了 Ctrl 键，默认值为false。")])]),v._v(" "),e("li",[e("p",[v._v("shiftKey：")]),v._v(" "),e("p",[v._v("布尔值，是否同时按下了 Shift 键，默认值为false。")])]),v._v(" "),e("li",[e("p",[v._v("altKey：")]),v._v(" "),e("p",[v._v("布尔值，是否同时按下 Alt 键，默认值为false。")])]),v._v(" "),e("li",[e("p",[v._v("metaKey：")]),v._v(" "),e("p",[v._v("布尔值，是否同时按下 Meta 键，默认值为false。")])]),v._v(" "),e("li",[e("p",[v._v("button：")]),v._v(" "),e("p",[v._v("数值，表示按下了哪一个鼠标按键")]),v._v(" "),e("p",[v._v("默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；")]),v._v(" "),e("p",[v._v("1表示按下辅助键（通常是鼠标的中间键）")]),v._v(" "),e("p",[v._v("2表示按下次要键（通常是鼠标的右键）。")])]),v._v(" "),e("li",[e("p",[v._v("buttons：")]),v._v(" "),e("p",[v._v("数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。")]),v._v(" "),e("p",[v._v("1（二进制001）表示按下主键（通常是左键）")]),v._v(" "),e("p",[v._v("2（二进制010）表示按下次要键（通常是右键）")]),v._v(" "),e("p",[v._v("4（二进制100）表示按下辅助键（通常是中间键）")]),v._v(" "),e("p",[v._v("因此，如果返回3（二进制011）就表示同时按下了左键和右键。")])]),v._v(" "),e("li",[e("p",[v._v("relatedTarget：")]),v._v(" "),e("p",[v._v("节点对象，表示事件的相关节点，默认为null。")]),v._v(" "),e("p",[v._v("mouseenter和mouseover事件时，表示鼠标刚刚离开的那个元素节点；")]),v._v(" "),e("p",[v._v("mouseout和mouseleave事件时，表示鼠标正在进入的那个元素节点。")])])]),v._v(" "),e("h4",{attrs:{id:"各种位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#各种位置"}},[v._v("#")]),v._v(" 各种位置")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("MouseEvent.clientX，MouseEvent.clientY")]),v._v(" "),e("p",[v._v("MouseEvent.clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素）")]),v._v(" "),e("p",[v._v("MouseEvent.clientY属性返回垂直坐标。这两个属性都是只读属性。")])]),v._v(" "),e("li",[e("p",[v._v("MouseEvent.movementX，MouseEvent.movementY")]),v._v(" "),e("p",[v._v("MouseEvent.movementX属性返回当前位置与上一个mousemove事件之间的水平距离（单位像素）。")]),v._v(" "),e("p",[e("code",[v._v("currentEvent.movementX = currentEvent.screenX - previousEvent.screenX")])]),v._v(" "),e("p",[v._v("MouseEvent.movementY属性返回当前位置与上一个mousemove事件之间的垂直距离（单位像素）。")]),v._v(" "),e("p",[e("code",[v._v("currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。")])])]),v._v(" "),e("li",[e("p",[v._v("MouseEvent.screenX，MouseEvent.screenY")]),v._v(" "),e("p",[v._v("MouseEvent.screenX属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素）")]),v._v(" "),e("p",[v._v("MouseEvent.screenY属性返回垂直坐标。")]),v._v(" "),e("p",[v._v("两个属性都是只读属性")])]),v._v(" "),e("li",[e("p",[v._v("MouseEvent.offsetX，MouseEvent.offsetY")]),v._v(" "),e("p",[v._v("MouseEvent.offsetX属性返回鼠标位置与目标节点左侧的padding边缘的水平距离（单位像素）")]),v._v(" "),e("p",[v._v("MouseEvent.offsetY属性返回与目标节点上方的padding边缘的垂直距离。")]),v._v(" "),e("p",[v._v("这两个属性都是只读属性。")])]),v._v(" "),e("li",[e("p",[v._v("MouseEvent.pageX，MouseEvent.pageY")]),v._v(" "),e("p",[v._v("MouseEvent.pageX属性返回鼠标位置与文档左侧边缘的距离（单位像素）")]),v._v(" "),e("p",[v._v("MouseEvent.pageY属性返回与文档上侧边缘的距离（单位像素）。")]),v._v(" "),e("p",[v._v("它们的返回值都包括文档不可见的部分。这两个属性都是只读。")])])]),v._v(" "),e("h2",{attrs:{id:"globaleventhandlers"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#globaleventhandlers"}},[v._v("#")]),v._v(" GlobalEventHandlers")]),v._v(" "),e("p",[v._v("还有一种方法可以直接指定事件的回调函数。")]),v._v(" "),e("p",[e("code",[v._v("div.onclick = clickHandler;")])]),v._v(" "),e("p",[v._v("这个接口是由GlobalEventHandlers接口提供的。")]),v._v(" "),e("p",[v._v("它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("鼠标的事件属性")]),v._v(" "),e("th",[v._v("键盘的事件属性")]),v._v(" "),e("th",[v._v("焦点的事件属性")]),v._v(" "),e("th",[v._v("表单的事件属性")]),v._v(" "),e("th",[v._v("触摸的事件属性")]),v._v(" "),e("th",[v._v("被拖动元素的事件属性")]),v._v(" "),e("th",[v._v("接收被拖动元素的容器元素的事件属性")]),v._v(" "),e("th",[v._v("对话框元素的事件属性")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("onclick")]),v._v(" "),e("td",[v._v("onkeydown")]),v._v(" "),e("td",[v._v("onblur")]),v._v(" "),e("td",[v._v("oninput")]),v._v(" "),e("td",[v._v("ontouchcancel")]),v._v(" "),e("td",[v._v("ondragstart")]),v._v(" "),e("td",[v._v("ondragenter")]),v._v(" "),e("td",[v._v("oncancel")])]),v._v(" "),e("tr",[e("td",[v._v("ondblclick")]),v._v(" "),e("td",[v._v("onkeypress")]),v._v(" "),e("td",[v._v("onfocus")]),v._v(" "),e("td",[v._v("onchange")]),v._v(" "),e("td",[v._v("ontouchend")]),v._v(" "),e("td",[v._v("ondrag")]),v._v(" "),e("td",[v._v("ondragleave")]),v._v(" "),e("td",[v._v("onclose")])]),v._v(" "),e("tr",[e("td",[v._v("onmousedown")]),v._v(" "),e("td",[v._v("onkeyup")]),v._v(" "),e("td"),v._v(" "),e("td",[v._v("onsubmit")]),v._v(" "),e("td",[v._v("ontouchmove")]),v._v(" "),e("td",[v._v("ondragend")]),v._v(" "),e("td",[v._v("ondragover")]),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onmouseenter")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td",[v._v("onreset")]),v._v(" "),e("td",[v._v("ontouchstart")]),v._v(" "),e("td"),v._v(" "),e("td",[v._v("ondrop")]),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onmouseleave")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td",[v._v("oninvalid")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onmousemove")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td",[v._v("onselect")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onmouseout")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onmouseover")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onmouseup")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td")]),v._v(" "),e("tr",[e("td",[v._v("onwheel")]),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td"),v._v(" "),e("td")])])]),v._v(" "),e("h2",{attrs:{id:"键盘事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#键盘事件"}},[v._v("#")]),v._v(" 键盘事件")]),v._v(" "),e("p",[v._v("键盘事件由用户击打键盘触发，主要有keydown、keypress、keyup三个事件")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("keydown：")]),v._v(" "),e("p",[v._v("按下键盘时触发。")])]),v._v(" "),e("li",[e("p",[v._v("keypress：")]),v._v(" "),e("p",[v._v("按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。")]),v._v(" "),e("p",[v._v("对于有值的键，按下时先触发keydown事件，再触发这个事件。")])]),v._v(" "),e("li",[e("p",[v._v("keyup：")]),v._v(" "),e("p",[v._v("松开键盘时触发该事件。")]),v._v(" "),e("p",[v._v("如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。")]),v._v(" "),e("ol",[e("li",[v._v("keydown")]),v._v(" "),e("li",[v._v("keypress")]),v._v(" "),e("li",[v._v("keydown")]),v._v(" "),e("li",[v._v("keypress")]),v._v(" "),e("li",[v._v("...（重复以上过程）")]),v._v(" "),e("li",[v._v("keyup")])])])]),v._v(" "),e("h3",{attrs:{id:"keyboardevent-的实例属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-的实例属性"}},[v._v("#")]),v._v(" KeyboardEvent 的实例属性")]),v._v(" "),e("h4",{attrs:{id:"keyboardevent-altkey，keyboardevent-ctrlkey，keyboardevent-metakey，keyboardevent-shiftkey"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-altkey，keyboardevent-ctrlkey，keyboardevent-metakey，keyboardevent-shiftkey"}},[v._v("#")]),v._v(" KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey")]),v._v(" "),e("p",[v._v("以下属性都是只读属性，返回一个布尔值，表示是否按下对应的键。")]),v._v(" "),e("ul",[e("li",[v._v("KeyboardEvent.altKey：是否按下 Alt 键")]),v._v(" "),e("li",[v._v("KeyboardEvent.ctrlKey：是否按下 Ctrl 键")]),v._v(" "),e("li",[v._v("KeyboardEvent.metaKey：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）")]),v._v(" "),e("li",[v._v("KeyboardEvent.shiftKey：是否按下 Shift 键")])]),v._v(" "),e("h4",{attrs:{id:"keyboardevent-code"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-code"}},[v._v("#")]),v._v(" KeyboardEvent.code")]),v._v(" "),e("p",[v._v("KeyboardEvent.code属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。")]),v._v(" "),e("p",[v._v("下面是一些常用键的字符串形式")]),v._v(" "),e("ul",[e("li",[v._v("数字键0 - 9：返回digit0 - digit9")]),v._v(" "),e("li",[v._v("字母键A - z：返回KeyA - KeyZ")]),v._v(" "),e("li",[v._v("功能键F1 - F12：返回 F1 - F12")]),v._v(" "),e("li",[v._v("方向键：返回ArrowDown、ArrowUp、ArrowLeft、ArrowRight")]),v._v(" "),e("li",[v._v("Alt 键：返回AltLeft或AltRight")]),v._v(" "),e("li",[v._v("Shift 键：返回ShiftLeft或ShiftRight")]),v._v(" "),e("li",[v._v("Ctrl 键：返回ControlLeft或ControlRight")])]),v._v(" "),e("h4",{attrs:{id:"keyboardevent-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keyboardevent-key"}},[v._v("#")]),v._v(" KeyboardEvent.key")]),v._v(" "),e("p",[v._v("KeyboardEvent.key属性返回一个字符串，表示按下的键名。该属性只读。")]),v._v(" "),e("p",[v._v("如果按下的键代表可打印字符，则返回这个字符，比如数字、字母。")]),v._v(" "),e("p",[v._v("如果按下的键代表不可打印的特殊字符，则返回预定义的键值")]),v._v(" "),e("h2",{attrs:{id:"进度事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进度事件"}},[v._v("#")]),v._v(" 进度事件")]),v._v(" "),e("p",[v._v("进度事件用来描述资源加载的进度，img、audio、video、style、link等外部资源的加载触发")]),v._v(" "),e("p",[v._v("主要包含以下几种事件。")]),v._v(" "),e("ul",[e("li",[v._v("abort：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。")]),v._v(" "),e("li",[v._v("error：由于错误导致外部资源无法加载时触发。")]),v._v(" "),e("li",[v._v("load：外部资源加载成功时触发。")]),v._v(" "),e("li",[v._v("loadstart：外部资源开始加载时触发。")]),v._v(" "),e("li",[v._v("loadend：外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面。")]),v._v(" "),e("li",[v._v("progress：外部资源加载过程中不断触发。")]),v._v(" "),e("li",[v._v("timeout：加载超时时触发。")])]),v._v(" "),e("p",[e("strong",[v._v("注意，除了资源下载，文件上传也存在这些事件。")])]),v._v(" "),e("h3",{attrs:{id:"progressevent-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#progressevent-接口"}},[v._v("#")]),v._v(" ProgressEvent 接口")]),v._v(" "),e("p",[v._v("ProgressEvent接口主要用来描述外部资源加载的进度")]),v._v(" "),e("p",[v._v("浏览器原生提供了ProgressEvent()构造函数，用来生成事件实例。")]),v._v(" "),e("p",[e("code",[v._v("new ProgressEvent(type, options)")])]),v._v(" "),e("p",[v._v("ProgressEvent()构造函数接受两个参数。")]),v._v(" "),e("p",[v._v("第一个参数是字符串，表示事件的类型，这个参数是必须的。")]),v._v(" "),e("p",[v._v("第二个参数是一个配置对象，表示事件的属性，该参数可选。")]),v._v(" "),e("p",[v._v("配置对象除了可以使用Event接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。")]),v._v(" "),e("ul",[e("li",[v._v("lengthComputable：布尔值，表示加载的总量是否可以计算，默认是false。")]),v._v(" "),e("li",[v._v("loaded：整数，表示已经加载的量，默认是0。")]),v._v(" "),e("li",[v._v("total：整数，表示需要加载的总量，默认是0")])]),v._v(" "),e("p",[v._v("如果ProgressEvent.lengthComputable为false，ProgressEvent.total实际上是没有意义的。")]),v._v(" "),e("h2",{attrs:{id:"窗口事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#窗口事件"}},[v._v("#")]),v._v(" 窗口事件")]),v._v(" "),e("h3",{attrs:{id:"scroll-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scroll-事件"}},[v._v("#")]),v._v(" scroll 事件")]),v._v(" "),e("p",[v._v("scroll事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条")]),v._v(" "),e("p",[e("code",[v._v("window.addEventListener('scroll', callback);")])]),v._v(" "),e("p",[v._v("该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。")]),v._v(" "),e("p",[v._v("推荐的做法是使用requestAnimationFrame或setTimeout控制该事件的触发频率")]),v._v(" "),e("h3",{attrs:{id:"resize-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#resize-事件"}},[v._v("#")]),v._v(" resize 事件")]),v._v(" "),e("p",[v._v("resize事件在改变浏览器窗口大小时触发，主要发生在window对象上面")]),v._v(" "),e("h3",{attrs:{id:"fullscreenchange-事件，fullscreenerror-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fullscreenchange-事件，fullscreenerror-事件"}},[v._v("#")]),v._v(" fullscreenchange 事件，fullscreenerror 事件")]),v._v(" "),e("p",[v._v("fullscreenchange事件在进入或退出全屏状态时触发，该事件发生在document对象上面。")]),v._v(" "),e("h2",{attrs:{id:"触摸事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触摸事件"}},[v._v("#")]),v._v(" 触摸事件")]),v._v(" "),e("p",[v._v("浏览器的触摸 API 由三个部分组成。")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Touch")]),v._v("：一个触摸点")]),v._v(" "),e("li",[e("code",[v._v("TouchList")]),v._v("：多个触摸点的集合")]),v._v(" "),e("li",[e("code",[v._v("TouchEvent")]),v._v("：触摸引发的事件实例")])]),v._v(" "),e("p",[v._v("触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。")]),v._v(" "),e("p",[v._v("这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。")]),v._v(" "),e("p",[v._v("如果想避免这种情况，可以用"),e("code",[v._v("event.preventDefault")]),v._v("方法阻止发出鼠标事件。")]),v._v(" "),e("h3",{attrs:{id:"触摸事件的种类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触摸事件的种类"}},[v._v("#")]),v._v(" 触摸事件的种类")]),v._v(" "),e("p",[v._v("触摸引发的事件，有以下几种。可以通过TouchEvent.type属性，查看到底发生的是哪一种事件。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("touchstart：")]),v._v(" "),e("p",[v._v("用户开始触摸时触发，它的target属性返回发生触摸的元素节点。")])]),v._v(" "),e("li",[e("p",[v._v("touchend：")]),v._v(" "),e("p",[v._v("用户不再接触触摸屏时（或者移出屏幕边缘时）触发")]),v._v(" "),e("p",[v._v("它的target属性与touchstart事件一致的，就是开始触摸时所在的元素节点。")]),v._v(" "),e("p",[v._v("它的changedTouches属性返回一个TouchList实例，包含所有不再触摸的触摸点（即Touch实例对象）。")])]),v._v(" "),e("li",[e("p",[v._v("touchmove：")]),v._v(" "),e("p",[v._v("用户移动触摸点时触发，它的target属性与touchstart事件一致。")]),v._v(" "),e("p",[v._v("如果触摸的半径、角度、力度发生变化，也会触发该事件。")])]),v._v(" "),e("li",[e("p",[v._v("touchcancel：")]),v._v(" "),e("p",[v._v("触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。")])])]),v._v(" "),e("h2",{attrs:{id:"拖拉事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拖拉事件"}},[v._v("#")]),v._v(" 拖拉事件")]),v._v(" "),e("p",[v._v("拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。")]),v._v(" "),e("p",[v._v("拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。")]),v._v(" "),e("p",[v._v("在网页中，除了元素节点默认不可以拖拉")]),v._v(" "),e("p",[v._v("其他（图片、链接、选中的文字）都可以直接拖拉。")]),v._v(" "),e("p",[e("strong",[v._v("为了让元素节点可拖拉，可以将该节点的draggable属性设为true。")])]),v._v(" "),e("p",[v._v("draggable属性可用于任何元素节点，但是图片（img）和链接（a）不加这个属性，就可以拖拉。")]),v._v(" "),e("blockquote",[e("p",[v._v("对于它们，用到这个属性的时候，往往是将其设为false，防止拖拉这两种元素。")])]),v._v(" "),e("p",[v._v("一旦某个元素节点的draggable属性设为true，就无法再用鼠标选中该节点内部的文字或子节点了。")]),v._v(" "),e("h3",{attrs:{id:"拖拉事件种类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拖拉事件种类"}},[v._v("#")]),v._v(" 拖拉事件种类")]),v._v(" "),e("p",[v._v("当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("drag：")]),v._v(" "),e("p",[v._v("拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。")])]),v._v(" "),e("li",[e("p",[v._v("dragstart：")]),v._v(" "),e("p",[v._v("用户开始拖拉时，在被拖拉的节点上触发，")]),v._v(" "),e("p",[v._v("该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。")])]),v._v(" "),e("li",[e("p",[v._v("dragend：")]),v._v(" "),e("p",[v._v("拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。")]),v._v(" "),e("p",[v._v("它与dragstart事件，在同一个节点上触发。")]),v._v(" "),e("p",[v._v("不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。")])]),v._v(" "),e("li",[e("p",[v._v("dragenter：")]),v._v(" "),e("p",[v._v("拖拉进入当前节点时，在当前节点上触发一次，该事件的target属性是当前节点。")]),v._v(" "),e("p",[v._v("通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。")]),v._v(" "),e("p",[v._v("如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。")]),v._v(" "),e("p",[v._v("在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。")])]),v._v(" "),e("li",[e("p",[v._v("dragover：")]),v._v(" "),e("p",[v._v("拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒）")]),v._v(" "),e("p",[v._v("该事件的target属性是当前节点。")]),v._v(" "),e("p",[v._v("该事件与dragenter事件的区别是，dragenter事件在进入该节点时触发，然后只要没有离开这个节点，dragover事件会持续触发。")])]),v._v(" "),e("li",[e("p",[v._v("dragleave：")]),v._v(" "),e("p",[v._v("拖拉操作离开当前节点范围时，在当前节点上触发，")]),v._v(" "),e("p",[v._v("该事件的target属性是当前节点。")]),v._v(" "),e("p",[v._v("如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。")])]),v._v(" "),e("li",[e("p",[v._v("drop：")]),v._v(" "),e("p",[v._v("被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。")]),v._v(" "),e("p",[v._v("注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。")]),v._v(" "),e("p",[v._v("如果用户按下 ESC 键，取消这个操作，也不会触发该事件。")]),v._v(" "),e("p",[v._v("该事件的监听函数负责取出拖拉数据，并进行相关处理。")])])]),v._v(" "),e("p",[v._v("dragenter和dragover事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。")]),v._v(" "),e("p",[v._v("由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。")]),v._v(" "),e("p",[v._v("如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。")]),v._v(" "),e("h3",{attrs:{id:"datatransfer-接口概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#datatransfer-接口概述"}},[v._v("#")]),v._v(" DataTransfer 接口概述")]),v._v(" "),e("p",[v._v("所有拖拉事件的实例都有一个DragEvent.dataTransfer属性，用来读写需要传递的数据。")]),v._v(" "),e("p",[v._v("这个属性的值是一个DataTransfer接口的实例。")]),v._v(" "),e("p",[v._v("拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。")]),v._v(" "),e("p",[v._v("数据的种类是一个 MIME 字符串（比如text/plain、image/jpeg），数据的值是一个字符串。")]),v._v(" "),e("p",[v._v("一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。")]),v._v(" "),e("p",[v._v("拖拉事件开始时，开发者可以提供数据类型和数据值。")]),v._v(" "),e("p",[v._v("拖拉过程中，开发者通过dragenter和dragover事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。")]),v._v(" "),e("p",[v._v("比如，在只允许放下链接的区域，检查拖拉的数据类型是否为text/uri-list。")]),v._v(" "),e("p",[v._v("发生drop事件时，监听函数取出拖拉的数据，对其进行处理。")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://wangdoc.com/javascript/events/drag.html#datatransfer-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0",target:"_blank",rel:"noopener noreferrer"}},[v._v('"DataTransfer详情"'),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);